<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css新世界笔记]]></title>
    <url>%2FCSS%E6%96%B0%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS新世界是知名博主张鑫旭CSS世界三部曲的最后一部，主要讲述CSS3及其之后很多实用的新特性，介绍了很多潜藏的特性和有用的细节。CSS世界介绍的是CSS2.1规范及其之前内容，CSS选择器世界介绍的是CSS LV1-LV4的选择器知识，CSS新世界介绍的是CSS3及其之后的知识。 CSS基础知识 CSS全局关键字属性值 inherit 继承关键字 实现属性继承，如input { font-family: inherit;height:inherit } initial 初始关键字 适合用在需要重置某些CSS样式，但又不记得初始值的场景，如ul { font-size: 14px } ul li:last-child { font-size: initial } unset 不固定值关键字 只有配合all属性使用才有意义，批量重置内置样式，如dialog { all: unset } revert 恢复关键字 让当前元素的样式还原成浏览器内置的样式，如ol { list-style-type: repeat } @supports规则用来检测当前浏览器是否支持某个CSS新特性1234567891011121314151617181920212223242526&lt;style&gt;/* 支持网格布局 */@supports (display:grid) &#123; .item &#123; background:red &#125; &#125;/* 不支持网格布局 */@supports not (display:grid) &#123; .item &#123; background:red &#125; &#125;/* 同时支持弹性布局和网格布局 */@supports (display:flex) and (display:grid) &#123; .item &#123; background:red &#125; &#125;/* 支持弹性布局或网格布局 */@supports (display:flex) or (display:grid) &#123; .item &#123; background:red &#125; &#125;/* 支持弹性布局 但不支持网格布局 */@supports (display:flex) and (not (display:grid)) &#123; .item &#123; background:red &#125; &#125;/* @supports规则的大括号里 可以包含其他@规则*/@supports (display:flex) &#123; @media screen and (max-width: 750px) &#123;&#125; @supports (animation: none) &#123; .box &#123; animation: skip &#125;&#125; @keyframes skip &#123;&#125;&#125;&lt;/style&gt;&lt;!-- 浏览器还提供了CSS.supports()方法，用来在javascript代码中检测当前浏览器是否支持某个CSS特性--&gt;&lt;script&gt;// CSS.supports(propertyName, value)if (window.CSS || CSS.supports || CSS.supports('position', 'sticky'))&#123; document.getElementById('box').style.position = 'sticky'&#125;&lt;/script&gt; 增强的CSS属性 fit-content关键字 实现元素尺寸的自适应 12345678&lt;!-- 设置元素的width或height为fit-content关键字后，元素的尺寸就是里面内容的尺寸 --&gt;&lt;!-- 使用width:fit-content加margin:0 auto实现单行文字居中，多行文字居左对齐 --&gt;&lt;div class="box"&gt;单行文字居中，多行文字居左对齐&lt;/div&gt;&lt;style&gt;.box &#123; width:fit-content; margin:0 auto; &#125;/* fit-content关键字的兼容性处理 IE浏览器、Edge79之前不支持 但可以用在移动端 */.ex &#123; width:-webkit-fit-content; width:-moz-fit-content;width:fit-content; &#125;&lt;/style&gt; position:sticky 黏性定位 123黏性定位：当元素在屏幕内时，随屏幕滚动;当元素滚出屏幕时，元素变成固定定位黏性定位过去都是使用javascript实现，在现代浏览器可以使用position: sticky实现在使用position: sticky时，务必保证黏性定位元素的祖先元素没有可滚动元素 currentColor 关键字 12345&lt;!-- currentColor 表示当前元素所使用的color属性的计算值 --&gt;&lt;div class="box"&gt;currentColor 使用当前color相同的颜色&lt;/div&gt;&lt;style&gt;.box &#123; color: red; border: 1px solid currentColor; /* 边框的颜色和文字颜色一致*/ &#125;&lt;/style&gt; zoom 缩放 除Firefox外其他浏览器都支持 12345语法 zoom: normal | reset | &lt;number&gt; | &lt;percentage&gt;zoom 和 scale 的区别1. zoom属性缩放的中心坐标是元素的左上角，且不能修改。transform中的scale缩放默认的中心坐标是元素的中心点2. zoom属性缩放会改变元素占据的尺寸空间，transform中的scale缩放不会改变元素占据的尺寸3. zoom属性不会改变元素的层级，不会影响元素的fixed定位 backface-visiblility 元素背面是否可见 123backface-visiblility: visible 默认值 元素背面是可见的backface-visiblility: hidden 元素背面是不可见的常用于transform变换中，是否要隐藏元素的背面，使变换效果更好 justify-content: space-evenly 每个flex子项空白间距相等 1234ul&#123; display: flex; justify-content: space-evenly;&#125; prefers-color-scheme 用来检测当前网页是否处于深色(黑暗)模式的媒体属性 12345678910111213141516171819202122232425262728293031&lt;style&gt;/* 支持三个属性：dark 系统倾向于使用深色模式light 系统倾向于使用浅色模式no-perference 系统未告知用户使用的颜色方案 *//* 深色模式 */@media (prefers-color-scheme: light) &#123; body&#123; color:#333; background-color: #fff; &#125;&#125;/* 浅色模式 */@media (prefers-color-scheme: dark) &#123; body&#123; color:#fff; background-color: #000; &#125;&#125;/* 快速对现有网页进行深色模式改造的技巧 */body &#123; /* 使用filter:invert(1)滤镜对文字颜色和背景色等进行反相 */ filter: invert(1) hue-rotate(180deg); background-color: #000;&#125;/* 对图片进行再次反相将图片还原成真实颜色 避免应body反相后 图片颜色出现异常*/img&#123; filter: invert(1) hue-rotate(180deg); &#125;&lt;/style&gt;&lt;script&gt;// 判断当前手机浏览器是否支持深色或浅色模式// 是否支持 prefers-color-scheme 属性console.log(window.matchMedia('(prefers-color-scheme)').matches) // true// 是否是浅色模式 prefers-color-scheme: lightconsole.log(window.matchMedia('(prefers-color-scheme: light)').matches) // true// 是否是深色模式 prefers-color-scheme: darkconsole.log(window.matchMedia('(prefers-color-scheme: dark)').matches) // false&lt;/script&gt; touch-action: manipulation 取消移动端点击事件300ms延迟和双击行为 12/* touch-action: manipulation 只允许浏览器进行滚动和持续缩放操作 */html &#123; touch-action: manipulation; &#125; scroll-behavior: smooth 平滑滚动 safari不支持 1.box&#123; scroll-behavior: smooth; &#125; /* 平滑滚动 */ overscroll-behavior: contain 滚动嵌套时，终止外层滚动 safari不支持 12/* 局部滚动的滚动条滚动到底部边缘时，再继续滚动时，外部容器不会再跟滚动 */.box&#123; overscroll-behavior: contain;-ms-overscroll-behavior: contain; &#125; pointer-events: none 元素无法点击 caret-color: red 更改输入光标的颜色12/* 设置输入光标的颜色 也可以用于设置了 contenteditable的html标签 */input&#123; caret-color: red; &#125; 简单实用的css函数 calc()函数的使用 12345支持“+”、“-”、“*” 和 “/”四则运算；可以使用百分比、px、em、rem等单位，不能使用当前CSS属性不支持的单位，可以混合使用各种单位进行计算；表达式中有“+”和“-”时，其前后必须要有空格，如"widht: calc(12%+5em)"这种没有空格的写法是错误的；表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。.elm &#123; width: calc(100% - 20px + 5px*2)) &#125; min()函数的使用 1234min(expression [, expression]) 支持一个或多个表达式，使用逗号分隔，将最小表达式的值作为返回结果实现网页在大于等于1024px的PC浏览器显示宽度为1024px，在小于1024px时显示宽度为100%el &#123; width: 1024px; max-width:100% &#125; 使用min()函数 el &#123; min(1024px, 100%) &#125;min()用来限制最大值（即最大宽度值为1024px），IE和其他低版本浏览器不支持 max()函数的使用 1234max(expression [, expression]) 支持一个或多个表达式，使用逗号分隔，将最大表达式的值作为返回结果实现网页在小于等于1024px的PC浏览器显示宽度为1024px，在大于1024px时显示宽度为100%使用max()函数 el &#123; max(1024px, 100%) &#125;max()用来限制最小值（即最小宽度值为1024px），IE和其他低版本浏览器不支持 clamp()函数的使用 12345678910clamp()函数的作用是返回一个区间范围的值，语法：clamp(MIN, VAL, MAX),MIN表示最小值，MAX表示最大值，VAL表示首选值，如果VAL在MIN~MAX范围内，则将VAL作为返回值，如果VAL大于MAX则将MAX作为返回值，如果VAL小于MIN，则将MIN作为返回值。clamp(MIN, VAL, MAX)等同于max(MIN, min(VAL, MAX))IE和其他低版本浏览器不支持&lt;button&gt;宽度自适应变化&lt;/button&gt;button&#123; width: clamp(100px, 50%, 600px)&#125;不断改变浏览器视口的宽度，按钮宽度在100px~600px范围内变化，当屏幕宽度的一半大于600px时，宽度为600px当屏幕宽度的一半小于600px时，宽度在200px~600px之间，当屏幕宽度的一半小于200px时，宽度为200px。 env() 环境变量函数 1234567环境变量env()规范的制定是源于解决‘刘海屏’和‘底部触摸黑条’的移动设备的出现在使用safe-area-inset-*等env的属性时，一定要设置meta信息&lt;meta name="viewport" content="viewport-fit="cover""&gt;使用4个安全内边距值， 同时设置兜底尺寸，无法使用safe-area-inset-*时，会使用兜底的值env(safe-area-inset-top, 20px) 距离顶部 设置顶部刘海区域安全距离env(safe-area-inset-right, 1em) 距离右边env(safe-area-inset-bottom, 20px) 距离底部env(safe-area-inset-left, 20px) 距离左边 设置底部小黑条安全距离 Css变量和自定义属性 --变量名:值 声明css变量 属性：var(--变量名) 使用css变量12345678910111213&lt;div class="box"&gt;深浅色模式&lt;/div&gt;&lt;style&gt;:root&#123; --primary-color: pink; &#125; /* 声明css变量 */.box&#123; color: var(--primary-color)&#125; /* 使用css变量 */.box&#123; color: var(--primary-color, red)&#125; /* 使用 var(css变量, 备用值) 当css变量无效时 使用备用值 */&lt;/style&gt;&lt;script&gt;// 在js中设置和获取 css自定义属性// 只能借助 xx.style.setProperty 在js中设置 css变量document.documentElement.style.setProperty('--myColor', '#0000ff')// 使用 getComputedStyle(document.querySelector('.box')).getPropertyValue('--myColor') 获取css变量console.log(getComputedStyle(document.querySelector('.box')).getPropertyValue('--myColor')) // #0000ff&lt;/script&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue3配套的Vuex4与VueRouter4]]></title>
    <url>%2FVue3%E9%85%8D%E5%A5%97%E7%9A%84Vuex%E4%B8%8EVueRouter%2F</url>
    <content type="text"><![CDATA[Vuex是一个专为Vue.js应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。VueRouter是Vue.js的官方路由。它与Vue.js核心深度集成，让用Vue.js构建单页应用变得轻而易举。 Vuex4.x 安装 npm install vuex@next -S或yarn add vuex@next -S 几乎所有的Vuex4 API都与Vuex3保持不变 使用createStore函数来创建store实例,使用Vue实例.use(store)安装 createLogger函数从核心模块vuex中导出 在setup中用useStore组合式函数来使用store实例 支持TypeScript123456789101112131415161718192021222324252627282930313233// store/index.jsimport &#123; createStore, // 创建Vuex实例的方法 createLogger // vuex 日志插件&#125; from 'vuex'const env = process.env.NODE_ENVconst store = createStore(&#123; // 使用createStore创建store实例 state: &#123; x: 0, y: 10 &#125;, mutations: &#123; changeX (state, payload = 1) &#123; state.x += +payload &#125;, changeY (state, payload = 1) &#123; state.y += +payload &#125; &#125;, actions: &#123; changeYAsync (&#123; commit &#125;, payload) &#123; setTimeout(() =&gt; &#123; commit('changeY', payload) &#125;, 1000) &#125; &#125;, plugins: env === 'production' ? [] : [createLogger()]&#125;)export default store// main.jsimport &#123; createApp &#125; from 'vue'import App from './App.vue'import store from './store/index'const app = createApp(App)app.use(store) // 使用use安装store对象app.mount('#app') 12345678910111213141516171819202122232425262728293031&lt;!-- test.vue --&gt;&lt;template&gt; &lt;p&gt;测试Vuex&lt;/p&gt; &lt;p&gt;x: &#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;p&gt;y: &#123;&#123;y&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click="setX(5)"&gt;改变X&lt;/button&gt; &lt;button @click="setY(2)"&gt;改变Y&lt;/button&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed &#125; from 'vue'import &#123; useStore &#125; from 'vuex'export default &#123; name: 'test', setup () &#123; const store = useStore() // 使用store const x = computed(() =&gt; store.state.x) const y = computed(() =&gt; store.state.y) const setX = (val) =&gt; &#123; // 同步修改 store.commit('changeX', val) &#125; const setY = (val) =&gt; &#123; // 异步修改 store.dispatch('changeYAsync', val) &#125; return &#123; x, y, setX, setY &#125; &#125;&#125;&lt;/script&gt; VueRouter4.x 安装 npm install vue-router@4 -S 在VueRouter4的API与VueRouter3大部分的API都没有变化 使用createRouter函数来创建router实例,使用Vue实例.use(router)安装 mode配置被history取代 123"history": createWebHistory() # history模式"history": createWebHashHistory() # hash模式"history": createMemoryHistory() # 使用&#39;/:pathMatch(.*)*&#39;代替了 * 路由 1234567891011121314151617181920212223242526272829303132333435363738// router/index.jsimport &#123; createRouter, createWebHashHistory &#125; from 'vue-router'import Test from '../pages/Test.vue'import Vote from '../pages/Vote.vue'const router = createRouter(&#123; // 使用createRouter创建路由对象 // 指定路由使用模式 代替VueRouter3中的 mode history: createWebHashHistory(), // hash模式 routes: [ // 路由规则 映射关系 &#123; path: '/', component: Vote &#125;, &#123; path: '/test', component: Test &#125;, &#123; path: '/:pathMatch(.*)*', redirect: '/' &#125; ]&#125;)export default router// main.jsimport &#123; createApp &#125; from 'vue'import App from './App.vue'import router from './router/index'const app = createApp(App)app.use(router) // 安装路由对象app.mount('#app')// App.vue&lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;// Test.vueimport &#123; useRoute, useRouter &#125; from 'vue-router'export default &#123; name: 'test', setup () &#123; const route = useRoute() const router = useRouter() console.log(route) // 当前路由实例 // Proxy &#123;path: ComputedRefImpl, name: ComputedRefImpl, params: ComputedRefImpl, query: ComputedRefImpl, …&#125; console.log(router) // 全局路由实例 // &#123;currentRoute: RefImpl, push: ƒ, replace: ƒ, isReady: ƒ, getRoutes: ƒ, …&#125; &#125;&#125; 文章推荐: Vue-Router必知必会–万字肝文]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue3常用API学习]]></title>
    <url>%2Fvue3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[vue3使用TypeScript重写了代码,增加了Composition API基于函数的API,Vue3中使用Proxy重写了响应式原理.Vue3常用的API如:ref、toRef、toRefs、reactive、setup、watchEffect等，Vue3中某些API的变化如watch、computed、v-model等 setup入口12345678910111213141516171819202122232425&lt;!-- 父组件 --&gt;&lt;Vote title="Hello Vue3!"&gt;&lt;/Vote&gt;&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;span&gt;&#123;&#123; num &#125;&#125;人&lt;/span&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from 'vue'export default &#123; props: ['title'], // vue3中以setup开始 // + setup通过形参可以拿到props接收的值 // + setup发生在初始化props和beforeCreate之间，没有this无法拿到vue实例 // + 会将data/methods/computed/watch/filters等options API聚合在setup中 // + setup只在第一次加载执行一次，重新渲染不会再执行它[销毁后再加载属于第一次] // + setup中return返回的内容可以直接在视图中渲染 setup (props) &#123; console.log(props) // Proxy &#123;title: 'Hello Vue3!'&#125; console.log(this) // undefined return &#123; num: ref(10) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- 渲染后 &lt;h2&gt;Hello Vue3!&lt;/h2&gt;&lt;span&gt;10人&lt;/span&gt; --&gt; Vue3中的ref响应式APIref返回「RefTml」对象、在模板视图中自动渲染value值,在js中使用时需要使用value属性去获取和设置值、基于ES5「Object.defineProperty」的set/get实现数据劫持、通常只作用与单个基本类型值12345678910111213141516171819&lt;template&gt; &lt;p&gt;支持人数：&#123;&#123; supNum &#125;&#125;人&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from 'vue'export default &#123; // 基于 ref 响应式 API // + 返回 RefTml 对象 // + 在模板视图中自动渲染value值， 在js中使用时 需要使用value属性去获取和设置值 // + value属性是基于【Object.defineProperty】的set/get实现数据劫持 // + 通常只作用与单个基本类型值 setup () &#123; const supNum = ref(10) // 使用ref声明响应式单个数据 console.log(supNum) // RefImpl &#123;_shallow: false,...,value: 10&#125; console.log(supNum.value) // 10 return &#123; supNum &#125; &#125;&#125;&lt;/script&gt; Vue3中的reactive响应式APIreactive是基于ES6「Proxy」实现数据劫持、reactive返回「Proxy」对象、通常作用于对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;header class="vote-head"&gt; &lt;span&gt;&#123;&#123; state.oppNum + state.supNum &#125;&#125;人&lt;/span&gt; &lt;/header&gt; &lt;main class="vote-main"&gt; &lt;p&gt;支持人数：&#123;&#123; state.supNum &#125;&#125;人&lt;/p&gt; &lt;p&gt;反对人数：&#123;&#123; state.oppNum &#125;&#125;人&lt;/p&gt; &lt;p&gt;支持比率：&#123;&#123; ratio &#125;&#125;&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;button @click='change("sup")'&gt;支持&lt;/button&gt; &lt;button @click='change("opp")'&gt;反对&lt;/button&gt; &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, reactive &#125; from 'vue'export default &#123; setup () &#123; const state = reactive(&#123; // 使用reactive声明响应式对象 supNum: 10, oppNum: 5 &#125;) // 计算属性 const ratio = computed(() =&gt; &#123; const total = state.supNum + state.oppNum return total === 0 ? '--' : ((state.supNum / total) * 100).toFixed(2) + '%' &#125;) console.log(state) // Proxy &#123;supNum: 10, oppNum: 5&#125; // 普通方法 const change = (type) =&gt; &#123; type === 'sup' ? state.supNum++ : state.oppNum++ &#125; return &#123; state, ratio, change &#125; &#125;&#125;&lt;/script&gt;&lt;!-- 模板中如果要省略 state.xxx 直接使像 ref 声明数据时 直接使用 xxx需要使用 toRefs 将reactive声明对象的每一项都转换为单独的 RefImpl 对象--&gt;&lt;template&gt; &lt;main class="vote-main"&gt; &lt;p&gt;支持人数：&#123;&#123; supNum &#125;&#125;人&lt;/p&gt; &lt;p&gt;反对人数：&#123;&#123; oppNum &#125;&#125;人&lt;/p&gt; &lt;/main&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, reactive, toRefs, toRef &#125; from 'vue'export default &#123; name: 'Vote', props: ['title'], setup () &#123; const state = reactive(&#123; // 使用reactive声明响应式对象 supNum: 10, oppNum: 5 &#125;) // toRefs() 转换多个 toRef() 转化单个 console.log(toRef(state.supNum)) // RefImpl &#123;_shallow: false,..., value: 10&#125; console.log(toRefs(state)) // &#123;supNum: ObjectRefImpl, oppNum: ObjectRefImpl&#125; return &#123; ...toRefs(state) &#125; &#125;&#125;&lt;/script&gt; Vue3中的computed计算属性computed([getter函数])，返回ComputedRefImpl对象，获取的计算属性值是只读的，若修改会报警告：computed value is readonly123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;p&gt;支持比率：&#123;&#123; ratio &#125;&#125;&lt;/p&gt; &lt;footer&gt; &lt;button @click='change("sup")'&gt;支持&lt;/button&gt; &lt;button @click='change("opp")'&gt;反对&lt;/button&gt; &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed &#125; from 'vue'export default &#123; setup (props) &#123; const supNum = ref(10) const oppNum = ref(5) // 计算属性 const ratio = computed(() =&gt; &#123; const total = supNum.value + oppNum.value return total === 0 ? '--' : ((supNum.value / total) * 100).toFixed(2) + '%' &#125;) console.log(ratio) // ComputedRefImpl &#123;dep: undefined, _dirty: true, …&#125; // ratio.value = '100%' // 无法修改 并警告 Write operation failed: computed value is readonly // 普通方法 const change = (type) =&gt; &#123; type === 'sup' ? supNum.value++ : oppNum.value++ &#125; return &#123; ratio, change &#125; &#125;&#125;&lt;/script&gt; Vue3中的 watch 监听器 和 watchEffect watch 监听器 默认第一次加载组件不执行 当监听的数据改变时会触发执行 watchEffect(callback) 第一次加载组件和函数中所依赖数据发生改变时都会触发callback1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;p&gt;支持人数：&#123;&#123; supNum &#125;&#125;人&lt;/p&gt; &lt;footer&gt; &lt;button @click='change("sup")'&gt;支持&lt;/button&gt; &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, reactive, toRefs, watch, watchEffect &#125; from 'vue'export default &#123; props: ['title'], setup () &#123; const state = reactive(&#123; // 使用reactive声明响应式对象 supNum: 10 &#125;) const num = ref(0) // 普通方法 const change = (type) =&gt; &#123; type === 'sup' ? state.supNum++ : state.oppNum++ num.value++ &#125; // watchEffect(callback) 第一次加载组件和函数中所依赖数据发生改变时都会触发callback watchEffect(() =&gt; &#123; console.log('watchEffect: ', state.supNum) &#125;) // 监听对象 watch(state, () =&gt; &#123; console.log('watch: ') &#125;) // 1. 监听reactive创建的单个值,第一个参数必须使用函数 watch(()=&gt;state.supNum,()=&gt;&#123;&#125;) watch( () =&gt; state.supNum, (next, prev) =&gt; &#123; // next:新值 prev:旧值 console.log('watch: ', next, prev) &#125; ) // 2. 监听 ref 创建的数据 watch(num, (next, prev) =&gt; &#123; // next:新值 prev:旧值 console.log('watch: ', next, prev) &#125;) // watch 深度监听 或 第一次也执行 第三个参数:对象 watch( num, (next, prev) =&gt; &#123; // next:新值 prev:旧值 console.log('watch: ', next, prev) &#125;, &#123; deep: true, immediate: true &#125; ) return &#123; ...toRefs(state), change, num &#125; &#125;&#125;&lt;/script&gt; vue3中的v-model用法更改 替换 v-bind.sync&lt;Switch :value=&quot;bool&quot; @update:value=&quot;bool = $event&quot; /&gt;简写为&lt;Switch v-model:value=&quot;bool&quot; /&gt;123456789101112131415&lt;template&gt; &lt;button :class="&#123;'checked':value&#125;" @click="toggle"&gt;&lt;span&gt;&lt;/span&gt;&lt;/button&gt;&lt;/template&gt;&lt;script lang="ts"&gt;export default &#123; props: &#123; value: Boolean &#125;, setup(props, context)&#123; const toggle = () =&gt; &#123; context.emit('update:value', !props.value) &#125; return &#123;toggle&#125; &#125;&#125; Vue3属性绑定 默认所有属性都绑定到根元素 使用inheritAttrs: false 可以取消默认绑定 使用 $attrs 或 context.attrs 获取所有属性 使用 v-bind=”$attrs” 批量绑定属性 123456789101112131415&lt;!-- 父组件 --&gt;&lt;Button @click="test" @focus="test" @mouseover="test"&gt;&lt;!-- 子组件 --&gt;&lt;div :size="size"&gt; &lt;button v-bind="rest"&gt;&lt;/button&gt;&lt;/div&gt;&lt;script lang="ts"&gt;export default &#123; inheritAttrs: false, setup(props, context)&#123; const &#123;size, ...rest&#125; = context.attrs return &#123;size, rest&#125; &#125;&#125;&lt;/script&gt; props和attrs区别 props要先声明才能取值, attrs不用先声明 props不包含事件, attrs包含 props 没有声明的属性 会在attrs里 props支持string以外的类型 attrs只有string类型 Vue3其他变更 v-if优先级高于v-for .native事件修饰符废除]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学vue3]]></title>
    <url>%2F%E5%88%9D%E5%AD%A6vue3%2F</url>
    <content type="text"><![CDATA[vue3抛弃了Flow类型注释,使用TypeScript重写了代码,增加了Composition API基于函数的API,解决了Vue2中Options API不好拆分和重用的的问题.Vue3中使用Proxy重写了响应式原理，并且对编译器做了优化,重写了虚拟DOM,从而让渲染和update的性能都有了大幅度的提升.Vue3中移除了一些不常用的API,如filter.对Tree-shaking的支持更好,过滤掉未使用的模块使打包的体积更小. 官方文档 Vue3.x文档地址 Vue3.x更新内容 用于Vue2项目迁移Vue3的构建版本 创建项目 通过CDN &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; 通过Vue-cli脚手架创建项目 注：需要将@vue/cli更新至4.5.0及以上 npm update -g @vue/clivue create &lt;project-name&gt; 选择 vue3 的模板进行创建` 12345/*1. vue create &lt;project-name&gt; 选择vue3的模板进行创建2. cd &lt;project-name&gt;3. npm run serve*/ 通过vite脚手架创建项目 注：Vite需要Node.js版本&gt;=12.0.0npm init vite-app &lt;project-name&gt; 或 yarn create vite-app &lt;project-name&gt; 123456/*1. npm init vite-app &lt;project-name&gt; 或 yarn create vite-app &lt;project-name&gt;2. cd helloVite3. npm install4. npm run dev*/ 全局API-createApp123456// 入口文件 main.js// vue3提供大量函数式API,推崇的是函数式编程import &#123; createApp &#125; from "vue";import App from "./App.vue";const app = createApp(App); // 使用createApp函数创建vue应用实例app.mount("#app"); // 将组件App挂载到id为app的节点上 Vue3 主要更新 Performance 重写了虚拟 DOM 的实现(跳过静态节点,只处理动态节点),update 性能提供,SSR 速度提高 Tree shaking 全局和内部 API 已经被重构为支持 tree-shake,可以将无用模块过滤,仅打包需要和用到的部分 Fragment (空文档标签)不再限于模板中的单个根节点,Vue3 的 template 支持多个根标签,Vue2 只能由一个根标签 TypeScript 更好的 TypeScript 支持 Custom Renderer API 自定义渲染器 将某些部分以 canvas 画布形式展示出来而不是 Dom 方式 Composition API 组合式 API 组合式API,替换原有的Options API,将逻辑相关的代码组织在一起,提高可读性和可维护性,更好的重用逻辑代码(避免mixins混入时命名冲突的问题),但是依然可以使用Options API 123456789101112131415161718192021// Options APIexport default &#123; data () &#123; return &#123;&#125; &#125;, methods: &#123;&#125;, cooputed () &#123;&#125;, watch: &#123;&#125;, filters: &#123;&#125;&#125;// Composition API 所有操作聚合在 setUp 中export default &#123; name: "AsyncTest", async setup() &#123; let &#123; id, name &#125; = &#123;id: 1, name: 'tew'&#125;; return &#123; id, name, &#125;; &#125;,&#125;; Proxy 数据劫持,Vue3 中的响应式原理是基于 ES6 的 Proxy 实现的 1234567891011121314151617181920212223242526272829303132/*Vue2是基于0bject.defineProperty实现数据劫持的(get/set) + 需要给对象中的每一个属性分别遍历做劫持「对于后期新增的属性是没有做劫持的,vue2中可以基于$set实现新增属性的劫持」 + 对于数组中的每一项没有做劫持「vue2中重写了数组7个方法，后期通过这7个方法修改数组中的某一项，才会让视图重新渲染」 + 默认劫持是"浅”的,vue2自动基于递归的方式实现了深度劫持 + ES5的API，兼容IE9及以上Vue3中的响应式数据，是基于ES6中的Proxy实现的 + ES6的API，不兼容IE + Proxy除了提供get/set监听之外，还提供了其他大量的监听函数 + Proxy无需自己依次遍历对象的每个属性，只需要代理整个对象，则所有属性都被劫持，新增属性也会被劫持 + Proxy直接对数组每一项做代理操作数组的某一项都会触发试图更新，无需重写数组的方法 + Proxy默认也是只对对象的第一层做代理，也需要递归遍历实现深层次代理*/// proxy 基本使用// const data = &#123;// name: 'zhangsan',// age: 20,// &#125;const data = ['a', 'b', 'c']const proxyData = new Proxy(data, &#123; get(target, key) &#123; return Reflect.get(target, key) &#125;, set(target, key, val) &#123; // 重复的数据，不处理 if (val === target[key]) return true Reflect.set(target, key, val) &#125;, deleteProperty(target, key) &#123; Reflect.deleteProperty(target, key) &#125;&#125;) Teleport 传送门 12345678910111213141516171819202122232425262728// index.html&lt;body&gt; &lt;div id="#app"&gt;&lt;/div&gt; &lt;div id="#other"&gt;&lt;/div&gt;&lt;/body&gt;// demo.vue/*Teleport 把当前组件的部分内容抽离出来放到页面中 非#app的容器中 基于to指定放在那个容器下*/&lt;template&gt; &lt;h2&gt;Hello Vue3!&lt;/h2&gt; &lt;Teleport to="#other"&gt; &lt;span&gt;hello world!&lt;/span&gt; &lt;/Teleport&gt;&lt;/template&gt;// 渲染结果/*&lt;body&gt; &lt;div id="app" data-v-app=""&gt; &lt;h2&gt;Hello Vue3!&lt;/h2&gt; &lt;!--teleport start--&gt; &lt;!--teleport end--&gt; &lt;/div&gt; &lt;div id="other"&gt; &lt;span&gt;hello world!&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;*/ Suspense 可在嵌套层级中等待嵌套的异步依赖项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- AsyncTest.vue --&gt;&lt;template&gt; 获取的用户信息是&lt;br /&gt; 用户编号: &#123;&#123; id &#125;&#125;&lt;br /&gt; 用户姓名: &#123;&#123; name &#125;&#125;&lt;br /&gt;&lt;/template&gt;&lt;script&gt; const query = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; id: 1, name: "tew" &#125;); &#125;, 2000); &#125;); &#125;; export default &#123; name: "AsyncTest", async setup() &#123; let &#123; id, name &#125; = await query(); return &#123; id, name, &#125;; &#125;, &#125;;&lt;/script&gt;&lt;!-- App.vue --&gt;&lt;!--&lt;template&gt; &lt;h2&gt;Hello Vue3!&lt;/h2&gt; &lt;AsyncTest /&gt; 直接使用异步组件无法使用 需要使用 Suspense&lt;/template&gt;--&gt;&lt;template&gt; &lt;h2&gt;Hello Vue3!&lt;/h2&gt; &lt;Suspense&gt; &lt;!-- 异步组件加载成功之后显示的内容 --&gt; &lt;template #default&gt; &lt;AsyncTest /&gt; &lt;/template&gt; &lt;!-- 异步组件加载成功之前显示的内容 --&gt; &lt;template #fallback&gt;loading... &lt;/template&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt; import AsyncTest from "./AsyncTest.vue"; export default &#123; name: "App", components: &#123; AsyncTest, &#125;, &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 7.0 +]]></title>
    <url>%2Fes7%2B%2F</url>
    <content type="text"><![CDATA[ES6全称ECMAScript 6.0,部分浏览器不支持ES6，在应用程序的构建过程中需要使用babel将ES6转换为ES5. es6新特性：默认参数、箭头函数、模块化、Proxy、Generator构造器函数、Promise等 async/await 异步编程终级解决方案 async函数的会返回一个promise对象，并且把内部的值进行promise的封装. async函数就是将Generator函数的星号（*）替换成 async，将 yield替换成 await。 如果函数中return一个直接量,async会把这个直接量通过Promise.resolve()封装成Promise对象，在没有await的情况下执行async函数，它会立即执行， 返回一个promise对象， 不会阻塞后面的语句。async 函数就是 Generator 函数的语法糖。 await关键字只能放到async 函数里面，不可以脱离async单独使用，等待后面的promise对象执行完毕，然后拿到promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行 await后面一定是Promise对象，如果不是会自动包装成Promise对象 await如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西。 await如果它等到的是一个Promise对象，await会阻塞后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// async 返回 promise 对象async function test()&#123; return 4&#125;console.log(test()) // Promise &#123;&lt;resolved&gt;: 4&#125;test().then(res =&gt; &#123;console.log(res)&#125;) // 4async function test1()&#123; return new Promise((resolve, reject) =&gt;&#123; resolve(4) &#125;)&#125;console.log(test1()) // Promise &#123;&lt;pending&gt;&#125;test1().then(res =&gt; &#123;console.log(res)&#125;) // 4// async 与 await 的使用function getGoodsId() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve("商品id"), 1000) &#125;)&#125;async function test() &#123; console.log(await getGoodsId())&#125;test() // 商品idvar fs = require('fs');// Generator 函数// 返回promise的对象var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125;// Generator * yield 解决异步var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab') var f2 = yield readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125;// async await 解决异步var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab') var f2 = await readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125; await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。 12345678910111213async function fun() &#123; try &#123; await asyncFun() &#125; catch (err) &#123; console.log(err) &#125;&#125;// 另一种写法async function myFunction() &#123; await asyncFun().catch(function (err)&#123; console.log(err) &#125;)&#125; async/await遇上map的遍历操作时，当async函数被执行时，将立即返回pending状态的Promise，因此，在map循环时，不会等待 await操作完成，而是直接进入下一次循环。 123456789101112131415161718let arr = [1, 2, 3]let res = arr.map(value =&gt; &#123; return value * 2&#125;)console.log(res) // [2, 4, 6]let arr1 = [1, 2, 3]let res1 = arr1.map(async value =&gt; &#123; return value * 2&#125;)console.log(res1) // [Promise, Promise, Promise]// 使用 Promise.all() 将async返回的promise对象数组依次执行let arr1 = [1, 2, 3]let res1 = await Promise.all(arr1.map(async value =&gt; &#123; return value * 2&#125;))console.log(res1) // [2, 4, 6] 幂运算 **12345// n**m 等同于 Math.pow(n, m) n的m次方console.log(2**5) // 32console.log(Math.pow(2, 5)) // 32// **运算是右结合的 4**3**2 ===&gt; 4**(3**2) ===&gt; 4**9console.log(4**3**2) // 262144 不是(4**3)**2 4096 ## 先行断言 匹配到hello时 紧接着去匹配hello后面的字符 装饰器装饰器可以修饰类 类的属性 类的原型上的方法 修饰的时候就是把这个类的属性传递给修饰的函数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些面试题(3)]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98(3)%2F</url>
    <content type="text"><![CDATA[1. 去掉数组中非数字字符， 并给每个数字+11234567891011// 删除数组从后往前删 避免数组塌陷var arr = [1, 2, 3, 'a', 4, 'b']for(var i = arr.length - 1; i &gt;= 0; i--)&#123; console.log(typeof arr[i]) if(typeof arr[i] === 'number')&#123; arr[i]++ &#125; else&#123; arr.splice(i, 1) &#125;&#125;console.log(arr) 2. 再两个排好序的数组中， 高效率找出相同的元素放入新数组12345678910111213141516// 两个变量 谁小谁往后移动 未排序先用 arr.sort排序后再查找var arr1 = [1, 3, 7, 9, 12, 37, 45]var arr2 = [2, 4, 9, 13, 45, 88, 92]var result = []for(var i = 0, j = 0;i&lt;arr1.length &amp;&amp; j&lt;arr2.length;)&#123; if(arr1[i] === arr2[j])&#123; result.push(arr1[[i]]) i++ j++ &#125; else if(arr1[i]&lt;arr2[j])&#123; i++ &#125; else &#123; j++ &#125;&#125;console.log(result) // [2, 3, 4, 5] 3. 找出一个排好序的数组中， 两个元素相加和为19的元素组合1234567891011121314var arr4 = [1, 2, 4, 6, 7, 11, 12, 15, 17, 20]var res = []for (var i = 0, j = arr4.length - 1; i &lt; j;) &#123; if (arr4[i] + arr4[j] &gt; 19) &#123; j-- // 让大的往前移 &#125; else if(arr4[i] + arr4[j] &lt; 19)&#123; i++ &#125; else &#123; // arr4[i]+arr4[j] === 19 res.push([arr4[i], arr4[j]]) i++ j-- &#125;&#125;console.log(res) // [9, 45] 4. hash 数组去重 会改变数据类型123456789var arr5 = [1, 2, 3, 4, '2', 1]var hash = &#123;&#125;for(var i=0;i&lt;arr5.length;i++)&#123; hash[arr5[i]] = 1&#125;var res5 = []var i = 0;for(res5[i++] in hash)&#123;&#125; // 利用对象遍历将key分别添加进数组res5中console.log(res5) // ["1", "2", "3", "4"] 5. x in window1234567891011// var y var x---&gt; window.x window.y// y = 10 -&gt; ++y// if()&#123;&#125; 不是作用域 拦不住内部的var变量被声明提前var y = 10if(!(x in window))&#123; var x = 10&#125; else &#123; ++y&#125;console.log(x) // undefinedconsole.log(y) // 11 6. 闭包 作用域链12345678910111213141516171819function fun(n, o)&#123; // fun 全局函数 随处可用 console.log(o) // 输出第二个参数 return &#123; fun: function(m)&#123; return fun(m, n) // 只把第一个参数给孩子 &#125; &#125;&#125;var a = fun(0) // undefiend a.fun(1); // 0 a.fun(2); // 0 a.fun(3); // 0var b = fun(0) // undefiend .fun(1) // 0 .fun(2) // 1 .fun(3) // 2var c = fun(0).fun(1); // undefiend 0 c.fun(2); // 1 c.fun(3); // 1 7. 默认参数123456789101112131415161718192021// es6 如果函数的形参定义默认值 则函数体会包裹在一个匿名函数自调中运行/*function foo(x, y = function()&#123;x=2&#125;)&#123; if(y===undefined)&#123; y = function()&#123;x=2&#125; &#125; (() =&gt; &#123; var x = 3 y() console.log(x) // 3 &#125;)()&#125;*/var x = 1;function foo(x, y = function()&#123;x=2&#125;)&#123; var x = 3 y() // 修改的是形参形成的临时作用域 将x=undefiend 修改为x=2 console.log(x) // 3 自己的作用域x依旧为3&#125;// foo() 调用创建 临时函数作用域 x=undefiend y= function()&#123;x=2&#125;foo()console.log(x) // 1 8. FOO.a123456789101112131415161718192021function Foo()&#123; // 第一步 创建地址Foo存储对象 Foo.a = function ()&#123; console.log(1) &#125; this.a = function ()&#123; console.log(2) &#125;&#125;Foo.prototype.a = function()&#123; // 构造函数原型上定义a方法 console.log(3)&#125;Foo.a = function()&#123; // 构造函数静态方法 console.log(4)&#125;Foo.a() // 4 执行Foo的静态方法 Foo.a = function()&#123; console.log(4) &#125;let obj = new Foo() // obj.__proto__ = Foo.prototype// 执行Foo中的内容 Foo.a = function()&#123; console.log(1) &#125; 将构造函数静态方法a// 修改为 Foo.a = function()&#123; console.log(1) &#125;// this.a = obj.a = function ()&#123; console.log(2) &#125;obj.a() // 2 obj.a = function ()&#123; console.log(2) &#125; 自身有a方法 否则会找 Foo.prototype.aFoo.a() // 1 执行Foo的静态方法 Foo.a = function()&#123; console.log(1) &#125; 9. foo.x 闭包123456789101112131415161718var x = 0;var foo = &#123; x: 1, bar: function()&#123; console.log(this.x) var that = this return function()&#123; console.log(this.x) console.log(that.x) &#125; &#125;&#125;foo.bar() // 1 this.x == foo.xfoo.bar()() // 1 0 1//1. 先执行 foo.bar() 打印 1 that = this = foo//2. 返回 function()&#123; console.log(this.x) console.log(that.x) &#125;//3. 匿名函数自调 function()&#123; console.log(this.x) console.log(that.x) &#125;()// this--&gt; window this.x = window.x 打印 0 that---&gt;foo that.x==foo.x 打印 1 10. obj.fn11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var a = 2var obj = &#123; a: 4, fn1:(function()&#123; this.a *= 2 var a = 3 return function()&#123; this.a *= 2 a *= 3 console.log(a) &#125; &#125;)()&#125;// 1. 匿名函数自调 this--&gt; window/*fn1: (function()&#123; this.a *= 2 // window.a = a*2 = 4 var a = 3 return function()&#123; // a = 3 闭包中 this.a *= 2 a *= 3 console.log(a) &#125; &#125;)() 执行后 a = 4 var obj = &#123; a: 4, fn1: function()&#123; // a = 3 this.a *= 2 a *= 3 console.log(a) &#125; &#125;*/var fn1 = obj.fn1 // 9 fn1 = function()&#123; this.a *= 2; a *= 3; console.log(a) &#125;console.log(a) // 4 全局 window.a = 4fn1() // 9/*function()&#123; // a = 3 局部 this.a *= 2 // window.a = a*2 = 8 a *= 3 // a = a*3 = 9 console.log(a) // 9&#125;()*/obj.fn1() // 27/*function()&#123; // a = 9 局部 this.a *= 2 // obj.a = 4*2 = 8 a *= 3 // a = a*3 = 27 console.log(a) // 27&#125;*/console.log(a) // 8 window.aconsole.log(obj.a) // 8 11. 引用类型12345678910function setObj(p)&#123; // 形参函数局部作用域 // 形参 var p 然后赋值 p为0x1234 p.name='小红' // 将地址0x1234 name 修改为 小红 p = &#123;&#125; // 局部变量 p 指向新地址 0x5555 p.name="西西" // 将地址0x5555 name 修改为 xixi&#125;var p = &#123;name: '小明'&#125; // 地址为0x1234setObj(p)console.log(p) // &#123;name: "小红"&#125; 局部变量 p 0x5555被系统回收 12. 判断一个属性是否在对象内1234567891011// 属性名 in obj ---&gt;是不仅判断一个属性是否在对象内部， 还判断是否在当前对象的原型链上// obj.hasOwnProperty('属性名') ---&gt; 仅判断是否在对象内部， 不检查原型链上function People(firstname)&#123; this.firstname = firstname&#125;People.prototype.lastname = 'tew'var bob = new People('tom')bob.hasOwnProperty('firstname') // truebob.hasOwnProperty('lastname') // false'firstname' in bob // true'lastname' in bob // true 其他1234567891011121314151617181920212223242526// getElements vs querySelectorAll// getElements 返回的是动态集合，不存储实际数据，每次访问集合，都重新扫描DOM树// querySelectorAll 返回的是非动态集合 存储实际数据， 每次访问集合，// 都不重新查找DOM树，即使DOM树发生变化也不重新查找/** 定时器* 周期性定时器setInterval， 不会自动停止， 只能通过外部的变量timer来控制停止： clearInterval(timer)* timer在clear之后，不会自动变为null，而是依然保存着已经关闭的定时器序号，需要手动设为null*/// let 和 setTimeout 一起使用时 块级作用域 相当于包裹了一个自执行函数 形成闭包for(let i=0;i&lt;3;i++)&#123; setTimeout(()=&gt;&#123; conolse.log(i) &#125;, 0)&#125;// 0 1 2/* 转换为es5之后for (var i = 0; i &lt; 3; i++) &#123; (function(i) &#123; setTimeout(function () &#123; conolse.log(i); &#125;, 0); &#125;)(i);&#125; */ 继承12345678910111213141516171819202122232425262728293031// 定义一个新的People类继承 Animal中所有的属性和方法function Animal(name, age)&#123; this.name = name this.age = age&#125;Animal.prototype.intr = function()&#123; console.log(`I'm $&#123;this.name&#125;, I'm $&#123;this.age&#125;`)&#125;/*1. 让 person可以调用 Animal 原型上的方法 intr, 需要让 People.prototype继承Animal.prototype Object.setPrototypeOf(People.prototype, Animal.prototype) 或者 People.prototype = new Animal() 或者 People.prototype = Animal.prototype2. 使用 Animal.call(this, name, age) 方法继承父类的属性*/function People(name, age, className)&#123; Animal.call(this, name, age) this.className = className&#125;// People.prototype = new Animal()// People.prototype = Animal.prototypeObject.setPrototypeOf(People.prototype, Animal.prototype)People.prototype.run = function()&#123; console.log(`我是$&#123;this.className&#125;的$&#123;this.name&#125;, 我正在跑步`)&#125;var person = new People('Tom', 20, '高一(2)班')person.run()person.intr() promise 多个resolve123456789101112131415161718192021222324252627// 1. first()-&gt; new Promise 立即执行 输出 3 再立即执行new promise 输出 7// 2. 将setTimeout放在异步队列// 3. resolve(1)--&gt; p.then(arg =&gt; &#123; console.log(arg)&#125;) 输出 1// 4. resolve(2)--&gt; first().then(arg =&gt; &#123; console.log(arg) &#125;) 输出 2// 5. 执行 setTimeout 函数体 输出5// 6. Promise中，只要遇到resolve，就会将resolve状态凝固，后边再出现其他的resolve，不会覆盖之前的resolve。// 所有 resolve(6) 不会覆盖之前的resolve 也不执行 resolve(6)const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123; console.log(3) let p = new Promise((resolve, reject)=&gt;&#123; console.log(7) setTimeout(() =&gt; &#123; console.log(5) resolve(6) &#125;, 0) resolve(1) &#125;) resolve(2) p.then(arg =&gt; &#123; console.log(arg) &#125;)&#125;))first().then(arg =&gt; &#123; console.log(arg)&#125;)console.log(4)// 3 7 4 1 2 5 promise 多个then12345678910111213141516171819202122232425262728293031323334353637// 1. 将 setTimeout 放入宏任务队列// 2. 立即执行 p1 = new Promise 输出 2 将p1.then(第一个then) 放入微任务队列// 3. 立即执行 p2 = new Promise 输出 8 将p2.then(第一个then) 放入微任务队列// 4. 执行 p1.then(第一个then) 输出 3 立即执行 p3 = new Promise 输出 4 将p3.then(第一个then) 放入微任务队列// 5. 执行 p2.then(第一个then) 输出 9// 6. 执行 p3.then(第一个then) 输出 5 返回一个promise 并将p3 的第二个then 放入微任务队列// 7. 执行 p3.then(第二个then) 输出 6 此时 p1的第一个then执行完毕 返回一个promise 并将p1 的第二个then 放入微任务队列// 8. 并将p1.then(第二个then) 输出 7 此时 微任务队列执行完毕// 9. 执行宏任务 setTimeout 输出 1setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)let p1 = new Promise((resolve, reject) =&gt; &#123; console.log(2) resolve()&#125;).then(() =&gt; &#123; console.log(3) let p3 = new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;).then(() =&gt; &#123; console.log(6) &#125;)&#125;).then(() =&gt; &#123; console.log(7)&#125;)let p2 = new Promise((resolve, reject)=&gt;&#123; console.log(8) resolve()&#125;).then(() =&gt; &#123; console.log(9)&#125;)// 2 8 3 4 9 5 7 6 1]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue高级特性及部分原理]]></title>
    <url>%2Fvue%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%8F%8A%E9%83%A8%E5%88%86%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[vue常用高级特性、自定义v-model、slot插槽、mixin抽离公共代码、keep-alive缓存组件、$nextTick、动态组件、异步组件、vuex、vue-router等。vue中的响应式原理、组件渲染过程、模板渲染、虚拟DOMvdom、diff算法等。 Vue 高级特性 自定义v-model :value与@input 结合实现 1234567&lt;!-- input-price --&gt;&lt;input type="text" :value="price" @input="price=$event.target.value"&gt;&lt;!-- app.vue --&gt;&lt;div id="app"&gt; &lt;input-price v-model="price"&gt;&lt;/input-price&gt;&lt;/div&gt; slot 插槽 作用域插槽 具名插槽 mixin 抽离多个组件中相同的逻辑mixin存在问题:1. 变量来源不明确，不利于阅读多 2. mixin可能造成命名冲突 3. mixin组件可能出现多对多关系，复杂度较高. vue3 composition API 解决这些问题 1234567891011121314151617181920212223242526272829303132333435&lt;!-- mixin.js --&gt;export default &#123; data() &#123; return &#123; city: '北京' &#125; &#125;, methods: &#123; showName() &#123; console.log(this.name) &#125; &#125;, mounted() &#123; console.log('mixin mounted', this.name) &#125;&#125;&lt;!-- mixin demo --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;name&#125;&#125; &#123;&#123;major&#125;&#125; &#123;&#123;city&#125;&#125;&lt;/p&gt; &lt;button @click="showName"&gt;显示姓名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myMixin from './mixin'export default &#123; mixins: [myMixin], // 可以添加多个，会自动合并起来 data() &#123; return &#123; name: 'tew', major: 'web 前端' &#125; &#125;, methods: &#123;&#125;, mounted() &#123; console.log('component mounted', this.name) &#125;&#125;&lt;/script&gt; keep-alive 缓存 频繁切换不需要重复渲染组件 12345&lt;keep-alive&gt; &lt;!-- tab 切换 --&gt; &lt;KeepAliveStageA v-if="state === 'A'"/&gt; &lt;!-- v-show --&gt; &lt;KeepAliveStageB v-if="state === 'B'"/&gt; &lt;KeepAliveStageC v-if="state === 'C'"/&gt;&lt;/keep-alive&gt; $nextTick与异步更新 由于异步渲染 会在DOM渲染完之后被触发，以获取最新DOM节点 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 refs 元素设置 ref=&quot;ul&quot; 属性 获取DOM元素 this.$refs.ul 1234567891011121314151617/* &lt;ul ref="ul"&gt; &lt;li v-for="(item, index) in list" :key="index"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;button @click="addItem"&gt;添加一项&lt;/button&gt; */addItem() &#123; this.list.push(`$&#123;Date.now()&#125;`) this.list.push(`$&#123;Date.now()&#125;`) // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调 // 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次 this.$nextTick(() =&gt; &#123; // 获取 DOM 元素 const ulElem = this.$refs.ul console.log( ulElem.childNodes.length ) &#125;)&#125; 动态组件 &lt;component :is=&quot;componentname&quot; /&gt; 异步组件 按需加载 components: { DescPopup: () =&gt; import(&#39;../components/descPopup&#39;)} vue 生命周期 vuexstate mutation getters actiondispatch commit mapState mapMutations mapGetters mapActions vue-router 路由模式（hash（默认） H5 history(需要server端支持)） 路由配置（动态路由(动态参数) 懒加载） 路由守卫 event事件是 原生的event事件 事件被挂载到当前元素 Vue原理Vue原理主要三部分: 组件化、响应式、vdom和diff 组件化和MVVM 数据驱动视图 M model V view VM 模型(指令 事件等将view和model链接起来) 响应式原理 核心API Object.defineProperty 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Object.defineProperty的缺点// 1. 复杂对象需要深度监听 需要递归调用， 一次性计算量大// 2. 无法监听新增属性/删除属性(Vue.set/Vue.delete)// 3. 无法监听原生数组 需要特殊处理 重写了数组的7个方法// 重新定义数组原型const oldArrayProperty = Array.prototype// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型const arrProto = Object.create(oldArrayProperty);['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName =&gt; &#123; arrProto[methodName] = function () &#123; updateView() // 触发视图更新 oldArrayProperty[methodName].call(this, ...arguments) // Array.prototype.push.call(this, ...arguments) &#125;&#125;)// 重新定义属性，监听起来function defineReactive(target, key, value) &#123; observer(value) // 深度监听 Object.defineProperty(target, key, &#123; // 核心 API get() &#123; return value &#125;, set(newValue) &#123; if (newValue !== value) &#123; observer(newValue) // 深度监听 // 设置新值 // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值 value = newValue &#125; &#125; &#125;)&#125;// 监听对象属性function observer(target) &#123; if (typeof target !== 'object' || target === null) &#123; return target // 不是对象或数组 &#125; // 污染全局的 Array 原型 // Array.prototype.push = function () &#123; // updateView() // ... // &#125; if (Array.isArray(target)) &#123; target.__proto__ = arrProto &#125; // 重新定义各个属性（for in 也可以遍历数组） for (let key in target) &#123; defineReactive(target, key, target[key]) &#125;&#125; vdom(Virtual DOM)是实现vue和react的重要基石 snabbdom vdom库 1234567891011121314151617181920212223242526// vdom 数据驱动视图 控制DOM操作// vdom 用JS模拟DOM结构 计算出最小变更， 操作DOM/* 真实DOM&lt;div id="div1" class="wrap"&gt; &lt;p&gt;vdom&lt;/p&gt; &lt;ul style="font-size: 20px"&gt; &lt;li&gt;a&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;*//* JS 模拟DOM&#123; tag: 'div', props:&#123; className: 'wrap', id: 'div1' &#125;, children: [ &#123; tag: 'p', children: 'vdom' &#125;, &#123; tag: 'ul', props: &#123; style:'font-size: 20px'&#125;, children: [ &#123; tag: 'li', children: 'a' &#125; ] &#125; ]&#125;*/ diff算法是vdom中最核心、最关键的部分 vdom树的diff对比 1234// 只比较同一层级 不跨级比较// tag不相同 则直接删除重建，不再深度比较// tag和key 两者都相同 则认为是相同节点，不再深度比较// vdom核心概念: h, vnode, ptach, diff, key等 模板编译 with语法 12345678const obj = &#123; a: 100, b: 200 &#125;// with 能改变 &#123;&#125; 内自由变量的查找方式 将 &#123;&#125; 内自由变量当做 obj 的属性来查找with(obj)&#123; console.log(a) // 100 console.log(b) // 200 console.log(c) // 报错&#125;// with 慎用 他打破了作用域规则 易读性变差 vue-template-complier将模板编译为render函数 1234// 模板编译是将模板转化为某种JS代码// 模板编译为render函数 执行render函数返回vnode// 基于vnode在执行patch和diff// webpack vue-loader 会在开发环境编译模板 执行render函数生成vnode render函数代替template 12345678Vue.component('title', &#123; // template: '&lt;div class="test"&gt;&lt;a href="xxx"&gt;this is a tag&lt;/a&gt;&lt;/div&gt;' render: function(createElement)&#123; return createElement('div',&#123; className: 'test'&#125; , [ createElement(a, &#123; attrs: &#123; href: 'xxx' &#125;&#125;, 'this is a atg') ]) &#125;&#125;) 组件渲染/更新过程初次渲染 解析模板为render函数 触发响应式, 监听data属性getter setter 执行render函数(会触发getter), 生成vnode, patch(elem, vnode)更新过程 修改data, 触发setter 重新执行render函数, 生成newVnode patch(vnode, newVnode) 前段路由 hashhash变化不会刷新页面, 会触发网页跳转,即浏览器的前进、后退 1234567891011121314151617181920212223&lt;body&gt; &lt;p&gt;hash test&lt;/p&gt; &lt;button id="btn1"&gt;修改 hash&lt;/button&gt; &lt;script&gt; // hash 变化，包括： // a. JS 修改 url // b. 手动修改 url 的 hash // c. 浏览器前进、后退 window.onhashchange = (event) =&gt; &#123; console.log('old url', event.oldURL) console.log('new url', event.newURL) console.log('hash:', location.hash) &#125; // 页面初次加载，获取 hash document.addEventListener('DOMContentLoaded', () =&gt; &#123; console.log('hash:', location.hash) &#125;) // JS 修改 url document.getElementById('btn1').addEventListener('click', () =&gt; &#123; location.href = '#/user' &#125;) &lt;/script&gt;&lt;/body&gt; H5 history主要使用 history.pushState和window.onpopstate 实现 12345678910111213141516171819202122&lt;body&gt; &lt;p&gt;history API test&lt;/p&gt; &lt;button id="btn1"&gt;修改 url&lt;/button&gt; &lt;script&gt; // 页面初次加载，获取 path document.addEventListener('DOMContentLoaded', () =&gt; &#123; console.log('load', location.pathname) &#125;) // 打开一个新的路由 用 pushState 方式，浏览器不会刷新页面 document.getElementById('btn1').addEventListener('click', () =&gt; &#123; const state = &#123; name: 'page1' &#125; console.log('切换路由到', 'page1') history.pushState(state, '', 'page1') &#125;) // 监听浏览器前进、后退 window.onpopstate = (event) =&gt; &#123; console.log('onpopstate', event.state, location.pathname) &#125; // 需要 server 端配合，可参考 // https://router.vuejs.org/zh/guide/essentials/history-mode.html &lt;/script&gt;&lt;/body&gt; Vue面试题 v-show和v-if的区别 123// v-show 通过css display 控制显示和隐藏// v-if 组件真正的渲染和销毁, 而不是显示和隐藏// 频繁切换显示状态用 v-show, 否则用 v-if 为何v-for中要用keykey可以提升vue的编译效率 提高复用key不能是index和random, 因为diff算法中通过tag和key来判断, 是否是相同节点sameNode当使用index索引做key时, 删除列表元素会有bug(bug产生原因就是vue就地复用策略导致的) 生命周期(父子组件生命周期)加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMounted-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated父组件更新过程 父beforeUpdate-&gt;父updated销毁过程 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed Vue组件如何通讯 父子组件 props和$emit 自定义事件 event.$on event.$emit event.$off vuex provide和inject $parent和$children/$refs eventbus $attrs/$listeners dispatch/boardcast 描述组件渲染和和更新的过程初次渲染 解析模板为render函数 触发响应式, 监听data属性getter setter 执行render函数(会触发getter), 生成vnode, patch(elem, vnode)更新过程 修改data, 触发setter 重新执行render函数, 生成newVnode patch(vnode, newVnode) 双向数据绑定v-model的实现原理 :value与@input 结合实现 1234567&lt;!-- input-price --&gt;&lt;input type="text" :value="price" @input="price=$event.target.value"&gt;&lt;!-- app.vue --&gt;&lt;div id="app"&gt; &lt;input-price v-model="price"&gt;&lt;/input-price&gt;&lt;/div&gt; computed有何特点computed 会缓存, data不变不会重新计算 提高性能 如何将组件所有props传递给子组件&lt;com v-bind=&quot;$props&quot;&gt; 何时使用异步组件加载大组件 路由异步加载 何时需要使用beforeDestroy 解绑自定义事件 event.$off 清楚定时器 解除自定义的DOM事件, 如scroll等 vuex中action和mutation有何区别 action中处理异步, mutation不可以处理异步只处理同步 action可以整合多个mutation Vue常见性能优化方式 自定义事件 dom事件及时销毁 合理使用异步组件 合理使用keep-alive data层级不要太深]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些面试题(2)]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98(2)%2F</url>
    <content type="text"><![CDATA[第1题 作用域1234567891011121314151617//// (1) 变量提升 var num1， num2， function f1()&#123;&#125;var num1 = 55var num2 = 66function f1(num, num1)&#123; // 有参数先声明形参的临时作用域 var num， num1 形参赋值 num=55， num1=66 num = 100 // 修改num num1 = 100 // 修改num1 num2 = 100 // 查找当前作用域 没有上一层作用域查找 找到全局 num2并修改为100 console.log(num) // 100 console.log(num1) // 100 console.log(num2) // 100&#125;f1(num1, num2)console.log(num2) // 100 全局num2在函数内部被修改为100console.log(num1) // 55 全局num1console.log(num) // 全局未找到num声明则报错 num is not defiend 第2题 值类型和引用类型的传递12345678910111213function Person(name, age)&#123; this.name = name this.age = age&#125;function f1(person)&#123; // 形参临时作用域 var person 形参声明 person = p (0x111) 赋值 person.name = 'ls' // 将 0x1111 地址中的name修改为 &#123; name: 'ls', age: 16 &#125; person = new Person('ww', 18) // 重新开辟空间 Ox2222 &#123;name: 'ww', age: 18&#125; 局部变量person指向新地址Ox2222&#125;var p = new Person('zs', 16) // 创建对象地址 Ox1111console.log(p.name) // zsf1(p)console.log(p.name) // ls 输出 Ox1111 地址中的 name: ls 第3题 字符串转驼峰命名123456789// 将 'get-element-by-id' 转化为 'getElementById'function toHump(str)&#123; var arr = str.split('-') for(var i=1;i&lt;arr.length;i++)&#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1) &#125; return arr.join('')&#125;toHump('get-element-by-id') // getElementById 第4题 冒泡排序123456789101112131415var arr = [2, 1, 5, 3, 4]var len = arr.length-1// 轮数for(var i=0;i&lt;len;i++)&#123; // 次数 for(var j=0;j&lt;len-i;j++)&#123; // 交换位置 if(arr[j]&gt;arr[j+1])&#123; var temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125;&#125;console.log(arr) 第5题 不使用reverse反转数组123456789101112// 交换位置 反转数组var arr = [1,2,3,4,5]for(var i=0;i&lt;arr.length/2;i++) &#123; // arr[0] 和 arr[arr.length-1-0] 交换 // arr[1] 和 arr[arr.length-1-1] 交换 // arr[2] 和 arr[arr.length-1-2] 交换 // 利用第三方变量交换两个变量的值 var temp = arr[i] arr[i] = arr[arr.length-1-i] arr[arr.length-1-i] = temp&#125;console.log(arr) 第6题 js综合面试题getName123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 变量提升 函数提升1 function Foo()&#123; getName = function()&#123; console.log(1) &#125; return this &#125;// 2 var getName 被同名函数 getName() 覆盖// 3 function getName()&#123; console.log(5) &#125;// 执行代码阶段Foo.getName = function()&#123; console.log(2) &#125;Foo.prototype.getName = function()&#123; console.log(3) &#125;getName = function()&#123; console.log(4) &#125;4 getName = function()&#123; console.log(4) &#125; // 全局方法最终执行到这里时function Foo()&#123; getName = function()&#123; console.log(1) &#125; return this&#125;Foo.getName = function()&#123; console.log(2) &#125; // 类的静态方法Foo.prototype.getName = function()&#123; console.log(3) &#125; // 累的实例方法getName = function()&#123; console.log(4) &#125; // 全局方法*/function Foo()&#123; getName = function()&#123; console.log(1) &#125; return this&#125;Foo.getName = function()&#123; console.log(2) &#125; // 类的静态方法Foo.prototype.getName = function()&#123; console.log(3) &#125;var getName = function()&#123; console.log(4) &#125;function getName()&#123; console.log(5) &#125;Foo.getName() // 2 执行类的静态方法 function()&#123; console.log(2) &#125;getName() // 4 执行全局方法 function()&#123; console.log(4) &#125;()// Foo() 执行 将全局getName修改为 getName = function()&#123; console.log(1) &#125; 并返回this --&gt; windowFoo().getName() // 1 (Foo()).getName()--&gt; window.getName()getName() // 1 执行全局方法 getName = function()&#123; console.log(1) &#125;// . 操作符优先级高 new (Foo.getName)() --&gt; new (function()&#123; console.log(2) &#125;)()new Foo.getName() // 2// (new Foo()).getName()--&gt; foo.getName() === Foo.prototype.getName()// foo.getName === Foo.prototype.getName 实例对象的隐式原型就等于构造函数的显示原型new Foo().getName() // 3// new ((new Foo()).getName)()--&gt; new (foo.getName)()--&gt; new (function()&#123; console.log(3) &#125;)()new new Foo().getName() // 3 第7题 什么是函数节流？ 什么是函数防抖 函数节流：一个函数执行一次后，只有大于设定的执行周期后才会执行第二次需要频繁触发的函数，在规定时间内，只让函数触发的第一次生效，后面不生效 12345678910111213141516171819/*** 节流函数* @param fn 要被节流的函数* @param delay 规定的时间*/function throttle(fn, delay)&#123; var lastTime = 0 // 记录上一次函数触发的时间 return function()&#123; var nowTime = Date.now() // 记录当前函数触发的时间 if (nowTime - lastTime &gt; delay) &#123; fn.call(this) // 修改this指向 &#125; lastTime = nowTime // 同步时间 &#125;&#125;document.onscroll = throttle(function()&#123; console.log('scroll')&#125;, 60) 防抖函数：一个需要频繁触发的函数，在规定时间内，只让函数触发的最后一次生效，前面的不生效 123456789101112131415161718/*** 防抖函数* @param fn 要被防抖的函数* @param delay 规定的时间*/function debounce(fn, delay)&#123; var timer = null return function () &#123; clearTimeout(timer) // 清除上一次延时器 // 重新设置新的延时器 timer = setTimeout(function () &#123; fn.call(this) &#125;, delay) &#125;&#125;input.oninput = debounce(function()&#123; console.log(input.value)&#125;, 200) 第8题 多维数组扁平化1234567var arr = [[1,2],[3,4,5,[6,7]]]function flatten(arr)&#123; return [].concat( ...arr.map(item =&gt; Array.isArray(item) ? flatten(item) : item) )&#125;console.log(flatten(arr)) 第9题 变量隐式转换123456789101112131415var a = &#123; &#125;, b = &#123; key:'b' &#125;, c = &#123; key:'c' &#125;;a[b] = 123;a[c] = 456;console.log(a[b]) // 456/* 首先a[b] 这里面b最后显示成什么？ 关于变量隐式转换，对象的a[]这种写法，里面添加的是属性名称--string类型 所以a[b]，b的原类型是object，目标是string类型。实际上是执行了a[b.toString()] 同理a[c]也一样 a[b.toString()]=123; a[c.toString()]=456; Object类型的变量 执行toString() 结果都是同样的字符串。----"[object Object]" 所以a["[object Object]"]=123; a["[object Object]"]=456;*/ 第10题 连等号执行顺序123456var y = 1, x = y = typeof x;console.log(x) // undefiend/* var y; var x // x ,y 此时都是undefiend ---&gt; y = 1 连等号从右向左执行 typeof x --&gt;undefiend(字符串) --&gt;y = undefined(字符串) --&gt; x = undefied(字符串)*/ 第11题 toString 特例12345// 对象.toString() ---&gt; [object Object]console.log(&#123;a: 1&#125;.toString()=='[object Object]');// 纯数字.toString() .在前面是纯数字时会被当成 小数点// 10.toString() ==&gt; (10.)toString() 报错// 10..toString() ==&gt; (10.).toString() '10' 第12题 对象引用12345678910111213141516171819202122232425var a = &#123;n:1&#125;var b = aa = &#123;n:2&#125;a.x = aconsole.log(a.x) // &#123;n: 2, x: &#123; n:2, x: &#123;n:2, x: ...&#125;&#125;&#125; 无限console.log(b) // &#123;n:1&#125;console.log(b.x) // undefined// = 赋值操作 不但会将右边的值保存到左边的变量中, 而且还会返回等号右边的值 a = &#123;n:2&#125; // &#123;n:2&#125;// A=B=C连等赋值真正的运算规则是 B=C; A=B 即连续赋值是从右至左永远只取等号右边的表达式结果赋值到等号左侧。var a = &#123;n:1&#125;var b = aa.x = a = &#123;n:2&#125;console.log(a) // &#123;n: 2&#125;console.log(a.x) // undefiendconsole.log(b) // &#123;n:1, x: &#123;n:2&#125;&#125;console.log(b.x) // &#123;n:2&#125;/*解答思路：1. 首先将对象&#123;n:1&#125;赋值给a变量 再将a赋值给b 这是一层浅拷贝过程 所以a和b变量都指向同一个对象&#123;n:1&#125;2. 由于点运算符优先于赋值运算符所以先在&#123;n：1&#125;对象中创建了一个x属性 &#123;n:1，x:（暂时无值）&#125; 这个过程 因为运算符优先级的原因 赋值符号还未执行的时候就已经完成了3. 再然后执行 a = &#123;n:2&#125; 此时a的引用地址发生了改变 从对象&#123;n:1&#125;指向了&#123;n:2&#125;4. a.x此时指向的是 &#123;n:1，x:（暂时无值）&#125;对象 然后将&#123;n：2&#125; 赋值给了a.x属性 此时A对象&#123;n:1， x：&#123;n：2&#125;&#125;5. 此时的a.x属性的父级对象a的初始引用地址是A对象 而A对象赋值给了b变量 所以你能在b.x中得到对象&#123;n：2&#125;6. 原对象地址因无人引用他 被垃圾回收机制回收了 对象被赋值了B对象&#123;n：2&#125; 所以原有的a.x为undefined*/ 第13题 var 会突破if限制1234567891011121314var name = "World!";(function()&#123; /* var name 变量提神 if限制不住var变量提升 ... */ if (typeof name === "undefined") &#123; var name = "Jack" console.log(name) &#125; else &#123; console.log(name) &#125;&#125;)()// Jack 第14题 原型链与对象属性查找12345678910function A () &#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 第15题 变量提升 this 原型链1234567891011121314151617181920212223242526272829303132function Person() &#123; getAge = function () &#123; console.log(10) &#125; return this&#125;Person.getAge = function () &#123; console.log(20)&#125;Person.prototype.getAge = function () &#123; console.log(30)&#125;var getAge = function () &#123; console.log(40)&#125;function getAge() &#123; console.log(50)&#125;/*变量提升 1. function Person &#123;getAge = function () &#123; console.log(10) &#125; return this &#125; 2. var getAge; function getAge() &#123; console.log(50) &#125;执行 3. Person.getAge = function () &#123; console.log(20) &#125; 给Person添加静态属性 getAge = function () &#123; console.log(20) &#125; 4. Person.prototype.getAge = function () &#123; console.log(30) &#125; 给Person原型上添加属性 getAge = function () &#123; console.log(30) &#125; 5. 为全局的getAge赋值 getAge = function () &#123; console.log(40) &#125;*/Person.getAge() // 20 ===&gt; function () &#123; console.log(20) &#125;() 输出 20getAge() // 40 ===&gt; 执行全局 getAge = function () &#123; console.log(40) &#125; 输出 40Person().getAge() // 10 ===&gt; 执行Person() 将全局 getAge修改为 function () &#123; console.log(10) &#125; 并返回this--&gt; window 调用window.getAge 即全局getAge 输出10getAge() // 10 ===&gt; 执行全局 getAge 输出10new Person.getAge() // 20 ==&gt; new 运算先找()才执行 执行 new Person.getAge() --&gt;Person.getAge --&gt; new function () &#123; console.log(20) &#125; 输出20new Person().getAge() // 30 ===&gt; new 先找()执行 var p = new Person() 创建实例对象p 调用p的方法 为找到则去构造函数的原型上查找 Person.prototype.getAge = function () &#123; console.log(30) &#125; 执行 function () &#123; console.log(30) &#125; 输出30 实例对象的 p.__proto__=== Person.prototype]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些面试题(1)]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[记录一些常见的面试题, 加深巩固下基础知识, 及时扫盲. JavaScript的数据类型都有什么？ 基本数据类型：string, boolean, number, undefined, null, symbol(es6), bigInt(es10) 引用数据类型：object(Array,Date,RegExp,Function) javascript的typeof返回哪些数据类型 javascript的typeof返回那些数据类型？object number function boolean undefined string symbol bigint 检测数组的几种方式Array.isArray(arr)arr.toString().call([]) // [Object Array] 1234567891011121314151617// 获取数据类型 类似typeof 但比typeof强大function getType(v)&#123; // .+? 惰匹匹配 return Object.prototype.toString.call(v).match(/\[object (.+?)\]/)[1].toLowerCase()&#125;getType([]) // "array"getType(NaN) // "number"getType(Symbol(1)) // "symbol"getType(BigInt("9007199254740995")) // "bigint"getType(null) // "null"getType(undefined) // "undefined"getType('0') // "string"getType(&#123;&#125;) // "object"getType(parseInt) // "function"getType(new Date()) // "date"getType(/^$/) // "regexp"getType(false) // "boolean" 事件绑定和普通事件有什么区别 普通事件onclick的方法不支持添加多个事件，最下面的事件会覆盖上面的 事件绑定（addEventListener）方式添加事件可以添加多个, 支持事件冒泡和事件捕获 call和apply的区别 参数的不同 call 第二个参数以后是参数列表 apply第二个参数是参数序列（数组） window.onload和$(document).ready区别 window.onload 是在dom文档树加载完和所有文件加载完之后执行的函数 $(document).ready 在dom文档树加载完之后执行的函数（文档树加载完不代表全部文件加载完） $(document).ready要比window.onload先执行 window.onload只能出来一次，$(document).ready可以出现多次 判断数组方式12345if(typeof Array.isArray === "undefined")&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)==="[object Array]" &#125;&#125; Javascript中callee和caller的作用？ caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 谈谈Cookie的弊端？ Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。 安全性问题。如果cookie被拦截了，就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 哪些操作会造成内存泄漏？ 内存泄漏: 指一块被分配的内存既不能使用又不能回收，直到浏览器进程结束。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 控制台日志 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） javascript 中的垃圾回收机制？ 垃圾回收: 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0(没有其他对象引用过该对象)，或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 获取非行间样式123function getStyle(obj,attr,value)&#123; return obj.currentStyle ? obj.currentStyle(attr) : obj.getComputedStyle(attr, false)&#125; 事件委托是什么 利用事件冒泡的原理，自己要触发的事件，让他的父元素代替执行！ 原生ajax步骤1234567891011var xhr =null;//创建对象if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest()&#125; else &#123; xhr = new ActiveXObject("Microsoft.XMLHTTP")&#125;xhr.open('方式','地址','标志位') // 初始化请求xhr.setRequestHeader('', '') // 设置http头信息xhr.onreadystatechange = function()&#123;&#125; // 指定回调函数xhr.send() // 发送请求xhr.abort() // 在接收响应之前调用abort方法来取消异步请求 请解释一下 JavaScript 的同源策略。 同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。所谓同源指的是：协议，域名，端口三者都相同 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 当发送一个 URL 请求时，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面显示。 什么是伪数组？如何将伪数组转化为标准数组？ 伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们.如 argument, NodeList 可以使用Array.prototype.slice.call(argument)将数组转化为真正的Array对象 关于javascript中apply()和call()方法的区别？ 相同点:两个方法产生的作用是完全一样的 不同点:方法传递的参数不同1234Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)// apply()接收两个参数，第一个是函数运行的作用域(this)，另一个是参数数组。// call()接收多个参数方法, 第一个参数为函数运行的作用域(this)，其他参数为传递给函数的参数列表 通用的事件侦听器函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576markyun.Event = &#123; // 页面加载完成后 readyEvent: function(fn) &#123; if (fn==null) &#123; fn=document &#125; var oldonload = window.onload if (typeof window.onload != 'function') &#123; window.onload = fn &#125; else &#123; window.onload = function() &#123; oldonload() fn() &#125; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false) &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element) &#125;) &#125; else &#123; element['on' + type] = handler &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false) &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler) &#125; else &#123; element['on' + type] = null &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation() &#125; else &#123; ev.cancelBubble = true &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault() &#125; else &#123; event.returnValue = false &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e) &#123; var ev = e || window.event if (!ev) &#123; var c = this.getEvent.caller while (c) &#123; ev = c.arguments[0] if (ev &amp;&amp; Event == ev.constructor) &#123; break &#125; c = c.caller &#125; &#125; return ev &#125;&#125; javascript继承的方式？原型链继承 借用构造函数继承 原型+构造函数继承 寄生式继承12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. 原型链继承function Animal () &#123; this.age = 20&#125;function Cat () &#123; this.name = 'jack'&#125;var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // undefined// 让Cat对象拥有了Animal对象的属性和方法Cat.prototype = new Animal()var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // 20// 2. 借用构造函数继承function Animal () &#123; this.age = 20&#125;function Cat () &#123; // Cat的所有对象借用了Animal对象的构造函数 Animal.call(this) this.name = 'jack'&#125;var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // 20// 3. 原型 + 构造函数继承组合继承// 4. 寄生式继承function Person(name, age)&#123; this.name = name this.age = age&#125;function createPerson(name, age)&#123; var obj = &#123;&#125; Person.call(obj, name, age) return obj&#125;var person = createPerson('tew', 28)console.log(person) // &#123;name: "tew", age: 28&#125;console.log(person.constructor) // ƒ Object() &#123; [native code] &#125; 如何理解闭包?闭包作用是什么、优缺点？使用闭包主要是为了设计私有的方法和变量.闭包的优点是可以避免全局变量的污染闭包的三个特性: 函数嵌套函数 函数外部可以引用内部的参数和变量 参数和变量不会被垃圾回收机制回收闭包的作用 保护（形成一个私有作用域，保护内部私有变量，不受外界干扰） 如：多人开发规避函数重名或变量重名问题 保存（形成一个不销毁的栈内存，把一些值保存起来）如：使用闭包解决循环绑定事件索引问题闭包的缺点是变量会常驻内存,会增大内存使用量,使用不当很容易造成内存泄漏 用js将字符串str的所有单词的首字母大写12345var test = 'a tom is stupid,sda.';var a = test.replace(/\b\w+\b/g,function(word)&#123; return word.substr(0,1).toUpperCase() + word.substr(1)&#125;)console.log(a) // A Tom Is Stupid,Sda. “use strict” 严格模式有哪些问题A.全局变量必须显示声明,给一个未用var声明的全局变量赋值会报错B.禁止删除变量, configurable设置为true的属性才能被删除C.对象不能有重名的属性,函数不能有重名的参数D.函数必须声明在顶层(if/for中声明函数会报错) 栈和队列的区别栈的插入和删除操作都是在一端进行的,而队列的操作却是在两端进行的.队列先进先出,栈先进后出栈只允许在末尾一端进行插入和删除,而队列只允许在末尾插入,在表头一端进行删除 栈和堆的区别栈区(stack) 由编译器自动分配释放, 存放函数的参数值,局部变量的值等 一种先进后出的数据结构堆区(heap) 一般由程序员分配释放, 若程序员不释放,程序结束时可能被系统回收. 堆可以被看成是一棵树 其他 注意: 一个函数的父级作用域是它定义时的作用域 而不是他执行时的作用域 描述new一个对象额过程12345678910/* 1. 创建一个新对象 2. this指向这个新对象 3. 执行代码 即对this赋值 4. 返回this（默认）*/function Foo(name)&#123; this.name = name // return this 默认有着一行&#125; iframe iframe 会阻塞主页面的onload事件 搜索引擎的检索程序无法解读这种页面,不利于SEO iframe和主页面共享连接池, 浏览器对相同域的链接有限制,会影响页面的并行加载 要使用iframe,最好是通过javascript动态给iframe的src属性赋值]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面嵌套iframe后rem失效]]></title>
    <url>%2F%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%A5%97iframe%E5%90%8Erem%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近在一个页面嵌套使用了iframe之后,发现iframe嵌套的页面样式乱了,但是页面样式都应用上了,查看元素之后发现,嵌套的iframe里面的html并没有动态的设置上font-size,它也没有应用外面的html的font-size大小，还是iframe自身默认rem值即1rem=16px,所以解决办法是给iframe里面的html也动态设置上font-size,但前提是必须在页面加载完成才有效即window.onload里面. 未设置之前 设置iframe中html的font-size大小1234567891011121314151617181920212223&lt;iframe src="./test.html" frameborder="0" width="100%" height="100%" id="myIframe"&gt;&lt;/iframe&gt;&lt;script&gt;//等比缩放!(function(doc, win) &#123; var timer, docEle = doc.documentElement, evt = "onorientationchange" in window ? "orientationchange" : "resize", setFontSize = function() &#123; var width = docEle.getBoundingClientRect().width; width &amp;&amp; (docEle.style.fontSize = 20 * (width / 320) + "px"); // iframe的html元素font-size设置 必须在加载完成去设置 win.onload = function() &#123; myIframe.contentWindow.document.documentElement.style.fontSize = width / 16 + "px" &#125; &#125;; win.addEventListener(evt, function() &#123; clearTimeout(timer); timer = setTimeout(setFontSize, 1000); &#125;, false); setFontSize() doc.addEventListener("DOMContentLoaded", setFontSize, false);&#125;(document, window));&lt;/script&gt; 设置之后]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webp图片使用]]></title>
    <url>%2Fwebp%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[webp是谷歌推出的一种图片格式，它的优点就是同等画面质量下，体积比jpg、png这些少了25%以上。并能节省大量的服务器带宽资源和数据空间。Facebook 淘宝等知名网站已经开始测试并使用WebP格式。但WebP是一种有损压缩。相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。 webp兼容性并不是所有浏览器都支持webp格式查看浏览器支持情况 webp工具及在线网站WebP - 图片格式的发展趋势 - 又拍云JPG轉WEBP轉換器。在线自由 — ConvertioJPG to WEBP, 免费在线JPG转换成WebP转换器 - JPG转换成WebPWebP官方转换工具手把手安装教程XnConvert 在项目中如何转换webp 使用WebP转换插件（imagemin-webp） npm i -D imagemin imagemin-webp 1234567const imagemin = require('imagemin');const imageminWebp = require('imagemin-webp');imagemin(['images/*.&#123;jpg&#125;'], 'images', &#123; use: [ imageminWebp(&#123;quality: 60&#125;)]&#125;).then(() =&gt; &#123; console.log('Images optimized');&#125;); 使用gulp-webp 需要gulp4及以上版本 npm i -D gulp-webp[gulp-webp相关参数](https://github.com/imagemin/imagemin-webp#imageminwebpoptions) 1234567891011121314151617181920const gulp = require('gulp');const webp = require('gulp-webp');//任务[转换webp] 有损压缩gulp.task('convert-webp', function () &#123; gulp.src('images/**/*.&#123;jpg,png,gif&#125;') .pipe(webp(&#123; quality: 70, preset: 'photo', method: 4 &#125;)) .pipe(gulp.dest('dist/images'))&#125;)// 无损压缩gulp.task('convert-webp', function () &#123; gulp.src('images/**/*.&#123;jpg,png,gif&#125;') .pipe(webp(&#123; lossless: true &#125;)) .pipe(gulp.dest('dist/images'))&#125;) 使用webp的方式 服务端处理在支持webp图片的浏览器向服务器发送请求时,会在请求头Accept中带上image/webp,服务器根据是否包含这个头信息决定是否返回webp图片 前端检测是否支持webp然后请求相应格式的图片通过特性检查用户浏览器是否支持webp,通常在页面中先执行一段webp的检测,对页面中使用img标签引入图片时可使用picture兼容webp方式.如果是css中的引入的图片,使用检测webp代码给html设置单独的类,通过这个类名引入webp背景图片覆盖原来其他格式的图片. 在gulp构建工具中webp前端的使用方式 通过js判断是否支持webp 并给html设置class为webp 12345678910111213141516/* 方法一 firefox不支持该语法 console.log(document.createElement('canvas').toDataURL('image/webp'))if (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0) &#123; document.documentElement.classList.add('webp')&#125; */// 方法二var image = new Image()// 一张支持alpha透明度的webp的图片，使用base64编码image.src = 'data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==';// 图片加载完成时候的操作image.onload = function() &#123; // 图片加载成功且宽度为1，那么就代表支持webp了，因为这张base64图是webp格式。如果不支持会触发image.error方法 if (image.width == 1) &#123; // html根节点添加class，并且埋入cookie document.documentElement.classList.add('webp') &#125;&#125; 在页面中使用标签&lt;picture&gt;标签利用多个&lt;source&gt;和一个&lt;img&gt;来设置显示的图像,如果用户的浏览器中不支持&lt;picture&gt;，浏览器将会将它渲染为一个&lt;div&gt;，并使用其中的&lt;img&gt;,不要将image/webp的格式放在旧格式的后面 12345678&lt;picture&gt; &lt;source srcset="images/adv1.png.webp" type='image/webp'&gt; &lt;img src="images/adv1.png" alt="" &gt;&lt;/picture&gt;&lt;picture&gt; &lt;source srcset="images/adv2.png.webp" type='image/webp'&gt; &lt;img src="images/adv2.png" alt="" &gt;&lt;/picture&gt; 在css中使用背景图片时 支持webp时 使用webp背景图覆盖原来图片 12345678910111213// 在scss中使用@mixin bg($url) &#123; background:url($url) no-repeat center; background-size: 100% 100%; @at-root .webp &amp;&#123; background-image:url($url + '.webp'); &#125;&#125;.sign-top&#123; position: relative; height: 680px; @include bg('../images/bg-top.png')&#125; 浏览器运行结果支持webp的浏览器 采用webp图片不支持webp的浏览器 采用原来的图片格式 在项目上线后处理后端返回的webp图片资源前提是要后端 通过nginx+lua+imageMagic生成webp图片,然后前端使用picture标签显示webp图片不支持则使用原来图片格式jpg或png webp的缺陷在某些场景下失真很严重例如有颜色的纯文字图片颜色变暗了 webp优势图片大小大大缩小 参考链接webp在项目中的实践重要的图像优化之五：什么是WebP？]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame实现动画]]></title>
    <url>%2FrequestAnimationFrame%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[requestAnimationFrame是html5提供的一个专门用于请求动画的API，顾名思义就是请求动画帧。requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。 requestAnimationFrame的优点 采用系统时间间隔，保持最佳绘制效率，间隔时间相对精确，不会引起丢帧，不会卡断。而setTimeout和setInterval时间间隔不精确。 requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般是大约每16.7ms执行一次 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下或者页面被隐藏或最小化时，动画会自动暂停，有效节省了CPU开销，当页面被激活时，动画从上次暂停的地方继续执行。可解决使用setTimeout或setInterval定时器的轮播图可能存在的问题。 使用setTimeout或setInterval实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源，由于动画在后台执行在返回页面未刷新时，有时会看到轮播图快速执行多次。 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量 如何使用requestAnimationFramerequestAnimationFrame的用法与setTimeout很相似，只是不需要设置时间间隔而已。requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。它返回一个整数，表示定时器的编号，这个值可以传递给cancelAnimationFrame用于取消这个函数的执行。12345// 定义requestAnimationFrame定时器var timer = requestAnimationFrame(function()&#123;&#125;)console.log(timer) // 1// cancelAnimationFrame 取消定时器cancelAnimationFrame(timer) //控制台什么都不输出 兼容性处理IE9及以下浏览器不支持该方法12345678window.requestAnimFrame = (function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback ) &#123; window.setTimeout( callback, 1000 / 60 ) &#125;&#125;)(); 简单使用案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #porgress &#123; display: block; margin: 16px 0; width: 400px; height: 16px; border-radius: 8px; background-color:#ececf4; display: flex; overflow: hidden; &#125; #porgress .inner&#123; width: 0px; height: 16px; border-radius: 8px; font-size: 12px; text-align: center; background-image: linear-gradient(to right, #8575ff, #6bcdfe); /* startColorstr表示起点的颜色，endColorstr 表示终点颜色。GradientType 表示渐变类型，0 为缺省值，表示垂直渐变，1 表示水平渐变 */ filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1, startColorstr=#8575ff, endColorstr=#6bcdfe);/*IE9*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="porgress"&gt; &lt;div class="inner"&gt;0%&lt;/div&gt; &lt;/div&gt;&lt;button id="btn"&gt;执行动画&lt;/button&gt;&lt;script&gt;/* 当页面最小化 或 隐藏时 或者 切换页面处于未激活时动画会自动暂停 重新激活 动画会从上次暂停的地方继续执行*/var timer;var startTime = 0var endTime = 0var n;var inner = document.querySelector('.inner')btn.onclick = function()&#123; n = 0; inner.style.width = '0px' cancelAniFrame &amp;&amp; cancelAniFrame(timer) startTime = new Date().getTime() console.log(startTime, '动画开始时间') timer = requestAnimFrame(step)&#125;function step()&#123; if (parseInt(inner.style.width) &lt; 400) &#123; inner.style.width = parseInt(inner.style.width) + 4 + 'px' inner.innerHTML = parseInt(inner.style.width) / 4 + '%' timer = requestAnimFrame(step) n++ &#125; else&#123; endTime = new Date().getTime() console.log(endTime, '动画结束时间') console.log(n, '动画执行次数') // 100 console.log((endTime - startTime)/n, '每次执行的时间') // 16.7 每次可能有点差别但都是16.x毫秒 在ie中大约时15ms cancelAniFrame &amp;&amp; cancelAniFrame(timer) &#125;&#125;window.requestAnimFrame = (function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback ) &#123; window.setTimeout( callback, 1000 / 60 ) &#125;&#125;)();window.cancelAniFrame = (function()&#123; return window.cancelAnimationFrame || window.mozCancelAnimationFrame&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发中常见问题]]></title>
    <url>%2Fvue%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue开发中常见问题及简单处理办法,model层数据变化,但视图未及时更新,路由切换时或路由参数变化时（即组件切换），页面（组件）不更新.在路由组件内部或子组件想刷新当前路由,而不刷新刷新整个页面. vue关于img src动态赋值问题 或在vue中的script中引用图片时只需要加上require即可123456&lt;!-- 场景1 --&gt;&lt;img :src="require('../assets/images/'+imgsrc+'.png')"/&gt;&lt;!-- 场景2 --&gt;&lt;script&gt; this.photo = require('../assets/img/photo.png')&lt;/script&gt; 生产环境请将 productionSourceMap: false 即生产环境 关闭sourcemap 否则会在浏览器source里面看到所有源码vue数据更新了但页面视图没更新问题 利用 Vue.$forceUpdate() 解决 vue数据更新了但页面视图没更新问题 123456789101112131415&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.2.2/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;span&gt;&#123;&#123;JSON.stringify(obj)&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data:&#123; obj: &#123; id: '001' &#125; &#125;&#125;)// vue无法检测实例被创建时不存在于data对象的属性即无法检测对象新增属性或移除属性vm.obj.msg = 'hello' // 不是响应式的 视图未反生变化 仍然展示 &#123;"id":"001"&#125;vm.$forceUpdate() // 加上强制更新视图 展示 &#123;"id":"001","msg":"hello"&#125;&lt;/script&gt; 通过重新赋值解决vue数据更新了但页面视图没更新问题 1234567891011121314151617181920212223&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.2.2/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;span&gt;&#123;&#123;JSON.stringify(obj)&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data:&#123; obj: &#123; id: '001' &#125; &#125;&#125;)// vm.obj.msg = 'hello' // 不是响应式的 视图未反生变化 仍然展示 &#123;"id":"001"&#125;// 使用重新赋值解决 数据变化 视图未发生变化// 将属性添加到data对象上才能让 Vue.js 转换它，才能让它是响应的。// 方式1 直接构建新对象再重新赋值 推荐使用vm.obj = &#123; ...vm.obj, msg: 'hello'&#125;// 方式2 将对象合并到新对象上再重新赋值 会改变对象的属性顺序vm.obj = Object.assign(&#123;msg: 'hello'&#125;,vm.obj)// vm.obj = Object.assign(vm.obj, &#123;msg: 'hello'&#125;) // 将新对象合并到旧对象再赋值 无法实现&lt;/script&gt; 使用 Vue.set() 或 this.$set()Vue.set(对象, 属性, 值) 或 this.$set(对象, 属性, 值) 无法检测对象属性的添加或删除官方 - 由于 JavaScript（ES5） 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。 12345678910111213141516171819202122232425&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.2.2/vue.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;span&gt;&#123;&#123;JSON.stringify(obj)&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data:&#123; obj: &#123; id: '001' &#125; &#125;&#125;)// vm.obj.msg = 'hello' // 不是响应式的 视图未反生变化 仍然展示 &#123;"id":"001"&#125;// delete vm.obj.id // 不是响应式的 仍然展示 &#123;"id":"001"&#125;// 解决办法// 动态添加 - Vue.set// Vue.set(vm.obj, 'msg', 'hello') // 响应式的 视图展示 &#123;"id":"001","msg":"hello"&#125;// // 动态添加 - vm.$set// vm.$set(vm.obj, 'msg', 'hello') // 响应式的 视图展示 &#123;"id":"001","msg":"hello"&#125;// // 动态添加多个// vm.obj = Object.assign(&#123;&#125;, vm.obj, &#123; 'msg': 'hello' &#125;) // 响应式的 视图展示 &#123;"id":"001","msg":"hello"&#125;// // 动态移除 - Vue.delete// Vue.delete(vm.obj, 'id') // 响应式的 视图展示 &#123;&#125;// // 动态移除 - vm.$deletevm.$delete(vm.obj, 'id') // 响应式的 视图展示 &#123;&#125;&lt;/script&gt; Vue 不能检测通过数组索引直接修改一个数组项也不能检测到数组长度的变化官方 - 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化； 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;span v-for="item in items"&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的 页面中items依然为 ['a', 'b', 'c']// 解决办法// Vue.set// Vue.set(vm.items, 1, 'x') // 页面中items同步响应修改为 ['a', 'x', 'c']// vm.$set// vm.$set(vm.items, 1, 'x') // 页面中items同步响应修改为 ['a', 'x', 'c']// Array.prototype.splice// vm.items.splice(1, 1, 'x') // 页面中items同步响应修改为 ['a', 'x', 'c']// // 数组长度的变化// vm.items.length = 2 // 不是响应性的 页面中items依然为 ['a', 'b', 'c']// 解决数组长度未变化// vm.items.splice(2) // 页面中items同步响应修改为 ['a', 'x']&lt;/script&gt; 路由切换时或路由参数变化时（即组件切换），页面（组件）不更新（数据不更新）路由视图组件引用了相同组件时，当路由参会变化时，会导致该组件无法更新12345678910111213141516171819202122232425262728293031&lt;!-- app.vue --&gt;&lt;div id="app"&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to="/home/foo"&gt;To Foo&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to="/home/baz"&gt;To Baz&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to="/home/bar"&gt;To Bar&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;!-- home.vue --&gt;&lt;template&gt; &lt;div class="home"&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', data () &#123; return &#123; msg: this.$route.params.name &#125; &#125;&#125;&lt;/script&gt;&lt;!-- router/index.js --&gt;&lt;!-- 路由构建选项 routes 中配置了一个动态路由 '/home/:name'，它们共用一个路由组件 Home，这代表他们复用 RouterView当进行路由切换时，页面只会渲染第一次路由匹配到的参数，之后再进行路由切换时，msg 是没有变化的。 --&gt;new VueRouter(&#123; routes: [ &#123;path: '/home/:name', component: Home &#125; ]&#125;) 解决办法 通过 watch 监听 $route 的变化。 12345678910111213141516171819202122&lt;!-- 在home.vue中监听 $route 变化 --&gt;&lt;template&gt; &lt;div class="home"&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', data () &#123; return &#123; msg: this.$route.params.name &#125; &#125;, watch: &#123; $route: &#123; handler: function (route) &#123; this.msg = route.params.name &#125;, immediate: true &#125; &#125;&#125;&lt;/script&gt; 利用组件内守卫beforeRouteUpdate路由参数更新时触发 可以代替watch 1234567891011121314151617&lt;template&gt; &lt;div class="home"&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', data () &#123; return &#123; msg: this.$route.params.name &#125; &#125;, beforeRouteUpdate (to, from, next) &#123; this.msg = to.params.name next() &#125;&#125;&lt;/script&gt; 给&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;增加一个不同:key值 123456789101112131415161718192021&lt;!-- 修改app.vue --&gt;&lt;template&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to="/home/foo"&gt;To Foo&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to="/home/Bar"&gt;To Bar&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view :key="key"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', computed: &#123; key () &#123; return this.$route.path + Math.random() &#125; &#125;&#125;&lt;/script&gt; 给&lt;router-view v-if=&quot;routerAlive&quot;&gt;&lt;/router-view&gt;增加一个不同v-if值，先摧毁&lt;router-link&gt;，然后再重新创建 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="app"&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to="/home/foo" @click.native="routerRefresh"&gt;To Foo&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to="/home/Bar" @click.native="routerRefresh"&gt;To Bar&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view v-if="routerAlive"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; routerAlive: true &#125; &#125;, methods: &#123; routerRefresh () &#123; this.routerAlive = false this.$nextTick(() =&gt; &#123; this.routerAlive = true &#125;) &#125; &#125;&#125;&lt;/script&gt; 总结： 如果使用的是编程式导航路由，还是使用watch监听路由或者使用组件内路由钩子beforeRouteUpdate比较好 在路由组件内部或子组件刷新当前路由即刷新当前路由页面在日常开发中在当前路由组件中或当前路由子组件执行删除或新增数据之后需要刷新当前路由页面更新数据，但又不想使用location.reload(), 则可以使用provide和inject配合router-view的v-if来解决刷新问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- 根组件 app.vue --&gt;&lt;template&gt; &lt;div class="app"&gt; &lt;router-view v-if="routerAlive"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; routerAlive: true &#125; &#125;, provide () &#123; // 在父组件中创建属性 return &#123; routerRefresh: this.routerRefresh &#125; &#125;, methods: &#123; routerRefresh () &#123; this.routerAlive = false this.$nextTick(() =&gt; &#123; this.routerAlive = true &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Home.vue 当前路由页面 --&gt;&lt;template&gt; &lt;div class="home"&gt; &lt;Child :parentData="parentData" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child'export default &#123; name: 'Home', components: &#123; Child &#125;, data () &#123; return &#123; parentData: [1, 2] &#125; &#125;&#125;&lt;/script&gt;&lt;!-- child.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;parentData&#125;&#125;&lt;/div&gt; &lt;button @click="delData"&gt;更改数据&lt;/button&gt;&lt;br /&gt; &lt;button @click="linkToHome"&gt;跳转到当前路由，parentData为修改后[1, 2, 3]&lt;/button&gt;&lt;br /&gt; &lt;button @click="linkToHomeFresh"&gt;刷新当前路由，使parentData回到初始值[1, 2]&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['parentData'], name: 'child', inject: ['routerRefresh'], // 在子组件中注入在父组件中出创建的属性 methods: &#123; delData () &#123; this.parentData.push(3) &#125;, linkToHome () &#123; this.$router.push('/') // 路由跳转到首页但未刷新首页 &#125;, linkToHomeFresh () &#123; this.routerRefresh() // 刷新首页 &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="scss" scoped&gt;button&#123; margin-top: 10px &#125;&lt;/style&gt; ##]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用uniapp开发跨端小程序]]></title>
    <url>%2Funiapp%2F</url>
    <content type="text"><![CDATA[uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。uni-app在跨平台的过程中，不牺牲平台特色，可优雅的调用平台专有能力。 uniapp官网地址uniapp官网地址 uniapp的优势 开发者/案例数量更多 平台能力不受限 支持原生代码混写和原生sdk集成 性能体验优秀 体验更好的Hybrid框架，加载新页面速度更快 周边生态丰富 支持NPM、支持小程序组件和SDK、兼容mpvue组件和项目、兼容weex组件 学习成本低 采用vue语法+微信小程序api 开发成本低 开发成本，招聘、管理、测试各方面成本都大幅下降 uinapp特色 条件编译1234567891011#ifdef APP-PLUS需要条件编译的代码 仅出现在App平台下的代码#endif#ifndef H5需要条件编译的代码 除了H5平台,其他平台均存在的代码#endif#ifdef H5 || MP-WEIXIN需要条件编译的代码 在H5平台或微信小程序平台存在的代码#endif 条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 // #ifdef、css 使用 /* #ifdef */、vue/nvue 模板里使用 &lt;!-- #ifdef --&gt; App端的Nvue开发 HTML5+ uniapp开发环境搭建 通过 HBuilderX 可视化界面 快速上手 运行uni-app 第一次使用，需要配置开发工具的相关路径。点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 运行设置，配置相应小程序开发者工具的路径 在微信开发者工具打开时,需要先在微信开发者工具中开启服务端口 设置 -&gt; 安全 -&gt; 开启服务端口 通过vue-cli命令行1234567全局安装vue-cli npm install -g @vue/cli创建uni-app vue create -p dcloudio/uni-preset-vue my-project运行、发布uni-appnpm run dev:%PLATFORM%npm run build:%PLATFORM%%PLATFORM% 取值 app-plus(app平台)、h5、mp-alipay(支付宝)、mp-baidu(百度)、mp-weixin(微信)、mp-toutiao(头条)、mp-qq(qq)、mp-360(360)、quickapp-webview(快应用通用)、quickapp-webview-huawei(快应用华为)、quickapp-webview-union(快应用联盟) uniapp生命周期生命周期 应用生命周期 只能在App.vue中使用 123// onLaunch 应用初始化完成 全局只触发一次// onShow 应用启动的时候 或者从后台进入前台会触发// onHide 应用从前台进入后台 页面生命周期 123456789// onload 监听页面加载 可以获取页面传参// onReady 监听页面的初次渲染完成// onShow 监听页面显示 包括从下级页面点返回露出当前页面// onHide 监听页面隐藏// onUnload 监听页面卸载// onPullDownRefresh 监听用户下拉动作，一般用于下拉刷新// onReachBottom 页面滚动到底部的事件 一般用于上拉加载// onTabItemTap 点击 tabbar 触发// onShareAppMessage 用户点击右上角分享 组件生命周期(即vue的生命周期)uni-app 组件支持的生命周期，与vue标准组件的生命周期相同常用生命周期执行顺序 123456789101112// App Launch// APP Show// Page Onload// Page onShow// component beforeCreate// component created// component beforeMounted// component Mounted// Page onReady// component beforeDestroy// component destroyed// Page onUnload uniap默认模板目录 components 自定义组件的目录 pages 页面存放目录 static 静态文件资源目录 unpackage 编译后的文件存放目录 app.vue 全局公用的状态数据等 main.js 应用入口 manifest.json 项目基础配置 pages.json 页面相关配置 注册页面 设置页面名称等 uni.scss 公用的scss变量 无需import这个文件 uniapp配置启动模式 conditionuniapp使用中其他问题 屏蔽自定义导航栏 仅支持 default/custom。custom即取消默认的原生导航栏 注意事项 123"globalStyle": &#123; "navigationStyle": "custom"&#125; 自动导入自定义组件 无需import 123456// components/navbar/navbar.vue// index.vue 中 直接使用 &lt;navbar /&gt; 等同于以下// import navbar from '../components/navbar/navbar.vue'// components: &#123;// navbar// &#125; 在非H5 app mp-alipay中胶囊的位置 1234// 获取胶囊位置const menuButtonInfo = uni.getMenuButtonBoundingClientRect()console.log(menuButtonInfo)// wx &#123;width: 87, height: 32, left: 278, right: 365, top: 26, bottom: 58&#125;]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli3常用配置]]></title>
    <url>%2FVue-Cli3%2F</url>
    <content type="text"><![CDATA[vue-cli3.0 功能丰富：对babel、Typescript、ESLint提供开箱即用的支持;易于扩展;无需Eject：vue cli 完全可配置的，无需再使用webpack配置;CLI图形化界面：vue ui图形化界面创建、开发和管理项目;即刻创建原型：用单个vue文件实现新的灵感;为现代浏览器轻松产出原生的ES2015代码，或将你的vue组件构建为原生的Web Components组件 Vue-cli3安装 Vue-cli 先卸载vue-cli2 npm uninstall vue-cli -g 安装vue-cli3 npm install -g @vue/cli 查看安装vue-cli版本 vue -V 使用图形界面创建项目 vue ui 使用命令行创建项目 vue create project 进入项目目录 cd project 启动项目 npm run serve在Vue-cli3中要使用vue-cli2.x版本 需要全局安装桥接工具 npm install -g @vue/cli-init 然后在使用vue init webpack project 初始化项目 配置npm run serve后自动打开浏览器 在package.json中修改 123"scripts": &#123; "serve": "vue-cli-service serve --open"&#125;, vue-cli3默认的目录结构 12345678910111213141516├── node_modules # 项目依赖包目录├── public│ ├── favicon.ico # ico图标│ └── index.html # 首页模板├── src│ ├── assets # 样式图片目录│ ├── components # 组件目录│ ├── views # 页面目录│ ├── App.vue # 父组件│ ├── main.js # 入口文件│ ├── router.js # 路由配置文件│ └── store.js # vuex状态管理文件├── .gitignore # git忽略文件├── .postcssrc.js # postcss配置文件├── babel.config.js # babel配置文件└── package.json # 包管理文件 与vue-cli 2.x的差异使用vue-cli 2.x构建出的目录会包含相应的webpack配置文件，但是在vue-cli 3.x中提供了一种开箱即用的模式，隐藏了webpack的配置，即你无需配置 webpack 就可以运行项目，并且它提供了一个 vue.config.js 文件来满足开发者对其封装的 webpack 默认配置的修改 vue.config.js配置Vue-cli3中vue.config.js文件配置参考文档：参考文档`1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// vue.config.js 配置说明//官方vue.config.js 参考文档 https://cli.vuejs.org/zh/config/#css-loaderoptionsmodule.exports = &#123; // 部署生产环境和开发环境下的URL。默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上 //例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/。 publicPath: process.env.NODE_ENV === "production" ?'/my-app/':'/', // outputDir: 在npm run build 生成文件的目录名称（要和baseUrl的生产环境路径一致） outputDir: "dist", //用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下） assetsDir: "assets", //指定生成的 index.html 的输出路径 (打包之后，改变系统默认的index.html的文件名) // indexPath: "myIndex.html", //默认情况下，生成的静态资源文件名中包含了 hash以便更好的控制缓存。将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变) filenameHashing: false, // lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint lintOnSave: true, //是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false) runtimeCompiler: true, /** * 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 * 打包之后发现map文件过大，项目文件体积很大，设置为false就可以不输出map文件 * 不使用source map 可以防止在生产环境看到源代码 */ productionSourceMap: false, // 它支持webPack-dev-server的所有选项 devServer: &#123; host: "localhost", // 指定使用一个host默认是 localhost port: 8899, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: true, //是否自动启动浏览器 overlay: &#123; // 设置让浏览器 overlay 同时显示警告和错误 false不显示 warnings: false, errors: false &#125;, // 配置代理 proxy: &#123; "/api": &#123; target: "&lt;url&gt;", ws: true, changeOrigin: true, pathRewrite: &#123; // 替换路径 '^/api': '/jsons' &#125; &#125;, &#125; &#125;, //调整 webpack 配置 在 vue.config.js 中的 configureWebpack 选项提供一个对象 //该对象将会被 webpack-merge 合并入最终的 webpack 配置 configureWebpack: &#123; // 配置别名方式1 name: name, resolve: &#123; alias: &#123; // 配置别名 将复杂的文件路径定义成一个变量来访问 '@': resolve('src'), '_common': resolve('src/common') &#125; &#125; &#125;, // 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。可以让我们能够使用链式操作来修改配置 chainWebpack(config) &#123; config.module .rule('vue') .use('vue-loader') .loader('vue-loader') .tap(options =&gt; &#123; // 修改它的选项... return option &#125;) // 配置别名方式2 在样式中或html模板中引用路径的间写时前面需要加上~符 避免解析失败 // .bg&#123;background-url:~_assets/common/bg1.jpg&#125; 或 &lt;img src="~_assets/common/banner1.png" /&gt; config.resolve.alias .set('@', path.resolve('src')) .set('_assets', path.resolve('src/assets')) // 删除预加载文件 空闲时下载 &lt;link href="/js/1.js" rel="prefetch"&gt; config.plugins.delete('prefetch') &#125;&#125;; 查看默认及修改后的webpack配置 vue inspect 查看所有的webpack配置 vue inspect --mode &lt;mode&gt; 查看某个环境的配置 mode取值有 develop、test、develop vue inspect --rules 查看所有已配置规则名称列表 1234567891011121314151617vue inspect --rules[ 'vue', 'images', 'svg', 'media', 'fonts', 'pug', 'css', 'postcss', 'scss', 'sass', 'less', 'stylus', 'js', 'eslint'] vue inspect --rule &lt;ruleName&gt; 查看指定规则的配置 1234567891011121314151617181920vue inspect --rule images/* config.module.rule('images') */&#123; test: /\.(png|jpe?g|gif|webp)(\?.*)?$/, use: [ /* config.module.rule('images').use('url-loader') */ &#123; loader: 'xxx\\node_modules\\url-loader\\dist\\cjs.js', options: &#123; limit: 4096, fallback: &#123; loader: 'xxx\\node_modules\\file-loader\\dist\\cjs.js', options: &#123; name: 'img/[name].[hash:8].[ext]' &#125; &#125; &#125; &#125; ]&#125; vue inspect --plugins 查看所有plugins插件配置名称列表 1234567891011vue inspect --plugins[ 'vue-loader', 'define', 'case-sensitive-paths', 'friendly-errors', 'html', 'preload', 'prefetch', 'copy'] vue inspect plugin &lt;pluginName&gt; 查看指定的plugin插件的配置 123456789vue inspect --plugin html/* config.plugin('html') */new HtmlWebpackPlugin( &#123; title: 'pro', templateParameters: function () &#123; /* omitted long function */ &#125;, template: 'xxx\\public\\index.html' &#125;) vue inspect plugins 查看所有plugins插件配置 12345678910111213141516[ /* config.plugin('vue-loader') */ new VueLoaderPlugin(), /* config.plugin('define') */ new DefinePlugin( &#123; 'process.env': &#123; NODE_ENV: '"development"', BASE_URL: '"/"' &#125; &#125; ), /* config.plugin('case-sensitive-paths') */ new CaseSensitivePathsPlugin(), ...] .env文件与环境配置不同的配置文件.env对应不同的环境123456789101112131415161718192021222324.env # 在所有的环境中被载入.env.local # 在所有的环境中被载入，但会被 git 忽略.env.[mode] # 只在指定的模式中被载入.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略相同配置项的权重：.env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env修改package.json中的npm-script脚本的命令如："scripts": &#123; // 测试环境 对应配置文件 .env.test "build-test": "vue-cli-service build --mode=test", // 生产环境 对应配置文件 .env.prod "build-prod": "vue-cli-service build --mode=prod"&#125;build-test 会读取.env.test配置文件build-prod 会读取.env.prod配置文件vue-cli-service serve 会使用默认环境developmentvue-cli-service build 会使用默认环境production// vue.config.jsconsole.log(process.env.NODE_ENV); // development（在终端输出）仅支持注入环境配置文件中以 VUE_APP_ 开头的变量// .env.testVUE_APP_clientId = 350VUE_APP_DBS_URL = 'http://33.11.22.45'// 使用headers.clientId =process.env.VUE_APP_clientId 在VueCLI3使用template模板报错 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. VueCLI3默认使用vue.runtime.js，不允许编译template模板，用了template选项，会报错。解决方案有两种，一是手动将template改写为Render函数；另一种是修改vue.config.js：module.exports={ runtimeCompiler: true // 使用包含运行时编译器的 Vue 构建版本。可以在 Vue 组件中使用 template 选项，但是额外增加 10kb 左右} build.js 说明 app.[hash].css 将组件中的css编译合并 app.[hash].js 包含所有components中的js代码(当前应用程序开发的所有代码(业务代码)) vendor.[hash].js 包含了所有引用的node_mdules中的代码(第三方库代码 vue/vue-router/axios等) 生产环境请将 productionSourceMap: false 即生产环境 关闭sourcemap 否则会在浏览器source里面看到所有源码]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue工程不同环境配置文件自动切换]]></title>
    <url>%2Fvue%E5%B7%A5%E7%A8%8B%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[项目环境一般分为开发环境、测试环境、生产环境，每个环境的接口域名和其他配置、webpack配置可能都是不同的配置，每次打包构建不能总是手动去更改这些配置，我们应当根据打包的环境去动态判断不同环境自动切换配置，尤其是自动化构建部署如jenkins。 使用node的fs模块实现vue-cli2中根据打包环境动态切换配置 配置文件 src/common/config.js123456789101112131415161718192021222324// 部署不同的环境时 需要修改 DBS_ENV 的值// 0 开发环境 1为测试环境1 2为测试环境2 3为正式环境var DBS_ENV = 1var baseUrl = ''var clientId = ''swicth (DBS_ENV)&#123; case 0: baseUrl = 'http://192.168.5.6' clientId = '90' break case 1: baseUrl = 'http://22.11.33.44' clientId = '91' break case 2: baseUrl = 'http://22.55.33.99' clientId = '92' break case 3: baseUrl = 'https://xxx.cn' clientId = '93' break&#125;export default &#123;baseUrl, clientId&#125; 修改package.json中的npm scripts的打包命令 123456scripts: &#123; "dev": "node build/dev-server.js", // 开发环境 "build-T1": "node build/build.js", // T1测试环境1 "build-T2": "node build/build.js", // T2测试环境2 "build-pro": "node build/build.js" // pro生产环境&#125; 在build.js中通过打包参数修改src/common/config.js文件中DBS_ENV值 1234567891011121314151617181920212223242526272829303132// 读取配置文件const fs = require('fs')let fileContent = ''const envPath = path.resolve(__dirname, '../src/common/config.js')try &#123; fileContent = fs.readFileSync(envPath, 'utf-8')&#125; catch(error)&#123; console.log(chalk.red(error + '/n')) process.exit(1)&#125;// 获取打包命令判断打包环境参数const event = process.env.npm_lifecycle_eventlet env = 1switch(event)&#123; case 'build-T1': env = 1 break case 'build-T2': env = 2 break case 'build-pro': env = 3 break&#125;// 根据打包参数修改配置文件并写入const text = fileContent.replace(/(var DBS_ENV = \d;)/, `var DBS_ENV = $&#123;env&#125;;`)try &#123; fs.writeFileSync(envPath, text, 'utf-8')&#125; catch(error)&#123; console.log(chalk.red(error + '/n')) process.exit(1)&#125; 打包完成放弃src/common.config.js修改 12345678910let childProcess = require('child_process')// 在build.js中的打包完成回调中 webpack(webpackconfig, function()&#123;xxx&#125;)// svn 版本管理回退// childProcess.execSync('svn revert src/common/config.js', function(err, stdout, stdin)&#123;// console.log(chalk.red(err))// &#125;)// git 版本管理回退childProcess.execSync('git checkout -- src/common/config.js', function(err, stdout, stdin)&#123; console.log(chalk.red(err))&#125;) 使用cross-env和webpack.DefinePlugin()实现vue-cli2中根据打包环境动态切换配置 cross-env:可以跨平台设置和使用环境变量(process.env)的node模块包 webpack.DefinePlugin(): webpack通过DefinePlugin内置插件将process.env注入到客户端代码中,定义的变量可以在webpack打包范围内任意javascript环境内访问 修改package.json中的npm scripts的打包命令 123456scripts: &#123; "dev": "node build/dev-server.js", // 开发环境 "build-T1": "cross-env MODE=T1 node build/build.js", // T1测试环境1 "build-T2": "cross-env MODE=T2 node build/build.js", // T2测试环境2 "build-pro": "cross-env MODE=pro node build/build.js" // pro生产环境&#125; 修改config/dev.env.js和config/prod.env.js 1234567891011// config/dev.env.jsmodule.export = &#123; NODE_ENV: '"development"', MODE: '"dev"' // 全局变量&#125;)// config/prod.env.jsmodule.export = &#123; NODE_ENV: '"production"', // process.env.MODE 是通过 cross-env 设置的环境变量 即T1或T2或pro MODE: JSON.stringify(process.env.MODE) // 全局变量字符串需要使用JSON.stringify()&#125;) 在webpack.dev.conf.js和webpack.prod.conf.js通过new webpack.DefinePlugin()注入到执行环境中使用 123456789101112// webpack.dev.conf.jsplugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;)]// webpack.prod.conf.jsplugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/prod.env') &#125;)] 配置文件动态赋值 src/common/config.js 12345678910111213141516171819202122232425262728// 通过cross-env 和 webpack.DefinePlugin() 将process.env注入到执行环境(客户端代码)中使用// 设置DBS_ENV 的值 0 开发环境 1为测试环境1 2为测试环境2 3为正式环境var DBS_ENV = ''var baseUrl = ''var clientId = ''const envArr = ['dev', 'T1', 'T2', 'pro']if (envArr.indexOf(process.env.MODE) &gt; -1) &#123; DBS_ENV = envArr.indexOf(process.env.MODE)&#125;swicth (DBS_ENV)&#123; case 0: baseUrl = 'http://192.168.5.6' clientId = '90' break case 1: baseUrl = 'http://22.11.33.44' clientId = '91' break case 2: baseUrl = 'http://22.55.33.99' clientId = '92' break case 3: baseUrl = 'https://xxx.cn' clientId = '93' break&#125;export default &#123;baseUrl, clientId&#125; 其他用处 可以通过process.env.MODE设置sourceMap 12345// config/indx.jsbuild: &#123; // 生产环境关闭sourcemap(避免暴露源码) 开发环境和测试环境开启sourcemap便于调试和定位错误 productionSourceMap: process.env.MODE === 'pro' ? false : true&#125; 可以通过process.env.MODE设置仅在开发环境和测试环境引入vconsole 1234567// main.js 仅在开发环境和测试环境引入vconsoleif (process.env.MODE!=='pro') &#123; // 不能使用 import vConsole from 'vconsole' 或 import('vconsole') 静态引入 不能放在if里面会报错 // SyntaxError: xxx/main.js 'import' and 'export' may only appear at the top level let vConsole = require('vconsole') // 使用require引入 可放在if里动态引入 new vConsole()&#125; 使用process.env.npm_config_arg|process.argv和webpack.DefinePlugin()实现vue-cli2中配置切换process.env.npm_config_argv或process.argv可以获取npm命令行的参数,动态设置MODE，然后通过DefinePlugin注入 修改package.json中的npm scripts的打包命令 123456789scripts: &#123; "dev": "node build/dev-server.js", // 开发环境 "build": "node build/build.js"&#125;// 打包构建 在执行 npm run build 时多加入一个命令行参数/* npm run build T1 // T1测试环境1* npm run build T2 // T2测试环境2* npm run build pro // pro生产环境*/ 修改config/dev.env.js和config/prod.env.js 1234567891011121314151617// config/dev.env.jsmodule.export = &#123; NODE_ENV: '"development"', MODE: '"dev"' // 全局变量&#125;)// config/prod.env.jsmodule.export = &#123; NODE_ENV: '"production"', // 方式1 // process.env.npm_config_argv-&gt;JSON字符串 获取npm命令行的参数,动态设置MODE // npm run build pro -&gt; process.env.npm_config_argv -&gt; '&#123;"remain":["pro"], "cooked":["run", "build", "pro"],...&#125;' // 全局变量字符串需要使用JSON.stringify() MODE: JSON.stringify(JSON.parse(process.env.npm_config_argv).remain[0]) // 方式2 // npm run build pro -&gt; 使用 process.argv -&gt; ["c:\\xxx\node.exe", "D:\\project\xx\build.js", "pro"] // MODE: JSON.stringify(process.argv[2])&#125;) 其他步骤和上个方法一致 使用自定义loader实现配置环境的切换 package.json中的npm scripts的打包命令 123456scripts: &#123; "dev": "node build/dev-server.js", // 开发环境 "build-T1": "node build/build.js", // T1测试环境1 "build-T2": "node build/build.js", // T2测试环境2 "build-pro": "node build/build.js" // pro生产环境&#125; 配置文件 src/common/config.js 12345678910111213141516171819202122var DBS_ENV = ''var baseUrl = ''var clientId = ''swicth (DBS_ENV)&#123; case 0: baseUrl = 'http://192.168.5.6' clientId = '90' break case 1: baseUrl = 'http://22.11.33.44' clientId = '91' break case 2: baseUrl = 'http://22.55.33.99' clientId = '92' break case 3: baseUrl = 'https://xxx.cn' clientId = '93' break&#125;export default &#123;baseUrl, clientId&#125; 自定义loader替换环境变量 1234567891011121314// loaders/config-loader.jsmodules.exports = function (content) &#123; this.cacheable() if (process.env.npm_lifesycle_event === 'build-T1') &#123; content.replace(/(var DBS_ENV = \d)/, `var DBS_ENV = 1`) &#125; else if (process.env.npm_lifesycle_event === 'build-T2')&#123; content.replace(/(var DBS_ENV = \d)/, `var DBS_ENV = 2`) &#125; else if (process.env.npm_lifesycle_event === 'build-pro')&#123; content.replace(/(var DBS_ENV = \d)/, `var DBS_ENV = 3`) &#125; else &#123; content.replace(/(var DBS_ENV = \d)/, `var DBS_ENV = 0`) &#125; return content&#125; 使用loader webpack.base.conf.js 12345678module: &#123; rules: [ &#123; test: /config\.js$/, loader: path.resolve('loaders') + '/config-loader' &#125; ]&#125; vue-cli3及以上使用不同的.env文件设置不同的环境配置vue-cli3.x封装了webpack配置，.env文件中的变量都会被放入当process.env中，我们可以直接在客户端代码中使用process.env的值，该对象可以包含多个键值对，仅支持注入环境配置文件中以VUE_APP_开头的变量，也是通过webpack.DefinePlugin()实现 在根目录下设置不同环境的配置文件 123456789// .env.T1 测试环境1配置VUE_APP_baseUrl = 'http://22.11.33.44'VUE_APP_clientId = 91// .env.T2 测试环境2配置VUE_APP_baseUrl = 'http://22.55.33.99'VUE_APP_clientId = 92// .env.prod 生产环境VUE_APP_baseUrl = 'http://xxx.cn'VUE_APP_clientId = 93 修改package.json中的npm-script脚本的命令 123456789"scripts": &#123; // vue-cli-service build --mode=xxx webpack会去找对应的配置文件 .env.xxx // 测试环境1 会读取对应配置文件 .env.T1 "build-T1": "vue-cli-service build --mode=T1", // 测试环境2 会读取对应配置文件 .env.T2 "build-T2": "vue-cli-service build --mode=T2", // 生产环境 会读取对应配置文件 .env.prod "build": "vue-cli-service build --mode=prod"&#125; 配置变量的使用 12345// 客户端代码中 或 vue.config.js 中// 仅支持注入环境配置文件中以 VUE_APP_ 开头的变量 客户端代码中使用时，都是字符串形式// VUE_APP_XXX = xxx 都会被webpack.DefinePlugin()设置为 process.env = &#123;VUE_APP_XXX: "xxx" ,...&#125;config.baseUrl = process.env.VUE_APP_baseUrlheaders.clientId = process.env.VUE_APP_clientId // process.env.VUE_APP_clientId =&gt; "93" 如果需要在客户端代码中根据打包环境区分某些配置或功能如vconsole 12345678910111213141516171819202122232425262728// 方法一// 可以在 .env.T1 .env.T2 .env.prod 配置文件中 加VUE_APP_MODE = T1或T2或pro// .env.T1 测试环境1配置VUE_APP_MODE = T1VUE_APP_baseUrl = 'http://22.11.33.44'// .env.T2 测试环境2配置VUE_APP_MODE = T2VUE_APP_baseUrl = 'http://22.55.33.99'// .env.prod 生产环境VUE_APP_MODE = proVUE_APP_baseUrl = 'http://xxx.cn'// 方法二 不在 .env.xxx 配置文件中写死 可以通过配置 DefinePlugin 注入 MODE// vue.config.jsmoudles.export = &#123; chainWebpack: config =&gt; &#123; config.plugin('define').tap(args =&gt; &#123; //args =&gt; [&#123;'process.env': &#123; NODE_ENV: 'developMent', VUE_APP_base_url: 'xx'&#125;&#125;] // 通过 process.env.npm_lifecycle_script 去获取 =&gt; vue-cli-service build --mode=T1 args[0]['process.env'].VUE_APP_MODE = JSON.stringify(process.env.npm_lifecycle_script.match(/--mode=(.+)(?=\s)/)[1]) return args &#125;) &#125;&#125;// 使用 main.js 仅在开发环境和测试环境引入vconsoleif (process.env.VUE_APP_MODE!=='pro') &#123; let vConsole = require('vconsole') // 使用require引入 可放在if里动态引入 new vConsole()&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript补漏]]></title>
    <url>%2Fjavascript%E8%A1%A5%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[JSON.stringify(obj) 特性 undefined、任意的函数以及symbol作为对象属性值时JSON.stringify()将跳过（忽略）对它们进行序列化 123456789const data = &#123; a: "aaa", b: undefined, c: Symbol("dd"), fn: function() &#123; return true; &#125;&#125;;JSON.stringify(data) // "&#123;"a":"aaa"&#125;" undefined、任意的函数以及symbol作为数组元素值时，JSON.stringify()将会将它们序列化为null 12JSON.stringify(["aaa", undefined, function aa() &#123;&#125;, Symbol('dd')])// "["aaa",null,null,null]" undefined、任意的函数以及symbol被JSON.stringify()作为单独的值进行序列化时，都会返回 undefined 123JSON.stringify(undefined) // undefinedJSON.stringify(function aa()&#123;&#125;) // undefinedJSON.stringify(Symbol('tew')) // undefined JSON.stringify() 将会正常序列化Date的值。 12JSON.stringify(&#123; now: new Date() &#125;)// "&#123;"now":"2018-11-10T17:42:11.973Z"&#125;" JSON.stringify() 会将NaN和Infinity格式的数值及null都会被当做null 123JSON.stringify(NaN) // "null"JSON.stringify(null) // "null"JSON.stringify(Infinity) // "null" JSON.stringify(obj, replacer, space) 各个参数使用 123456789101112131415161718192021222324252627282930313233343536373839404142/* replacer 为函数时 有两个参数 key value*/const data = &#123; a: "aaa", b: undefined, c: Symbol("tew"), fn: function() &#123; return true; &#125;&#125;JSON.stringify(data, (key, value) =&gt; &#123; switch (typeof value) &#123; case "undefined": return "undefined" case "symbol": return value.toString() case "function": return value.toString() default: return value &#125;&#125;)// "&#123;"a":"aaa","b":"undefined","c":"Symbol(tew)","fn":"function() &#123;\n return true;\n &#125;"&#125;"/* 作为数组时 可以过滤对象指定的属性名 */const jsonObj = &#123; name: "tew", age: 18, hobby: "travel,cheese"&#125;// 只保留 hobby 属性的值JSON.stringify(jsonObj, ["hobby"]); // "&#123;"hobby":"travel,cheese"&#125;"/* 第三个参数可以格式化输出格式 缩进的空格数 */const jsonObj = &#123; name: "tew", age: 18, hobby: "travel,cheese"&#125;;JSON.stringify(jsonObj,null,2);/* "&#123; "name": "tew", "age": 18, "hobby": "travel,cheese"&#125;" /* bind兼容123456789if (!-[1,]) &#123; Function.prototype.bind = function(oThis)&#123; var that = this var arg = [].slice.call(arguments,1) return function()&#123; that.apply(oThis,arg) &#125; &#125;&#125; 排序 随机排序 123456789var arr = [ &#123; "price": 66, "id": 1 &#125;, &#123; "price": 99, "id": 2 &#125;, &#123; "price": 11, "id": 4 &#125;, &#123; "price": 44, "id": 3 &#125;]arr.sort(function(a, b)&#123; return Math.random() - 0.5&#125;) 按指定字段排序 123456789function compare(property)&#123; return function(a,b)&#123; var value1 = a[property] var value2 = b[property] return value1 - value2 &#125;&#125;arr = arr.sort(compare('price'))console.log(arr) 日期截取123var date = '20190108180155'var reg = /(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)/date.replace(reg, '$1年$2月$3日 $4:$5:$6') 逻辑运算符与短路123456789/** &amp;&amp; || 逻辑与 &amp;&amp; 优先级高于 逻辑或 ||1. 在条件判断中 &amp;&amp; 所有条件都为真 整体才为整 || 只要有一个条件为真 整体就为真2. 在非条件判断中 如赋值操作中 || -&gt; A || B 首先看A的真假 A为真返回A的值 A为假 返回B的值(不管真假) 1 || 2 ==&gt; 1 0 || false ==&gt; false &amp;&amp; -&gt; A &amp;&amp; B 首先看A的真假 A为假返回A的值 A为真 返回B的值(不管真假) 1 &amp;&amp; 2 ==&gt; 2 0 &amp;&amp; false ==&gt; 0 Number.toFixed()如果该方法在一个非Number类型的对象上调用会报错。 判断一个对象是否为数组的最好方式1234function isArray(obj)&#123; return Object.prototype.toString.call(obj) == "[object Array]";&#125;// 不能使用 instanceof 和 constructor encodeURIComponent 与 encodeURI12345678910// encodeURIComponent和decodeURIComponent可以编码和解码URI特殊字符（如#，/，￥等）// encodeURI和decodeURI对URI的特殊字符是没有编码和解码能力的var codeVal = encodeURI('20180711#abc');var url = 'http://www.baidu.com?code=' + codeVal;console.log(url) // http://www.xxx.com?code=20180711#abcdecodeURI(location.search) //"?code=20180711"var codeVal = encodeURIComponent('20180711#abc');var url = 'http://www.baidu.com?code=' + codeVal;console.log(url) // "http://www.baidu.com?code=20180711%23abc"decodeURIComponent(location.search) //"?code=20180711#abc" Object.freeze 对象冻结Object.freeze()方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。123456789101112131415161718192021222324252627282930313233343536var obj = &#123; tew: 'view',&#125;obj.tew = 'app'console.log(Object.isFrozen(obj)) // falseconsole.log(obj.tew) // appObject.freeze(obj) // 冻结对象obj.tew = 'update'console.log(Object.isFrozen(obj)) // trueconsole.log(obj.tew) // app// 深度冻结function deepFreeze(obj)&#123; Object.freeze(obj) for(key in obj)&#123; if (typeof obj[key] === 'object' &amp;&amp; obj[key] != null) &#123; deepFreeze(obj[key]) &#125; &#125;&#125;var deepObj = &#123; age: '26', tew: &#123; age: '26' &#125;&#125;// Object.freeze(deepObj)// deepObj.age = '18'// deepObj.tew.age = '18'// console.log(deepObj.age) // 26// console.log(deepObj.tew.age) //18deepFreeze(deepObj)deepObj.age = '19'deepObj.tew.age = '19'console.log(deepObj.age) // 26console.log(deepObj.tew.age) // 26 MutationObserver 监听改变123456789101112&lt;div id="app"&gt;&lt;/div&gt;&lt;script&gt; let mutationObserver = new MutationObserver(() =&gt; &#123; console.log(app.children.length); &#125;) mutationObserver.observe(app, &#123; childList: true &#125;) for(let i=0;i&lt;10;i++)&#123; app.appendChild(document.createElement('p')) &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步解决方案之promise]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8Bpromise%2F</url>
    <content type="text"><![CDATA[Promise对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。 异步操作 Promise Promise是ES6新增的异步编程解决方案,它是一个对象,可以通过Promise构造函数来实例化 new Promise(cb) 基本语法 new Promise( function(resolve, reject) {…} )通过创建 Promise 对象开启一个异步操作的过程，一般用几步完成多次异步操作： new Promise(fn) 返回一个Promise 对象 在fn 中指定异步等处理 处理结果正常的话，调用resolve(处理结果值) 处理结果错误的话，调用reject(Error对象)Promise 内部是有状态的(pending、fulfilled、rejected)，Promise 对象根据状态来确定执行哪个方法。Promise 在实例化的时候状态是默认 pending 的，当异步操作是完成的(调用resolve)，状态会被修改为 fulfilled，如果异步操作遇到异常(调用reject)，状态会被修改为 rejected,状态转化是单向的，不可逆转，已经确定的状态（fulfilled/rejected）无法转回初始状态（pending），而且只能是从 pending 到 fulfilled 或者 rejected Promise.prototype.then()promise.then(onFulfilled, onRejected) 12345678910var promise = new Promise(function (resolve, reject) &#123; resolve('传递给then的值') &#125;)promise.then(function (value) &#123; console.log(value)&#125;, function (error) &#123; console.error(error)&#125;)// 创建一个 Promise 对象，定义了处理 onFulfilled 和 onRejected 的函数（handler），然后返回这个 Promise对象。// 这个 Promise 对象会在变为 resolve 或者 reject 的时候分别调用相应注册的回调函数。// 当 handler 返回一个正常值的时候，这个值会传递给 Promise 对象的 onFulfilled 方法。// 定义的 handler 中产生异常的时候，这个值则会传递给 Promise 对象的 onRejected 方法。 Promise.prototype.catch()使用 Promise 对象的 catch 方法来捕获异步操作过程中出现的任何异常。 12345678function test () &#123; return new Promise((resolve, reject) =&gt; &#123; reject(new Error('es')) &#125;)&#125;test().catch((e) =&gt; &#123; console.log(e.message) // es&#125;) Promise.resolve() 1234// Promise.resolve()是Promise静态方法 Promise.resolve(value)可以认为是以下代码的语法糖。new Promise(function (resolve) &#123; resolve(42) &#125;)// 方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。Promise.resolve(42).then(function (value) &#123; console.log(value) &#125;) Promise.reject() 1234// Promise.reject()是Promise静态方法 Promise.reject(error)可以认为是以下代码的语法糖。new Promise(function (resolve, reject) &#123; reject(new Error('出错了')) &#125;)// 这段代码的功能是调用该Promise 对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。Promise.reject(new Error('BOOM!')) Promise.all(promiseArray) 12345678910111213141516171819202122232425var p1 = Promise.resolve(1)var p2 = Promise.resolve(2)var p3 = Promise.resolve(3)Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results) // [1, 2, 3]&#125;)// Promise.all返回一个新的 Promise对象，参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回，新创建的 Promise 则会使用这些 promise 的值。// 如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象。// Promise.all并不是串行的 而是并行的 例如 数组中的每个请求都有延迟则promise.all()返回是延迟时间最长的大约是3s 而不是 6sconsole.time()const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 3000, 'pro1')&#125;)const promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 2000, 'pro2')&#125;)const promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, 'pro3')&#125;)Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123; console.timeEnd() console.log(values)&#125;)// 3001.1630859375ms// ["pro1", "pro2", "pro3"] Promise.race(promiseArray) 1234567891011121314151617181920212223var p1 = Promise.resolve(1)var p2 = Promise.resolve(2)var p3 = Promise.resolve(3)Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value) // 1&#125;)// Promise.race返回一个新的 Promise对象。参数 promise 数组中的任何一个 Promise 对象如果变为 resolve或者 reject 的话，该函数就会返回，并使用这个 Promis 对象的值进行 resolve 或者 reject。返回最早完成的promise对象console.time()const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 3000, 'pro1')&#125;)const promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 2000, 'pro2')&#125;)const promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, 'pro3')&#125;)Promise.race([promise1, promise2, promise3]).then((values) =&gt; &#123; console.timeEnd() console.log(values)&#125;)// 1000.848876953125ms// pro3 promise的链式调用 123456789101112131415161718192021const promise1 = new Promise((resolve, reject) =&gt; &#123; resolve('pro1')&#125;)const promise2 = new Promise((resolve, reject) =&gt; &#123; resolve('pro2')&#125;)const promise3 = new Promise((resolve, reject) =&gt; &#123; resolve('pro3')&#125;)promise1.then((res1) =&gt; &#123; console.log(res1, 'res1') return promise2&#125;).then((res2) =&gt; &#123; console.log(res2, 'res2') return promise3&#125;).then((res3) =&gt; &#123; console.log(res3, 'res3')&#125;)// pro1 res1// pro2 res2// pro3 res3]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础(三)]]></title>
    <url>%2Fes6%E5%9F%BA%E7%A1%80(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[ES6全称ECMAScript 6.0,部分浏览器不支持ES6，在应用程序的构建过程中需要使用babel将ES6转换为ES5. es6新特性：默认参数、箭头函数、模块化、Proxy、Generator构造器函数、Promise等 函数的扩展 默认参数 函数体内不能再使用let const声明形参 默认参数必须放在最后面 123456789101112131415function fn(a=10, b=20)&#123; console.log(a, b)&#125;fn() // 10 20fn(6) // 6 20fn(8, 9) // 8 9// 间隔传递默认参数可以使用 undefiend代替function f(x, y=7, z=43)&#123; return x + y + z&#125;console.log(f(1, undefined, 20)) // 28// 函数体内不能再使用`let const`声明形参function fn(a)&#123; let a = 3; // Identifier 'a' has already been declared&#125; 函数的Rest参数(…参数名) 剩余参数Spread Operator扩展运算符(…实参) 和 Rest Parameter(…形参) 是形似但相反意义的操作符，Rest Parameter 是把不定的参数“收敛”到数组，而 Spread Operator 是把固定的数组内容“打散”到对应的参数用于获取函数的多余参数,这样就不需要使用arguments对象了rest参数搭配的变量是一个数组,该变量会把多余的参数放入数组中.后边不能再有其他参数,否则会报错 12345678910111213141516171819202122232425function sum(...arr) &#123; console.log(arr) // [1, 2, 3, 4, 5] let res = 0 arr.map((item) =&gt; &#123; res+=item &#125;) console.log(res)&#125;sum(1, 2, 3, 4, 5) // 15function sum1(arg, ...arr) &#123; console.log(arr) // [2, 3, 4, 5] let res = arg arr.map((item) =&gt; &#123; res+=item &#125;) console.log(res)&#125;sum1(1, 2, 3, 4, 5) // 15// Spread Operator(扩展运算符)function sum5 (x = 1, y = 2, z = 3) &#123; return x + y + z&#125;console.log(sum5(...[4]))// 9console.log(sum5(...[4, 5]))// 12console.log(sum5(...[4, 5, 6]))// 15 箭头函数使用 =&gt; 定义函数 箭头左边是参数 右边是函数体 基本用法 只有一个参数和函数体只有return一条语句时可简写 123456// 只有一个参数时 () 可省略 只有一句return时 &#123;&#125; return也可省略const es6Fun = a =&gt; a// 等价于const es5Fun = function(a) &#123; return a &#125;console.log(es6Fun(1)) // 1console.log(es5Fun(1)) // 1 有多个参数时 用()将参数包起来 12const fun = (a,b) =&gt; a + bconsole.log(fun(1, 2)) // 3 函数体有多行代码时 要将多行代码用{}包起来 123456const fun = (a, b) =&gt; &#123; a = a*a b = b*b return a + b&#125;console.log(fun(2, 3)) // 13 当函数体只有一行return语句且返回的是字面量对象 ,要用()将返回值包起来 1234567891011const fun2 = (a, b) =&gt; (&#123;a,b&#125;)console.log(fun2(1, 2)) // &#123;a:1, b:2&#125;// es5 排序实例var arr = [5,1,3]arr.sort(function(a,b)&#123; return b - a&#125;)console.log(arr) // [5, 3, 1]// es6 箭头函数 排序实例arr.sort((a, b) =&gt; a - b)console.log(arr) // [1, 3, 5] 箭头函数使用注意事项 箭头函数不能用作Generator生成器函数 函数体内没有自己的this对象,内部this对象是定义时上下文(作用域)的this对象, 不是调用时的this对象. 不能改箭头函数使用 call apply bind去更改其内部的this指向.箭头函数中的this只取决包裹箭头函数的第一个普通函数的this 123456789function fn()&#123; console.log(this) return () =&gt; &#123; console.log(this) // 定义时作用域 &#125;&#125;// fn()() // Window windowfn().call(&#123;a:2&#125;) // Window window 无法使用 call 改变箭头函数this对象// fn.call(&#123;a:1&#125;)() // &#123;a: 1&#125; &#123;a: 1&#125; 箭头函数体内没有arguments对象,可以用rest参数代替 12345678let fun3 = (...rest) =&gt;&#123; console.log(rest)&#125;fun3(1,2) // [1, 2]let fun4 = () =&gt; &#123; console.log(arguments)&#125;fun4(1,2) // arguments is not defined 箭头函数不可以当做构造函数,不可以使用new命令,否则会报错 12const Fun = (a, b) =&gt; a + bnew Fun(1,2) // Fun is not a constructor 模块化 es6中每一个模块就是一个文件，希望外部可以读取模块中的内容，就必须使用export将其暴露出去(导出)， 子其他模块使用import导入 12345// a.jsexport const name = 'tew'// b.jsimport &#123; name &#125; from './a.js'console.log(name) // tew 如果要导出多个变量可以将这些变量包装成对象进行模块化导出 123456789// a.jslet name = 'tew'let age = 18let fn = (name) =&gt; `My name is $&#123;name&#125;`export &#123; name, age, fn &#125;// b.jsimport &#123; name, age, fn &#125; from './a.js'console.log(fn('Bob')) // My name is Bobconsole.log(age) // 18 使用as对导出变量或导入变量进行重命名 123456789101112// a.jslet name = 'tew'let age = 18let fn = (name) =&gt; `My name is $&#123;name&#125;`export &#123; name as myName, age, fn as myFn &#125;// b.jsimport &#123; myName as name, age, myFn as fn &#125; from './a.js'console.log(name) // tewconsole.log(fn('Bob')) // My name is Bob// 直接导入整个模块// import * as info from './a.js'// console.log(info.name) // tew 默认导出 一个模块只能有一个export default默认导出 12345export default function()&#123; return '默认导出'&#125;import fn from './a.js'console.log(fn()) // 默认导出 混合导出 同时有export和export default 123456789// a.jsexport default function()&#123; return '默认导出'&#125;export let name = 'tew'// b.jsimport fn, &#123;name&#125; from './a.js'console.log(fn()) // 默认导出console.log(name) // tew ProxyGenerator构造器函数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础(二)]]></title>
    <url>%2Fes6%E5%9F%BA%E7%A1%80(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[ES6全称ECMAScript 6.0,是JavaScript的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念。es6新特性：Symbol、class、数值的扩展、字符串的扩展、数组的扩展、对象的扩展等 Symbol数据类型 Symbol表示独一无二的值,它是js中的第七种数据类型. 基本的数据类型: null undefined number boolean string symbol bigInt 引用数据类型 object1234567let s1 = Symbol('tew')let s2 = Symbol('tew')console.log(s1) // Symbol(tew)console.log(s2) // Symbol(tew)console.log(typeof s1) // symbolconsole.log(s1==s2) // falseconsole.log(s1===s2) // false Symbol使用注意事项 Symbol函数不能使用new否则会报错, 它是原始数据类型不是对象 1let s3 = new Symbol('tew') // Symbol is not a constructor Symbol函数接收一个字符串作为参数,表示对Symbol的描述和区分,主要是为了在控制台显示,或者转为字符串的时候,比较容易区分. 字符串只是描述,不代表其他. Symbol不能隐式转换，但可以显示转换为字符串或者布尔值,转换为Number的话会报错。 1234console.log(String(Symbol('tew'))) // Symbol(tew) stringconsole.log(Symbol('tew').toString()) // Symbol(tew) stringconsole.log(!Symbol('tew')) // falseconsole.log(Number(Symbol('tew'))) // Cannot convert a Symbol value to a number Symbol不能与其他值做任何运算,会报错 1console.log(Symbol('tew')+'1') // Cannot convert a Symbol value to a string Symbol作为对象的属性名使用时,属性不会出现在for in/of中,也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回, 12345678910let yyy = Symbol('ss')// 不能写成 &#123;yyy: 'hello'&#125; 需要加 []const obj = &#123;[yyy]: 'hello', a:2&#125;console.log(obj) // &#123;a: 2, Symbol(ss): "hello"&#125;console.log(obj[yyy]) // hellofor (const i in obj) &#123; console.log(i) // a 未出现 Symbol(ss): "hello"&#125;console.log(Object.keys(obj)) // ["a"]console.log(JSON.stringify(obj)) // &#123;"a":2&#125; 在直接使用symbol作为属性名的时候,只能使用通过obj[Object.getOwnPropertySymbols(obj)[0]] 123456789const obj = &#123; [Symbol()]: 123, a: 22&#125;console.log(obj) // &#123;a: 22, Symbol(): 123&#125;console.log(obj[Symbol()]) // undefinedconsole.log(Object.getOwnPropertySymbols(obj)) // [Symbol()]console.log(Object.getOwnPropertySymbols(obj)[0]) // Symbol()console.log(obj[Object.getOwnPropertySymbols(obj)[0]]) // 123 Class类传统方法是通过构造函数,定义并生成新对象,是一种基于原型的面向对象系统Es6中可以使用class声明一个类,之后以这个类来实例化对象 es5传统方式 1234567891011const Tew = function(a, b) &#123; this.a = a this.b = b&#125;Tew.prototype = &#123; constructor: Tew, print: function()&#123; console.log(this.a + ' ' + this.b) &#125;&#125;const tew = new Tew('hello', 'world').print() // hello world es6方式 12345678910class Tew&#123; constructor(a,b)&#123; this.a = a this.b = b &#125; print()&#123; console.log(this.a +' ' + this.b) &#125;&#125;new Tew('hello', 'world').print() // hello world class使用注意事项 Tew中的constructor方法是构造函数,this关键字则代表实例对象,也就是说,es5中的构造函数Tew,对应Es6的Tew这个类的构造方法,主要用于初始化对象的属性 定义类的方法的时候,前面不需要加上function关键字,方法之间不需要逗号分隔,加了会报错 构造函数的prototype属性,在es6的类上继续存在,而且类的所有方法都定义在类的prototype属性上面 定义在类中的方法都是不可以被枚举的 constructor方法是类的默认方法.通过new命令生成对象实例时,自动调用该方法.一个类必须有constructor方法,如没有显示定义,会默认添加一个空的contructor方法 用new实例化对象,如忘记使用new,将会报错 es6 class类的继承 123456789101112131415161718192021class Humen&#123; constructor()&#123; this.eyes = 2 this.hands = 2 &#125; say()&#123; console.log('I can say') &#125;&#125;let humen = new Humen()console.log(humen) // Humen &#123;eyes: 2, hands: 2&#125;humen.say() // I can sayclass Women extends Humen&#123; say()&#123; console.log('Women say') &#125;&#125;let women = new Women()console.log(women) // Women &#123;eyes: 2, hands: 2&#125;women.say() // Women say 子类继承父类使用extends关键字,为父类指定静态方法,使用static方法名 构造函数或方法是在类被实例化以后立刻调用的,可以用来传参 super 在构造函数中可以当一个函数来使用,相当于调用父类的构造函数 super.父类方法 调用父类的方法 super 在原型方法中,可以当一个对象来使用,相当于父类的原型对象,并且会自动绑定this到子类上1234567891011121314151617181920212223242526272829303132class Humen&#123; constructor()&#123; this.eyes = 2 this.hands = 2 &#125; say()&#123; console.log('I can say') &#125;&#125;class Thief extends Humen&#123; constructor()&#123; super() // 子类继承父类必须调用父类的构造函数 必须放在第一句 // 子类可以增加或修改父类的属性 this.hands = 3 this.face = 1 &#125; // 重写父类的方法 say()&#123; super.say() // 调用父类的方法 console.log('Thief say') &#125; // 子类扩展的方法 run()&#123; console.log('Thief run') &#125;&#125;let thief = new Thief()console.log(thief) // Thief &#123;eyes: 2, hands: 3, face: 1&#125;console.log(thief.hands) // 3console.log(thief.face) // 1thief.say() // Thief saythief.run() // Thief run 静态方法 es5中类的方法是静态方法 123456789101112131415161718192021222324252627// es5 静态方法只能通过 类名.静态方法名() 调用，不能使用对象实例调用function Animal(type)&#123; this.type = type this.walk = function()&#123; console.log('对象实例的方法') &#125;&#125;Animal.eat = function() &#123; console.log('定义在类上的静态方法') &#125;var dog = new Animal('dog')dog.walk() // 对象实例的方法Animal.eat() // 定义在类上的静态方法 只能通过类去调用dog.eat() // dog.eat is not a function//es6 静态方法只能通过 类名.静态方法名() 调用，不能使用对象实例调用class People &#123; constructor()&#123; this.name = name &#125; walk ()&#123; console.log('普通方法') &#125; static eat ()&#123; console.log('静态方法') &#125;&#125;let people = new People('tew')people.walk() // 普通方法People.eat() // 静态方法people.eat() // people.eat is not a function 数值的扩展 Math.trunc(num) 干掉小数点,返回整数部分。 Math.sign(num) 判断参数是正数,负数,正0还是负0,是正数时返回1 ,是负数时返回-1,0的时候返回0,-0的时候返回-0,NaN,对于非数值，会先将其转换为数值。 Math.hypot(3,4) 返回参数的平方和(勾股定理) Math.cbrt(8) 返回参数的立方根 Number.isInteger(num) 判断是否是整数 数值3.0和3.00都会被认为是整数。 Number.isNaN(num) 用来检查一个值是否为NaN1234567891011console.log(Math.trunc(1.634)) // 1console.log(Math.sign(5)) // 1console.log(Math.sign(-5)) // -1console.log(Math.sign(0)) // 0console.log(Math.sign(-0)) // -0console.log(Math.sign(NaN)) //NaNconsole.log(Math.sign(null)) // 0console.log(Math.hypot(3,4)) // 5console.log(Math.cbrt(8)) // 2console.log(Number.isInteger(3.0)) // trueconsole.log(Number.isInteger(3.1)) // false 字符串的扩展 模板字符串 在模板字符串中使用 ${&#39;字符串&#39;|&#39;运算符&#39;|变量} ${表达式} 插值 1234567let flag = true, text = '模板字符串'let html = ` &lt;ul&gt; &lt;li&gt;$&#123;text.slice(0,2)&#125;&lt;/li&gt; &lt;li class="$&#123;flag?'show':'hide'&#125;"&gt;$&#123;text&#125;&lt;/li&gt; &lt;/ul&gt;`console.log(html)//&lt;ul&gt;&lt;li&gt;模板&lt;/li&gt;&lt;li class="show"&gt;模板字符串&lt;/li&gt;&lt;/ul&gt; str.repeat(n) 重复n个相同的字符串 str.includes(&#39;a&#39;) 字符串中是否包含某字符 str.startsWith(&#39;a&#39;) 字符串是否已某字符开头 str.endsWith(&#39;a&#39;) 字符串是否已某字符结尾 123456789let str = 'abca'console.log(str.repeat(2)) // abcaabcaconsole.log(str) // abcaconsole.log(str.includes('a')) // trueconsole.log(str.includes('d')) // falseconsole.log(str.startsWith('a')) // trueconsole.log(str.startsWith('b')) // falseconsole.log(str.endsWith('a')) // trueconsole.log(str.endsWith('b')) // false str.padStart(2,&#39;0&#39;) 向前填充字符 str.padEnd(2,&#39;0&#39;) 向后填充字符1234567console.log('1'.padStart(2, '0')) // 01console.log('01'.padStart(2, '0')) // 01console.log('1'.padEnd(2, '0')) // 10console.log('10'.padEnd(2, '0')) // 10let date = new Date()console.log(date.getHours().toString().padStart(2, '0') + '时') // 09时console.log(date.getMinutes().toString().padStart(2, '0') + '分') // 08分 数组的扩展 Array.from() 将类数组转化成数组如NodeList arguments string等 1234let lis = document.querySelectorAll('li');console.log(Array.isArray(lis)) // falselet lis2 = Array.from(lis)console.log(Array.isArray(lis2)) // true Array.of(e1,e2,…) 按顺序创建包含每个参数的数组,不考虑参数的数量和数据类型 123456789// Array.of()和Array()区别在于处理整数参数// Array(n) n个长度的undefiend数组// Array.of(n) 一个长度的数组 [n]console.log(Array.of(1, 'a', &#123;&#125;, [], true)) // [1, "a", &#123;…&#125;, Array(0), true]console.log(Array(1, 'a', &#123;&#125;, [], true)) // [1, "a", &#123;…&#125;, Array(0), true]console.log(Array.of(7)) // [7]console.log(Array(7)) // (7) [empty × 7]console.log(Array(7).length) // 7console.log(Array(7)[1]) // undefined arr.find() 返回数组中满足函数的第一个元素的值,否则返回undefined arr.findIndex() 返回数组中满足函数的第一个元素的索引,否则返回-1 123456789const arr = [1, '2', '3', true]let resFind = arr.find((item)=&gt;&#123; return item &gt; 1&#125;)let resFindIndex = arr.findIndex((item)=&gt;&#123; return item &gt; 1&#125;)console.log(resFind) // '2'console.log(resFindIndex) // 1 arr.fill() 用固定值填充数组中从指定起始索引到指定终止索引内的全部元素,不包括终止索引。(会改变原数组) 1234const arr = [1, '2', true]// console.log(arr.fill('a')) // ["a", "a", "a"]// console.log(arr.fill('a', 1)) // [1, "a", "a"]console.log(arr.fill('a', 1, 2)) // [1, "a", true] arr.includes() 检测数组是否包含某元素,可判断NaN 1234let arr = [1, NaN, 'a']console.log(arr.includes(1)) // trueconsole.log(arr.includes(NaN)) // trueconsole.log(arr.includes('b')) // false 扩展运算符(spread)… 将类数组转为用逗号分隔的参数序列 123456var arr = [1,4,7,3,2,11]var str = 'tew'console.log(...arr) // 1 4 7 3 2 11console.log(...str) // t e wconsole.log(Math.max.apply(null,arr)) // 11console.log(Math.max(...arr)) // 11 用于取出参数对象的所有可遍历属性,拷贝到当前对象之中(浅拷贝) 123456789// 展开一个对象let obj = &#123;a:1, b:2&#125;let obj1 = &#123; c:'children', name:'tew', ...obj&#125;console.log(&#123;...obj&#125;) // &#123;a: 1, b: 2&#125; 可以浅拷贝对象console.log(obj1) //&#123;c: "children", name: "tew", a: 1, b: 2&#125; 对象的扩展 对象属性名和属性值相同时可简写, 属性可以是表达式,对象的方法简写可省略:function 1234567891011let a = 1let b = 'c'const obj = &#123; a, // 属性名和值相同时可简写 [b+a]: '3', // 属性可以使表达式 say () &#123; // 对象方法简写 console.log(this.a + '--' + this[b+a]) &#125;&#125;console.log(obj) // &#123;a: 1, c1: "3", say: ƒ&#125;obj.say() // 1--3 Object.is(a,a) 比较两个值是否相等 多数情况下Object.is等价于”===” 可以判断NaN，但-0和0不相等 1234567console.log(Object.is(1,1)) // trueconsole.log(Object.is(null,null)) // trueconsole.log(Object.is(undefined,undefined)) // trueconsole.log(NaN === NaN) // fasleconsole.log(Object.is(NaN,NaN)) // trueconsole.log(Object.is(0,-0)) // falseconsole.log(Object.is(+0,-0)) // false Object.keys() 返回一个数组，数组中每一项是对象中可被遍历的键名 Object.values() 返回一个数组，数组中每一项是对象中可被遍历的键值 Object.entries() 返回一个数组，数组中每一项是对象中可被遍历的键值对数组 Object.getOwnPropertyNames() 返回一个数组，由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成。 Object.getOwnPropertyDescriptors(obj) 返回对象所有属性的描述对象 Object.getOwnPropertyDescriptor(obj, &#39;a&#39;) 返回指定属性的描述对象 Object.getOwnPropertySymbols(obj) 方法返回一个给定对象自身的所有Symbol属性的数组。 123456789101112131415161718192021222324252627282930let a = 1let b = 'c'const obj = &#123; a, // 属性名和值相同时可简写 [b+a]: '3', // 属性可以使表达式 say () &#123; // 对象方法简写 console.log(this.a + '--' + this[b+a]) &#125;, [Symbol('tew')]:'hello'&#125;console.log(obj) // &#123;a: 1, c1: "3", Symbol(tew): "hello", say: ƒ&#125;console.log(Object.keys(obj)) // ["a", "c", "say"]Object.defineProperty(obj, 'a', &#123; enumerable: false //是否可枚举 默认值为true&#125;)console.log(Object.keys(obj)) // ["c", "say"]console.log(Object.getOwnPropertyNames(obj)) // ["a", "c", "say"]console.log(Object.values(obj)) // ["3", ƒ]console.log(Object.entries(obj)) //[["c", "3"],["say", ƒ]]console.log(Object.getOwnPropertyDescriptors(obj))/* &#123; a: &#123;value: 1, writable: true, enumerable: false, configurable: true&#125; c1: &#123;value: "3", writable: true, enumerable: true, configurable: true&#125; say: &#123;writable: true, enumerable: true, configurable: true, value: ƒ&#125; Symbol(tew): &#123;value: "hello", writable: true, enumerable: true, configurable: true&#125;&#125; */console.log(Object.getOwnPropertyDescriptor(obj, 'a'))//&#123;value: 1, writable: true, enumerable: false, configurable: true&#125;console.log(Object.getOwnPropertySymbols(obj)) //[Symbol(tew)] Object.assign(target,[obj1]) 用于对象的合并,将源对象的所有可枚举属性,复制到目标对象target中,如果目标对象与源对象有同名属性,或多个源对象有同名属性,则后面的属性会覆盖前面的属性.String类型和 Symbol类型的属性都会被拷贝 只拷贝源对象的自身属性(不拷贝继承属性),也不拷贝不可枚举的属性(enumerable: false) 是浅拷贝而不是深拷贝 123456789101112131415let a = 1let obj = &#123; a, [Symbol('tew')]:'hello', say () &#123; console.log(this.a + '--' + this[b]) &#125;&#125;console.log(Object.assign(&#123;a:3&#125;, obj)) // &#123;a: 1, Symbol(tew): "hello", say: ƒ&#125;// 如果只有一个参数,会直接返回该参数,不是对象则会先转成对象.// 如果一个参数是null或undefiend无法转成对象则会报错console.log(Object.assign(obj)) // &#123;a: 1, Symbol(tew): "hello", say: ƒ&#125;console.log(Object.assign(2)) // Number &#123;2&#125;console.log(Object.assign(null)) // Cannot convert undefined or null to object// console.log(Object.assign(undefined)) //Cannot convert undefined or null to object Object.defineProperty() 添加/修改属性 或 自定义Setters和Getters(Vue2双向绑定原理就是基于此) 123456789101112131415161718192021222324252627282930313233/* 添加/修改属性 */obj2 = &#123;x: 1&#125;Object.defineProperty(obj2, 'y', &#123; //描述或设置了该属性的细节 value: 100, // 设置的值 writable: true, //是否可被改写 默认值为true enumerable: true, //是否可枚举 默认值为true configurable: true //是否可被删除 默认值为true&#125;)console.log(obj2) // &#123;x: 1, y: 100&#125;obj2.y = 200 // 改写for (const key in obj2) &#123; //枚举属性 console.log(key + '--' + obj2[key]) // x--1 y--200&#125;delete obj2.y // 可删除console.log(obj2) // &#123;x: 1&#125;/* 自定义 Setters 和 Getters 实现简单的双向绑定 *///&lt;input type="text" id="model"&gt;&lt;br/&gt;//&lt;div id="modelText"&gt;&lt;/div&gt;let user = &#123;&#125;modelText.textContent = model.value = '默认值'Object.defineProperty(user,"name",&#123; // 监听name属性改变 get:function()&#123; return defaultName &#125;, set:function(newValue)&#123; modelText.textContent = newValue &#125;&#125;)model.addEventListener("keyup", function () &#123; user.name = this.value&#125;, false) 正则的扩展 y修饰符 u修饰符]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础(一)]]></title>
    <url>%2Fes6%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0简称(es6) 是继ECMAScript 5之后的javascript语言的下一代标准,它的目标是使得javascript语言可以用来编写复杂的大型应用程序。es6新特性：let、const、解构赋值、Set、Map、Iterrator接口等 Let 使用let声明的变量,所声明的变量只在命令所在的代码块有效. for if 等形成块级作用域 为什么需要块级作用域 内层变量会覆盖外层变量 用来计数的循环变量泄漏为全局变量 使用let命令声明的变量在预解析的时候不会被提升 let声明的变量不允许未定义就使用 暂时性死区 只要块级作用域内存在let命令,它所声明的变量就绑定在这个区域内,不再受外部的影响. 当前作用域在执行之前，浏览器会做语法检测，如果语法检测不通过会直接报错，整个代码不执行console.log(typeof a) //暂时性死区 let不允许在同一个作用域下声明已经存在的变量 不能在函数内部重新声明参数var 声明的变量由函数来划分作用域let 声明的变量由代码块来划分作用域 一对{ } 包括的区域被称为代码块12345678910111213141516171819202122232425262728293031323334353637383940/*&lt;div&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt;&lt;/div&gt;*/// 给多个button添加点击事件，并弹出对应的索引值var btns = document.querySelectorAll('button')/* 问题代码for(var i=0;i&lt;btns.length;i++)&#123; btns[i].onclick = function() &#123; console.log(i) // 6 6 6 6 &#125;&#125;*/// 方法1 使用letfor(let i=0;i&lt;btns.length;i++)&#123; btns[i].onclick = function() &#123; console.log(i) // 1 2 3 4 &#125;&#125;// 方法二 自定义属性存索引for(var i=0;i&lt;btns.length;i++)&#123; btns[i].index = i btns[i].onclick = function() &#123; console.log(this.index) // 1 2 3 4 &#125;&#125;// 方法三 闭包for(let i=0;i&lt;btns.length;i++)&#123; // 遍历过程 仅将事件处理函数赋值给按钮的onclick属性 不调用函数 (function(i))&#123; // 形参相当于局部变量 var i btns[i].onclick = function() &#123; // 每调用一次 就创建一个函数 并将本次传入的i值放在局部变量 被永久保存起来 console.log(i) // 1 2 3 4 &#125; &#125;)(i)&#125; ConstConst命令同样有上面let的1,2,3条特点,第一:所声明的常量只在其所在的代码块内有效,第二声明的常量不会被提升,第三不能声明已经被声明过得常量,除了这些,在使用const声明常量的时候需要注意的两点. 声明的时候必须赋值 否咋报错 12const C// Uncaught SyntaxError: Missing initializer in const declaration 声明的常量储存简单的数据类型不可改变其值,如果存储的是对象,那么引用不可以被改变,对象的属性是可以被修改 12345678const C = 1; C = 2// Uncaught SyntaxError: Assignment to constant variable.const obj = &#123; a: 10&#125;obj.a = 20console.log(obj) // &#123;a: 20&#125;obj = &#123;a: 30&#125;// Uncaught TypeError: Assignment to constant variable 声明不可更改的常量对象 12345const arr1 = Object.freeze([1, 2, 3])console.log(Object.isFrozen(arr1)) // truearr1[0] = 4console.log(arr1) // [1, 2, 3]arr1.push(4) // Uncaught TypeError: Cannot add property 3, object is not extensible 顶层对象window的属性Es6为了保持兼容性,var命令和function命令声明的全局变量,依旧是顶层对象的属性.另一方面规定,let命令,const命令,class命令声明的全局变量,不属于顶层对象的属性.12345678910var a = 1console.log(window.a) // 1function fn()&#123;&#125;console.log(window.fn) // fn()&#123;&#125;let b = 2console.log(window.b) // undefinedconst c = 3console.log(window.c) // undefinedclass Person &#123;&#125;console.log(window.Person) // undefined 解构赋值 解构赋值: 按照一定的模式从数组和对象中提取值,并对变量进行赋值,解构不成功,变量的值都会是undefined. 只要等号两边的模式相同.左边的变量就可以被赋予对象的值 基本类型的解构赋值null和undefined 不能进行解构 123456789// 字符串的解构let [a,b,c] = '123'console.log(a,b,c) // 1 2 3// length属性的解构let &#123;length: len&#125; = 'tew'console.log(len) // 3// null和undefined 不能进行解构let [n] = undefined // Uncaught TypeError: undefined is not iterablelet [m] = null // Uncaught TypeError: null is not iterable 数组的解构赋值 1234let [a,b,c] = [1,'test', false]console.log(a,b,c) // 1 "test" falselet [x, [[y],z]] = [1,[[['a', 'b']], false]]console.log(x, y, z) // 1 ["a", "b"] false 对象的解构赋值允许你为对象的不同属性绑定变量名,左侧类似一个对象字面量,对象中是一个名值对的列表,冒号左侧是属性名称,右侧是变量名称,每个属性都会去右侧对象中查找相应的值,每一个值都会赋值给它对应的变量.先找到同名的属性,然后赋值给变量,真正赋值的是变量,而不是属性 123let &#123;a:b&#125; = &#123;a:1&#125;console.log(b) // 1console.log(a) // Uncaught ReferenceError: a is not defined 属性名和变量名相同可简写 12let &#123;a, b&#125; = &#123;b: 'bbb', a: 'aaa'&#125;console.log(a,b) // aaa bbb 对象解构赋值的默认值 默认值生效的条件是属性值严格等于undefined 1234567891011let &#123;x,y=5&#125; = &#123;x:1&#125;console.log(x, y) // 1 5let &#123;msg='tew'&#125; = &#123;msg: 'default'&#125;console.log(msg) // default// 只有属性值是 === undefined 才会采用默认值let &#123;a = 3&#125; = &#123;a: undefined&#125;let &#123;b = 3&#125; = &#123;b: 'undefined'&#125;let &#123;c = 3&#125; = &#123;c: null&#125;let &#123;d = 3&#125; = &#123;d: false&#125;console.log(a,b, c,d) // 3 'undefined' null false 选择性解构赋值,用逗号可省略隔开 12let [,,c] = [1,2,3]console.log(c) // 3 将右侧多余的值以数组形式赋值给左边的变量–rest模式 12let [head, ...tail] = [1,2,3]console.log(head, tail) // 1 [2, 3] 起别名 原名称:别名 只能用别名来访问 123let &#123;name, a:num&#125; = &#123;'name':'tew', a: 9&#125;console.log(name, num) // tew 9console.log(a) // a is not defined 函数参数的解构赋值 12345678910111213141516171819202122function fn2(a=1,b=2)&#123; console.log(a,b)&#125;fn2() // 1 2fn2(&#123;b:9&#125;) // &#123;b:9&#125; 2// 函数参数解构赋值 默认值// 函数在未传值时才会使用默认值function fn(&#123;a=1,b=2&#125; = &#123;&#125;)&#123; // 解构赋值 &#123;a=1, b=2&#125; = 传过来的实参 (默认&#123;&#125;) console.log(a,b)&#125;fn() // 1 2fn(&#123;b:5&#125;) // 1 5// 函数在未传值时才会使用默认值function fn1(&#123;a, b&#125; = &#123;a:3, b:4&#125;)&#123; // 解构赋值 &#123;a=1, b=2&#125; = 传过来的实参(默认&#123;a:3, b:4&#125;) console.log(a,b)&#125;fn1() // 3 4fn1(&#123;a:5&#125;) // 5 undefinedfn1(&#123;a:10, b:20&#125;) // 10 20fn1(&#123;&#125;) // undefined undefined 解构赋值的用途 1234567891011121314151617181920212223242526272829/* 1. 交换变量 */let x = 100, y = 200console.log('交换前', x, y); // 交换前 100 200[x, y] = [y, x] //表达式前语句必须有;分号console.log('交换后', x, y) // 交换后 200 100/* 2. 从函数返回多个值(数组或对象) */function fun1()&#123; return &#123; id:10001, name: 'tew' &#125;&#125;let &#123;id, name&#125; = fun1()console.log(id, name)/* 3. 当函数参数顺序不确定时 */function fn(&#123;id, name&#125;)&#123; console.log(id, name)&#125;fn(&#123;name: 'tew', id: '002'&#125;) // 002 tew/* 4. 提取json数据 例如axios返回的数据 */// let &#123;status, data&#125; = this.$axios.post('xx')let data = &#123; id: '003', nick: 'bob', score: &#123; math: 95, chinese: 90 &#125;&#125;let &#123; id:num, nick, score: &#123; math &#125; &#125; = dataconsole.log(num, nick, math) // 003 bob 95 数据结构 Set Set是由一组无序且唯一(既不能重复)的项组成 ,key和value相同,没有重复的value 创建set 可以接受数组或类数组作为参数,用来初始化 12345// 创建 Setvar a = new Set([1,2,3])console.log(a) // Set(3) &#123;1, 2, 3&#125;// Set的属性 a.sizeconsole.log(a.size) // 3 set.add(value) 添加数据 返回值为set结构本身 12a.add('a').add('b')console.log(a) // Set(5) &#123;1, 2, 3, "a", "b"&#125; set.delete(value) 删除指定的数据,返回布尔值,表示删除是否成功 123console.log(a.delete('a')) // trueconsole.log(a) // Set(4) &#123;1, 2, 3, "b"&#125;console.log(a.delete('a')) // false set.has(value) 判断该值是否为set成员,返回一个布尔值 12console.log(a.has('b')) // trueconsole.log(a.has('a')) // false set.keys() 返回所有键名 set.values() 返回所有键名 set.entries() 返回所有键值对 123console.log(a.keys()) // SetIterator &#123;1, 2, 3, "b"&#125;console.log(a.values()) // SetIterator &#123;1, 2, 3, "b"&#125;console.log(a.entries()) // SetIterator &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3, "b" =&gt; "b"&#125; set.forEach(function(value,key,set){}) 遍历 1234a.forEach(function(value, key, set)&#123; console.log(key+'--'+value) // 1--1 2--2 3--3 b--b console.log(set) // SetIterator &#123;1, 2, 3, "b"&#125;&#125;) set.clear() 清除所有数据,无返回值 12a.clear()console.log(a) // Set(0) &#123;&#125; set 应用场景（去重、交集、并集、差集） 12345678910111213// 数组去重const arr = [1, 'a', true, 'a', true]console.log([...new Set(arr)]) // [1, "a", true]let arr1 = [4, 6, 8, 2, 1]let arr2 = [3, 6, 8, 7, 1]// 合并并去重Array.from(new Set([...arr1, ...arr2]))) //[4, 6, 8, 2, 1, 3, 7]// 交集Array.from(new Set([...arr1])).filter(item =&gt; arr2.includes(item)) // [6, 8, 1][...new Set([...arr1])].filter(item =&gt; new Set(arr2).has(item)) // [6, 8, 1]// 差集Array.from(new Set([...arr1])).filter(item =&gt; !arr2.includes(item)) // [4, 2][...new Set([...arr1])].filter(item =&gt; !new Set(arr2).has(item)) // [4, 2] 数据结构 Map Map类似于对象,也是键值对的集合,但是’键’不限于字符串.各种数据的值(包括对象)都可以当成键,也就是说,Object结构提供了’字符串–值’的对应,Map提供了’值–值’的对应. 创建map数据结构 1234567var map = new Map([ ['a', 1], ['b', 2]])console.log(map) // Map(2) &#123;"a" =&gt; 1, "b" =&gt; 2&#125;// Map的属性sizeconsole.log(map.size) // 2 map.set(key,value) 设置值,返回整个map结构,如果可以已经有值,则键值会被更新,否则新生成该键. 12map.set('name', 'tew').set('id', 001)console.log(map) // &#123;"a" =&gt; 1, "b" =&gt; 2, "name" =&gt; "tew", "id" =&gt; 1&#125; map.get(key) get方法读取key对应的键值,如果找不到key,返回undefined 12console.log(map.get('name')) // tewconsole.log(map.get('age')) // undefined .map.delate(key) 删除某个键,返回布尔值true成功,false失败 123console.log(map.delete('id')) // trueconsole.log(map.delete('age')) // falseconsole.log(map) // Map(3) &#123;"a" =&gt; 1, "b" =&gt; 2, "name" =&gt; "tew"&#125; map.has(key) 判断某个键是否在当前map对象之中 12console.log(map.has('name')) // trueconsole.log(map.has('age')) // false map.keys() 返回所有的键名 map.values() 返回所有的键值 map.entries() 返回所有键值对 123console.log(map.keys()) // MapIterator &#123;"a", "b", "name"&#125;console.log(map.values()) // MapIterator &#123;1, 2, "tew"&#125;console.log(map.entries()) // MapIterator &#123;"a" =&gt; 1, "b" =&gt; 2, "name" =&gt; "tew"&#125; map.forEach(value, key, map) 遍历map每个成员 1234map.forEach(function(value, key, map)&#123; console.log(key+'--'+value) // a--1 b--2 name--tew console.log(map) // Map(3) &#123;"a" =&gt; 1, "b" =&gt; 2, "name" =&gt; "tew"&#125;&#125;) map.clear() 清除所有数据,没有返回值 12map.clear()console.log(map) // Map(0) &#123;&#125; map的键是基本数据类型时,只要两个值严格相等,map将其视为一个键,但NaN不严格相等与自身,但map将其视为同一个键 1map.set(NaN, 10).set(NaN, 20) // Map(1) &#123;NaN =&gt; 20&#125; map的键是对象的时候,比较的是引用(内存地址),只有引用地址一样才可以 123map.set(&#123;&#125;, '对象').set(&#123;&#125;, '对象')console.log(map) // Map(3) &#123;&#123;…&#125; =&gt; "对象", &#123;…&#125; =&gt; "对象"&#125;console.log(map.get(&#123;&#125;)) // undefined Iterrator和for-of循环 Iterator(迭代器)是一种接口,为不同的数据结构,提供统一的访问机制,任何数据结构只要部署Iterator接口,就可以完成遍历操作,而且这种遍历操作是依次处理数据结构的所有成员 12345678910111213const arr = [1, 2]function iterrator()&#123; let index = 0; return &#123; next: function()&#123; return index&lt;arr.length ? &#123; value: arr[index++], done:false &#125;:&#123; value: undefined, done:true &#125; &#125; &#125;&#125;const it = iterrator(arr)console.log(it.next()) // &#123;value: 1, done: false&#125;console.log(it.next()) // &#123;value: 2, done: false&#125;console.log(it.next()) // &#123;value: undefined, done: true&#125; Iterator遍历(使用for of) 为各种数据结构,提供统一简便的访问接口使成员能够按某种次序排列 Iterator的遍历过程 创建一个指针对象,指向当前数据结构的起始位置,遍历器对象本质就是指针对象 每一次调用next方法都会返回当前指针所对应的成员的信息,返回一个包含value和done两个属性的对象,其中,value属性就是当前成员的值,done属性是不布尔值,表示遍历是否结束. 凡是具有Symbol.iterator 属性的数据结构都具有Iterator接口 (数组 Set Map) 对象是没有Symbol.iterator属性123456789const arr = [1,2,3]const set = new Set(["a",2])const map = new Map([["a", 1]])const obj = &#123;a: 1&#125;console.log(arr[Symbol.iterator]) // ƒ values() &#123; [native code] &#125;console.log(arr[Symbol.iterator]() // Array Iterator &#123;&#125;console.log(set[Symbol.iterator]()) // SetIterator &#123;"a", 2&#125;console.log(map[Symbol.iterator]()) // MapIterator &#123;"a" =&gt; 1&#125;console.log(obj[Symbol.iterator]) // undefiend 具备iterator接口的数据机构都可以进行解构赋值和扩展运算符、for of遍历操作]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议原理与实践]]></title>
    <url>%2Fhttp%2F</url>
    <content type="text"><![CDATA[http三次握手URI URL URN URI 统一资源标志符 用来唯一标识互联网上的信息资源 包括URL和URN URL 统一资源定位符 如:https://www.baidu.com/s?wd=aa URN 永久统一资源定位符 在资源更换地址后还能找到 HTTP报文格式CORS cors预请求 允许方法 GET HEAD POST cors预请求 允许content-type text/plain multipart/form-data application/x-www-form-urlencoded 缓存头Cache-control 可缓存性 public private no-cahe 到期时间 max-age=seconds s-maxage=seconds max-stale=seconds 其他 no-store no-transform 1234567891011121314151617181920// 客户端 index.html&lt;script src="/cache.js"&gt;&lt;/script&gt;// 服务端 server.jsif (request.url === '/cache.js') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=20' &#125;) response.end('console.log("script loaded")')&#125;// 使用 Cache-Control:max-age=20后 客户端再20S之内访问cache会读取客户端缓存得cache.js,过期后会重新请求// 服务端 server.jsif (request.url === '/cache.js') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'no-store' &#125;) response.end('console.log("script loaded")')&#125;// 使用Cache-Control: no-store 禁止客户端使用缓存 Last-Modified 上次修改时间 配合If-Modified-Since或者If-Unmodified-Since使用 对比上次修改时间以验证资源是否需要更新 Etag 数据签名 配合If-Match或者If-Non-Match使用 对比资源的签名判断是否使用缓存 参考文章：Expires、Cache-Control、Last-Modified和If-Modified—Since、Etag和If-None-Match 通过HTTP Header控制缓存 Cookie与session cookie 通过Set-Cookie设置下次请求会自动带上，键值对，可以设置多个 12345678910111213// 1. max-age和expires设置过期时间// 2. secure只在https时候发送// 3. HttpOnly无法通过document.cookie访问// 服务端response.writeHead(200, &#123; 'Content-Type': 'text/html', // 'Set-Cookie': 'id=123' // 设置单个cookie // 'Set-Cookie': 'id=123;max-age=5' // 设置单个cookie失效时间 // 'Set-Cookie': ['id=123;max-age=5','abc=456'] // 设置多个cookie 'Set-Cookie': ['id=123; max-age=2', 'abc=456;domain=test.com'] // 设置多个cookie并设置domain&#125;)// 客户端 获取cookieconsole.log(document.cookie) session Http长连接 Connection&#39;: &#39;keep-alive&#39; （HTTP1.1才支持） HTTP协议采用请求-应答模式，当使用普通模式，非keep-alive时，每个请求/应答,客户端和服务端都要新建一个连接，完成之后立即断开（HTTP为无连接的协议） 当使用Keep-alive模式（又称持久连接，长链接），keep-alive功能使客户端到服务器端的连接持续有效，当客户端对服务器有后继请求时，keep-alive功能避免了重新建立连接。 Accept等头部信息 Accept: text/html Accept-Encoding:gzip,deflate,br Accept-Language:zh-CN,zh;q:0.9 User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1 referer: 发出请求的页面的URL Content Content-Type Content-Type:’application/x-www-form-urlencoded’ name=1212&amp;password=sds Content-Type: multipart/form-data; boundary=—-WebKitFormBoundary5hG57FPGsLkJqcnt Content-Encoding:’gzip’ Content-Language 重定向 Location 301与302区别 浏览器第二次访问时 不在请求服务器从失效链接重定向新的地址，而直接请求新地址 Content-Security-Policy客户端请求 http.request application/json application/x-www-form-urlencoded 表单提交 multipart/form-data 文件上传 text/xml 消息头 Content-Type&lt;实体首部&gt;：发送内容类型 Content-Length&lt;实体首部&gt;：发送内容长度 Location&lt;响应首部&gt;：重定向地址 Cookie&lt;请求首部&gt;：包含要发送给服务器的Cookie Set-Cookie&lt;响应首部&gt;：服务器端向客户端发送 cookie 状态码 1xx 提示信息–表示请求已被成功接收，继续处理 2xx 成功 - 表示请求已被成功接收，理解，接受 3xx 重定向 - 要完成请求必须进行更进一步的处理 4xx 客户端错误 - 请求有语法错误或请求无法实现 5xx 服务器端错误 - 服务器未能实现合法的请求 http状态码有那些？分别代表是什么意思？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 客户端请求成功，正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 永久重定向。旧地址已废弃无法访问，第二次访问时，不在请求服务器从失效链接重定向新的地址，而直接请求新地址 302 Found 临时性重定向。 旧地址还可以访问 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。服务端告诉浏览器可以使用缓存 400 Bad Request 客户端请求有语法错误， 不能被服务器所理解 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。服务器收到请求但是拒绝提供服务 404 Not Found 请求资源不存在 500 Internal Server Error 最常见的服务器端错误。服务器发生不可预期的错误 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 HTTPSHTTPS是使用加密通道来传输HTTP的内容。但是HTTPS首先与服务端建立一条TLS加密通道。TLS构建于TCP协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS跟HTTP没有任何区别。HTTPS的作用 确定请求的目标服务端身份 保证传输的数据不会被网络中间节点窃听或者篡改 HTTP2服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。TCP连接复用，则使用同一个TCP连接来传输多个HTTP请求，避免了TCP连接建立时的三次握手开销，和初建TCP连接时传输窗口小的问题。HTTP2改进点 支持服务端推送 支持TCP连接复用 请求头header中不能放入中文字符会出现编码问题,除非对中文字符进行编码,后台接收后再解码]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习redux]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0redux%2F</url>
    <content type="text"><![CDATA[Redux是JavaScript状态容器，提供可预测化的状态管理。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。Redux由Flux演变而来，避开了 Flux 的复杂性。 不管你有没有使用过它们，只需几分钟就能上手Redux。 ReduxRedux Flow redux 工作流注: react组件要改变store里面的数据,首先要dispatch(派发)一个action,传递给store,然后store再把之前的state数据和action转发给reducer函数,reducer接收到action和state之后,做一些处理,然后返回一个新的state(newState)给store, 之后store用新的state替换掉之前旧的state数据,store数据改变后, react组件感知到store数据改变,然后从store重新取数据,更新组件的内容,页面发生变化. 安装 Redux npm i redux 创建 state容器 创建 reducer 必须一个函数 在state中引入reducer 123456789101112131415161718192021222324252627282930313233343536373839404142// store/index.jsimport &#123; createStore &#125; from 'redux'import reducer from './reducer'const store = createStore(reducer)export default store// store/reducer.jsconst defaultState = &#123; inputValue: '', list: []&#125;export default (state = defaultState, action) =&gt; &#123; return state&#125;// 创建action todolist.js// input绑定 onChange=&#123;this.InpuChange.bind(this)&#125;InpuChange (e) &#123; const action = &#123; // 定义action type: 'change_input_value', value: e.target.value &#125; store.dispatch(action) // 派发action给reducer&#125;// store/reducer.js reducer接收actionexport default (state = defaultState, action) =&gt; &#123; console.log(state, action); if (action.type == 'change_input_value') &#123; // 拷贝一份state reducer可以接收state, 但是建议不要直接修改state const newState = JSON.parse(JSON.stringify(state)) newState.inputValue = action.value return newState //返回给store &#125; return state&#125;// store进行数据替换 store中的state数据变化// todolist.js 更新组件页面数据store.subscribe(this.changeStore.bind(this)) // 订阅store的改变changeStore () &#123; this.setState(store.getState()) // 重新获取store中state数据&#125; 在chrome应用商店 搜索并安装 Redux DevTools Chrome 调试Redux 12345// 在store.index.js 中创建store时加入这句const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()) 添加actionTypes.js的意义在于 用常量去表示action类型, 在dispacth和reducer中action.type不一致导致字符串不报错难以排查问题, 使用常量如果写错会报错, 且便于修改action的名称,只需要修改定时的action值即可 1234567891011121314151617181920212223242526// actionTypes.jsexport const CHANGE_INPUT_VALUE = 'change_input_value'export const ADD_TODO_ITEM = 'add_todo_item'export const DELETE_TODO_ITEM = 'delete_todo_item'// reducer.jsimport &#123;CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM &#125; from './actionTypes'export default (state = defaultState, action) =&gt; &#123; // store 和 input的value实现响应 reducer可以接收state, if (action.type === CHANGE_INPUT_VALUE) &#123; // 拷贝一份state 一定不能直接修改state 需要返回一个新的state数据 const newState = JSON.parse(JSON.stringify(state)) newState.inputValue = action.value return newState &#125;&#125;// todoList.jsimport &#123;CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM &#125; from './actionTypes'InpuChange (e) &#123; const action = &#123; type: CHANGE_INPUT_VALUE, value: e.target.value &#125; store.dispatch(action)&#125; 使用actionCreator统一创建action 123456789101112131415161718192021222324// actionCreators.jsimport &#123;CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM &#125; from './actionTypes'export const getChangeInputValue = (value) =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;)export const getAddTodoItem = () =&gt; (&#123; type: ADD_TODO_ITEM&#125;)export const getDeleteItem = (index) =&gt; (&#123; type: DELETE_TODO_ITEM, index&#125;)// TodoList.jsimport &#123; getChangeInputValue, getAddTodoItem, getDeleteItem &#125; from './store/actionCreators'InpuChange(e) &#123; store.dispatch(getChangeInputValue(e.target.value))&#125;buttonClick() &#123; store.dispatch(getAddTodoItem())&#125;itemDeleteHandle(index) &#123; store.dispatch(getDeleteItem(index))&#125; combineReducers对reducer进行拆分管理 123456789101112131415161718192021222324252627// /common/header/store/reducer.jsconst defaultState = &#123; focused: false&#125;export default (state = defaultState, action ) =&gt; &#123; let newState = &#123;...state&#125; // 拷贝新对象 if (action.type === 'focus_input') &#123; newState.focused = true &#125; if (action.type === 'blur_input') &#123; newState.focused = false &#125; return newState&#125;// /store/reducer.jsimport &#123; combineReducers &#125; from 'redux'import headerReducer from '../common/header/store/reducer'const reducer = combineReducers(&#123; header: headerReducer&#125;)export default reducer// header/index.jsconst mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.header.focused &#125;&#125; 使用Immutable.js来管理store中的state数据使其不可更改npm i immutable 1234567891011121314151617181920212223// header/reducer.jsimport * as actionCreators from './actionTypes'import &#123; fromJS &#125; from 'immutable'const defaultState = fromJS(&#123; focused: false&#125;)export default (state = defaultState, action ) =&gt; &#123; if (action.type === actionCreators.SEARCH_FOCUS) &#123; // immutable对象色set方法,返回一个全新的对象 return state.set('focused',true) &#125; if (action.type === actionCreators.SEARCH_BLUR) &#123; return state.set('focused', false) &#125; return state&#125;// heade/index.jsconst mapStateToProps = (state) =&gt; &#123; return &#123; // 使用get()获取immutable对象下的state属性 focused: state.header.get('focused') &#125;&#125; 使用redux-immutable统一数据格式npm i redux-immutable 12345678910111213141516// /store/reducer.js// import &#123; combineReducers &#125; from 'redux'import &#123; combineReducers &#125; from 'redux-immutable'import headerReducer from '../common/header/store/reducer'const reducer = combineReducers(&#123; header: headerReducer&#125;)export default reducer// heade/index.jsconst mapStateToProps = (state) =&gt; &#123; return &#123; // 使用get()获取immutable对象下的state属性 // focused: state.get('header').get('focused') focused: state.getIn(['header', 'focused'] &#125;&#125; redux的三要素 store是唯一的 只有store能够改变自己的内容 Reducer必须是纯函数 纯函数指的是给固定的输入,就一定会有固定的输出,不管调用多少次,而且不会有任何的副作用 使用Redux-thunk中间件实现ajax请求(实际上是对dispatch的升级) npm i redux-thunk -S 在创建redux时,配置redux-thunk,redux-devtools 12345678910import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import thunk from 'redux-thunk'import reducer from './reducer'const composeEnhancers =window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : composeconst enhancer = composeEnhancers( applyMiddleware(thunk))const store = createStore(reducer, enhancer)export default store 在actionCreator创建action，就可以使用函数作为返回值了 1234567891011121314// actionCreator.jsexport const initTodoList = (data) =&gt; (&#123; type: INIT_TODOLIST, data&#125;)export const getTodoList = () =&gt; &#123; // 接收 dispatch 参数，直接使用，相当于调用store.dispatch方法 return (dispatch) =&gt; &#123; axios.get('/list.json').then( res =&gt; &#123; console.log(res.data) dispatch(initTodoList(res.data)) &#125;) &#125;&#125; 在组件componentDidMount钩子函数中调用getTodoList 123componentDidMount () &#123; store.dispatch(getTodoList())&#125; reducer接收store转发的state和action，处理改变state 12345678// reducer.jsexport default (state = defaultState, action) =&gt; &#123; if (action.type === INIT_TODOLIST) &#123; const newState = JSON.parse(JSON.stringify(state)) newState.list = action.data return newState &#125;&#125; 使用Redux-saga中间件处理异步请求 npm i redux-saga -S 在创建redux时,配置redux-saga,redux-devtools 123456789101112131415// index.js reduximport &#123; createStore, applyMiddleware, compose &#125; from 'redux';import reducer from './reducer';import createSagaMiddleware from 'redux-saga'import todoSaga from './todoSaga' // saga文件处理异步请求 必须是一个generator函数const sagaMiddleware = createSagaMiddleware()const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware));const store = createStore(reducer, enhancer);sagaMiddleware.run(todoSaga) // 执行todosagaexport default store; 在actionCreator创建action 在actionTypes创建常量GET_INIT_LIST 123456// actionTypes.jsexport const GET_INIT_LIST = 'get_init_list'// actionCreator.jsexport const getInitList = () =&gt; (&#123; type: GET_INIT_LIST&#125;) 创建todoSaga.js文件 12345678910111213141516import &#123; takeEvery, put &#125; from 'redux-saga/effects'import &#123; GET_INIT_LIST &#125; from './actionTypes'import axios from 'axios'import &#123; initTodoList &#125; from './actionCreators'function* fetchList () &#123; try &#123; const res = yield axios.get('/list.json') yield put(initTodoList(res.data)) &#125; catch (err) &#123; consoloe.log(err) &#125;&#125;function* todoSaga () &#123; yield takeEvery(GET_INIT_LIST, fetchList)&#125;export default todoSaga 在组件componentDidMount钩子函数中调用getInitList 1234import &#123; getInitList &#125; from './store/actionCreators'componentDidMount () &#123; store.dispatch(getInitList())&#125; reducer接收store转发的state和action，处理改变state 12345678// reducer.jsexport default (state = defaultState, action) =&gt; &#123; if (action.type === INIT_TODOLIST) &#123; const newState = JSON.parse(JSON.stringify(state)) newState.list = action.data return newState &#125;&#125; React-redux的作用是为了在项目中使用Redux更加方便。 npm install --save react-redux 使用 Provider 提供器包裹组件 123456789101112// index.jsimport React from 'react';import ReactDOM from 'react-dom';import store from './store'import &#123; Provider &#125; from 'react-redux'import Todo from './Todo'const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;Todo /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); 使用 connect 将组件和store连接起来 1234567891011121314151617181920212223242526272829// Todo.jsimport React from 'react'import &#123; connect &#125; from 'react-redux'class Todo extends React.Component &#123; render () &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.props.inputValue&#125; onChange=&#123;this.props.changeInputValue&#125;/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; inputValue: state.inputValue &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue (e) &#123; dispatch(&#123; type: 'change_input_value', value: e.target.value &#125;) &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(Todo) reducer接收store转发的state和action，处理改变state 1234567891011// reducer.jsconst defaultState = &#123; inputValue: ''&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === 'change_input_value') &#123; const newState = JSON.parse(JSON.stringify(state)) newState.inputValue = action.value return newState &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript(I)]]></title>
    <url>%2FTypescript%2F</url>
    <content type="text"><![CDATA[TypeScript 是一种由微软开发的的强类型编程语言。它是JavaScript的一个超集，可以编译成纯Javascript，兼容JavaScript，提供类和模块的概念，它的最大的特点就是类型化。未来前端开发的趋势。不能在浏览器或node中直接运行需要先编译为Javascript才能运行。 typescript编译环境 方式一 全局安装typescript npm i typescript -g tsc -v 查看安装版本在命令行使用 tsc xxx.ts 将ts编译生成对应的js文件 方式二 全局安装ts-node npm i ts-node -g在命令行使用 ts-node xxx.ts 执行ts文件，不会生成js文件就可以运行 typescript配置文件 npm init -y 创建package.json tsc –init 创建一个 tsconfig.json配置文件 数据类型 基础数据类型 boolean、number、string、undefined、null、symbol、enum、any、void、never、tuple、array、object 高级类型 union 组合类型、Nullable 可空类型、Literal 预定义类型 1234567891011121314151617181920/*boolen 布尔值 var isDone:boolen = falsenumber 数值型 var isNumber:number = 6string 字符型 var name:string = 'bob'never 不会出现的值array 数组 在元素类型后加[] arr:number[]=[1,2]元祖 数组长度固定，元素类型也固定 let x:[string,number]=['1',2]*/// TypeScript中数组使用'[]'来声明var list:number[] = [1,2,3] // 同 list = [1,2,3] list:Array&lt;number&gt; = [1,2,3]var name:string[] = ['赵','钱','孙','李']// 通过下标访问数组元素console.log(list[1]) // 2// 使用泛型+关键字Array+any 定义任意类型的数组 使用var arr:Array&lt;any&gt; = [1,2,3,'赵','钱',false,&#123;&#125;,3.2];console.log(list[6]) // &#123;&#125;// 使用any声明 任意类型数组var arr:any[] = [1,2,3,'赵','钱',false,&#123;&#125;,3.2];// 元组 tuple 数组长度固定 类型也固定 元祖声明时必须指定类型const arr:[number, string, undefined] = [1, '2', undefined] enum 枚举类型用于定义数值集合 用关键字enum来声明 12345678910111213141516171819202122232425262728// 如果不声明第一项的值 那么Red值就是0,然后每一项都加1enum Color&#123; Red, // 枚举元素列表 Green, Blue&#125;;var c:Color = Color.Blueconsole.log(c); // 2// 如果为某一项指定一个值则后面的值依次递增enum Color&#123; Red, // 枚举元素列表 Green = 5, Blue&#125;;var c:Color = Color.Red;var d:Color = Color.Blue;console.log(c); // 0console.log(d); // 6// 另外枚举类型还有一个比较特殊的功能，假如我们有一个数值，但是我们不知道枚举类型中是否有定义，可以用以下方式来获取，代码如下enum Color &#123; Red = 1, Green, Blue&#125;;var colorName: string = Color[2]; //访问第二个枚举子元素Greenconsole.log(colorName); // GreencolorName = Color[4];console.log(colorName); // undefined any 任意类型,动态的，能够赋予任意类型。声明时未指定类型,会被识别为任意类型 1234567var notSure:any = 4;notSure = 'maybe a string';notSure = false;var list:any[] = [1,true,'free'];list[1] = &#123;&#125;console.log(list[1]); // &#123;&#125;notSure() // notSure is not a function unknown 与 any类似 使用时需要做判断 可能会报错 1234var notSure:unknown = 4;notSure = 'maybe a string';notSure = false;notSure() // notSure is not a function union联合类型 只能访问此联合类型的所有类型里共有的属性或方法 12345var union:string|number;union = '字符串'union = 2console.log(union)console.log(union.length) // 类型“number”上不存在属性“length”。 Literal字面量类型 只能在声明的字面量里取值 不能赋值为其他值 1234let literal:1|'a'|true|[1,3]literal = trueliteral = 3 // 不能将类型 3 分配给 “1|'a'|true|[1,3]”console.log(literal) void 函数无返回值 12345// 哈数默认的返回类型就是 void 仅能在函数中使用 返回类型指定为void,表示该函数不返回任何值function warnUser():void&#123; console.log('定义一个无返回值得函数')&#125;console.log(warnUser()) // undefined 类型推断：当给一个变量赋值初始化时，如果变量类型没有给出时，TS会自动的去尝试分析变量的类型,如果TS无法分析变量类型的话，我们就需要使用类型声明 类型适配(类型断言)1234567let msg:any;msg = 'ac' // 虽然声明为string 但类型还是any 无法自动提示字符串的方法// console.log(msg.endsWith('c'))// 类型适配方法1 (&lt;string&gt;msg)let res = (&lt;string&gt;msg).endsWith('c')// 类型适配方法2 (msg as string)let res1 = (msg as string).endsWith('c') 函数的定义与调用 函数的定义与调用 123456789101112/*return_type该函数的返回值类型 return data需要返回的数据特殊的返回值类型 void 无返回值 never 不会执行未指定返回类型 默认为 void*/function function_name(arg:number,arg1:number,....):return_type&#123; return data&#125;function add(x:number,y:number):number&#123; return x+y&#125;console.log(add(5,6)) // 11 函数的参数注：可选参数和默认参数必须在参数列表的最后。 可选参数: 在参数名后面，冒号前面添加一个问号，则表明该参数是可选的 123456789function buildName(firstName:string,lastName?:string)&#123; if (lastName) &#123; return firstName + ' ' + lastName &#125; else &#123; return firstName &#125;&#125;console.log(buildName('Bob')) // Bobconsole.log(buildName('Bob','Ada')) // Bob Ada 默认参数: 在参数名后直接给定一个值，如果这个值没有被传入，将会被赋值为默认值 12345function buildName(firstName:string, lastName='Smith')&#123; return firstName + ' ' + lastName&#125;console.log(buildName('JR')); // JR Smithconsole.log(buildName('JR','James')); // JR James 解构赋值的参数类型 123456// 参数解构 参数类型声明 返回值类型function add(&#123; a, b &#125;: &#123; a: number, b: number &#125;): number &#123; return a + b&#125;let c = add(&#123; a: 2, b: 3 &#125;)console.log(c) // 5 class类 类的结构及声明 创建一个TypeScript类 必须使用class关键字进行声明 属性和方法的定义 属性: 类的属性实质为在类体内定义的变量，用于保存或设置参数 方法: 类的方法实质为在类体内定义的函数，用于实现某项功能，其定义方法与普通函数定义方法相同，同时可以应用访问权限关键字对方法访问权限进行限制1234567class 类名&#123; name:string; // 定义类的属性 fun()&#123;&#125; // 定义一个无返回值的方法 say():string&#123; // 定义返回值类型为string的方法 return '返回值' // 返回函数值 &#125;&#125; 静态属性 可以使用static关键字标注类的属性注:类的静态属性在类的内部只能使用 类名.静态属性方式调用(calc.count) 而不能使用this.count调用 12345678910class Calc&#123; static count=10; add(data1:number):number&#123; var sum=Calc.count+data1; return sum; &#125;&#125;var test=new Calc();console.log(test.add(20)); // 30// 类的静态属性在类的内部只能使用 类名.静态属性方式调用(calc.count) 而不能使用this.count调用 构造函数 是一种特殊的方法。用来在创建对象时初始化对象， 即为对象成员变量赋初始值.而TypeScript的构造函数用关键字constructor来实现。 123456789class Student&#123; //定义student类 name:string; //定义类的属性 constructor(myname:string)&#123; //定义构造函数 this.name=myname; &#125; study()&#123; //定义类的方法 //定义该方法所要实现的功能 &#125;&#125; 类的实例化 一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法。 12345678910111213141516class Student&#123; //定义student类 name:string; //定义类的属性 constructor(myname:string)&#123; //定义带参数的构造函数 this.name=myname; &#125; study()&#123; //定义类的方法 console.log("&lt;h1&gt;study "+this.name+"&lt;/h1&gt;"); &#125; write():string&#123; return this.name; &#125;&#125;var s1=new Student("Jim");console.log("&lt;h2&gt;attr "+s1.name+"&lt;/h2&gt;"); //获取name属性s1.study(); // 调用study方法console.log("&lt;h3&gt;write "+s1.write()+"&lt;/h3&gt;"); 类的继承 TypeScript中用关键字extends指明继承关系。例如，已经定义了类A，如果让类B继承A,我们把A叫做基类，B叫子类。 要在子类中调用基类中的属性与方法就要使用super关键字 1234567891011121314151617181920212223class Animal &#123; // 定义基类 name: string; constructor(theName:string)&#123; this.name = theName; &#125; move(meters:number) &#123; console.log(this.name + " moved " + meters + 'm.') &#125;&#125;class Snake extends Animal&#123; contructor(name:string)&#123; super(name); // 调用基类的构造函数 &#125; move()&#123; // 重写基类的方法 console.log('----Snake----') super.move(5); // 调用基类的方法 &#125;&#125;var s = new Snake('Tom');s.move();/*在Typescript中我们采用extends关键字来标识类的继承关系,在实例中重写父类的方法,并通过super关键字来调用父类的方法*/ interface接口 强约束对象的属性、属性的个数、属性值的类型 可描述类的一部分抽象行为，也可描述对象的结构形状 接口一般首字母大写 赋值的时候，变量的形状必须和接口的形状保持一致 接口中可定义可选属性 只读属性 任意属性1234567891011121314interface Person &#123; name: string, age?: number // ?可选参数&#125;const getPersonName = (person: Person) =&gt; &#123; console.log(person.name, 'get')&#125;const setPersonName = (person: Person, name: string) =&gt; &#123; person.name = name console.log(person.name, 'set')&#125;const person = &#123;name: 'tew'&#125;getPersonName(person) // tewsetPersonName(person, 'bob') // bob 类的访问控制 public 允许在类的内外被使用(默认为public) private 允许在类的内部被使用 protected 允许在类的内部及继承的子类中被使用1234567891011121314151617181920212223242526272829/* public private */class Person &#123; private name: string = 'tew'; public getName() &#123; console.log(this.name) &#125;&#125;const person = new Person()// console.log(person.name)// Property 'name' is private and only accessible within class 'Person'.person.getName() // tew/* protected */class Animal &#123; protected name: string = 'yang' protected getName() &#123; console.log(this.name) &#125;&#125;class Sheep extends Animal &#123; getSheepName() &#123; this.getName() // yang 等同 super.getName() console.log(this.name) // yang &#125;&#125;const sheep = new Sheep()// sheep.getName()// Property 'getName' is protected and only accessible within class 'Animal' and its subclasses.sheep.getSheepName() abstract 抽象类 readonly 类的修饰符 初始值之后不可再修改 abstract 抽象类123456789101112131415161718192021222324252627class Person &#123; // readonly 只读不可修改 public readonly name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;const person = new Person('tew');// person.name = 'hello';console.log(person.name);// 抽象类 不能实例化 只能被继承abstract class Geom &#123; getType() &#123; return 'Gemo'; &#125; // 抽象方法只能定义 不能实现 abstract getArea(): number;&#125;// 继承抽象类 并实现抽象方法class Circle extends Geom &#123; getArea() &#123; // 实现抽象类 return 123; &#125;&#125;console.log(new Circle().getArea()) //123 泛型 generic 泛指的类型 函数泛型 12345678910111213141516function join&lt;T&gt;(first: T, second: T) &#123; return `$&#123;first&#125;$&#123;second&#125;`&#125;join&lt;string&gt;('1', '2')join&lt;number&gt;(1, 2)// function map&lt;T&gt;(arg: Array&lt;T&gt;)&#123; return arg &#125;function map&lt;T&gt;(arg: T[]) &#123; return arg&#125;map&lt;string&gt;(['1'])function join1&lt;T, P&gt;(first: T, second: P) &#123; return `$&#123;first&#125;$&#123;second&#125;`&#125;join1&lt;string, number&gt;('1', 2) 类中的泛型 12 d.ts 类型描述文件 类型定义文件]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用clipboard实现复制文本到剪贴板]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8clipboard%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[clipboard是一款轻量级的实现复制文本到剪贴板功能的JavaScript插件。通过该插件可以将输入框，文本域，DIV元素中的文本等文本内容复制到剪贴板中.clipboard支持主流的浏览器：chrome 42+、Firefox 41+、IE 9+、opera 29、Safari 10+ 使用方式 直接引入cdn或下载到本地&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.8/clipboard.min.js&quot;&gt;&lt;/script&gt; 在npm脚手架中使用npm install clipboard --saveimport Clipboard from &#39;clipboard&#39; clipboard复印内容的方式 从target复制目标内容 123456789101112131415&lt;button class="btn"&gt;Copy_target&lt;/button&gt;&lt;script&gt;var clipboard = new ClipboardJS('.btn', &#123; // 通过target指定要复印的节点 target: function() &#123; return document.querySelector('.btn') &#125;&#125;)clipboard.on('success', function(e) &#123; console.log(e)&#125;)clipboard.on('error', function(e) &#123; console.log(e)&#125;)&lt;/script&gt; 通过function的text要复制的内容 123456789101112131415&lt;button class="btn"&gt;Copy&lt;/button&gt;&lt;script&gt;var clipboard = new ClipboardJS('.btn', &#123; // 点击copy按钮，直接通过text直接返回复印的内容 text: function() &#123; return 'text 复制内容' &#125;&#125;)clipboard.on('success', function(e) &#123; console.log(e)&#125;)clipboard.on('error', function(e) &#123; console.log(e)&#125;)&lt;/script&gt; 通过属性返回复制的内容 123456789&lt;button class="btn" data-clipboard-text="通过属性复制"&gt;Copy&lt;/button&gt;&lt;script&gt;var clipboard = new ClipboardJS('.btn')clipboard.on('success', function(e) &#123; console.log(e)&#125;)clipboard.on('error', function(e) &#123; console.log(e)&#125;) 使用中遇到过的问题 clipboard复制成功或失败多次回调的问题 12345678910// 只需要在成功或失败时 及时销毁即可var clipboard = new ClipboardJS('.btn')clipboard.on('success', function(e) &#123; console.log(e) clipboard.destroy()&#125;)clipboard.on('error', function(e) &#123; console.log(e) clipboard.destroy()&#125;) 复制文本时文本会被选中 12345678var clipboard = new ClipboardJS('.btn')clipboard.on('success', function(e) &#123; e.clearSelection() // 禁止复制文字后文字被选中 clipboard.destroy()&#125;)clipboard.on('error', function(e) &#123; clipboard.destroy()&#125;) 在vue的弹窗组件中无法复制的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 解决办法：使用$ref获取实例化需要传入的DOM --&gt;&lt;template&gt; &lt;div class="hello"&gt; &lt;el-popover placement="bottom" width="400" trigger="click"&gt; &lt;el-table :data="gridData"&gt; &lt;el-table-column min-width="150" property="date" label="日期"&gt;&lt;/el-table-column&gt; &lt;el-table-column min-width="100" prop="name" label="姓名"&gt; &lt;template slot-scope="scope"&gt; &lt;span @click="copy(scope)" :ref="'copy' + scope.$index" :data-clipboard-text="scope.row.name"&gt;&#123;&#123; scope.row.name &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-button slot="reference"&gt;click 激活&lt;/el-button&gt; &lt;/el-popover&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ClipboardJS from 'clipboard'export default &#123; name: 'HelloWorld', data() &#123; return &#123; gridData: [&#123; date: '2016-05-02', name: '王小虎' &#125;,&#123; date: '2016-05-02', name: '王老鼠' &#125;], &#125; &#125;, methods: &#123; copy (scope) &#123; let el = this.$refs['copy'+scope.$index] let clipboard = new ClipboardJS(el) clipboard.on('success', ()=&gt;&#123; this.$message('复制成功') clipboard.destroy() &#125;) clipboard.on('error', ()=&gt;&#123; this.$message('复制失败') clipboard.destroy() &#125;) clipboard.onClick(event) &#125; &#125;&#125;&lt;/script&gt; 第一次点击复制不生效，第二次才生效的问题点击复制时使用clipboard.onClick() 12345678910111213copy (scope) &#123; let el = this.$refs['copy'+scope.$index] let clipboard = new ClipboardJS(el) clipboard.on('success', ()=&gt;&#123; this.$message('复制成功') clipboard.destroy() &#125;) clipboard.on('error', ()=&gt;&#123; this.$message('复制失败') clipboard.destroy() &#125;) clipboard.onClick(event)&#125; 最终版使用 event.target 代替传入的DOM 不需要获取DOM或ref 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class="hello"&gt; &lt;el-popover placement="bottom" width="400" trigger="click"&gt; &lt;el-table :data="gridData" ref="atb"&gt; &lt;el-table-column min-width="150" property="date" label="日期"&gt;&lt;/el-table-column&gt; &lt;el-table-column min-width="100" prop="name" label="姓名"&gt; &lt;template slot-scope="scope"&gt; &lt;span @click="test" :data-clipboard-text="scope.row.name"&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-button slot="reference"&gt;click 激活&lt;/el-button&gt; &lt;/el-popover&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ClipboardJS from 'clipboard'export default &#123; name: 'HelloWorld', data() &#123; return &#123; gridData: [&#123; date: '2016-05-02', name: '王小虎' &#125;,&#123; date: '2016-05-02', name: '王老鼠' &#125;], &#125; &#125;, methods: &#123; test (event) &#123; // 需要注意的是要复制的内容是元素本身 let clipboard = new ClipboardJS(event.target) // 使用event.target 代替 获取DOM clipboard.on('success', (e)=&gt;&#123; this.$message('复制成功') e.clearSelection() // 禁止复制文字后文字被选中 clipboard.destroy() &#125;) clipboard.on('error', (e)=&gt;&#123; this.$message('复制失败') clipboard.destroy() &#125;) clipboard.onClick(event) // 解决第一次点击无法复制的问题 第二次可正常复制的问题 &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人收藏夹]]></title>
    <url>%2F%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[好记性不如烂笔头，日常开发中，打开过或这浏览过的网页无数个，总有那么一些让你舍不得关掉。最终就把它们收入麾下，特此整理在一个简单的收藏夹中。包括一些好用的插件，常用的网站，好的博客，所知道的前端团队等等。 工具类或插件库 jQuery插件库-收集最全最新最好的jQuery插件 Web 前端常用插件 jQuery库 / 幻灯片和轮播图_jQuery之家-自由分享jQuery、html5、css3的插件 各式各样的loading better-scroll SortableJS 功能强大的JavaScript 拖拽库 TinyPNG 图片压缩 雪碧图在线生成工具 css prites，css精灵，雪碧图生成 素材类 dowebok - 做好网站 觅元素设计元素的免费下载网站免抠素材 前端常用技术官网网站 vue.js 官网 swiper中文网 Element - 网站快速成型工具 easy-mock iView layui Bootstrap 前端团队博客学习类网站 慕课网 妙味课堂 从html、css到 js，WEB前端开发在线学习视频教程 - html中文网 知名大神博客 张鑫旭的个人主页 » 张鑫旭-鑫空间-鑫生活 张鑫旭 github 阮一峰的个人网站 - Ruan YiFeng’s Personal Website 其他 配置ESLint(代码检查) 最好用的切图工具 Markdown 语法整理大集合 VS Code 折腾记系列 docute 无需编译的文档生成器 好用的chrome插件 Vue.js devtools Vue官方发布的一款调试 Vue 项目的插件 Vue Performance Devtool 分析我们页面中各个组件的性能情况 Postman 非常好用的接口调试工具 FeHelper 是百度 FE 团队开发的一款前端工具集插件 Can I Use 查看某一特性的浏览器支持程度 JSONView 将后台返回的 JSON 字符串数据自动格式化成规范 JSON 格式的插件 Wappalyzer 一款查看当前网站使用的前后端技术的插件 Mobile/Responsive Web Design Tester 一款用于测试页面在不同机型下呈现的插件 Resolution Test 一款用于测试页面在不同分辨率下呈现的插件 草料二维码 将当前页面或指定页面生成二维码]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝、浅拷贝与循环引用]]></title>
    <url>%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[对于javascript而言，想要实现对象的拷贝/复制，单纯的使用赋值语句是不全面的，对于简单数据（值类型）是没问题的，但是对于对象这种复杂数据类型就会有意想不到的问题。一般而言，深拷贝与浅拷贝只针对像Object，Array这样的复杂对象。浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 浅拷贝与深拷贝的区别 浅拷贝：只会将复制目标对象的第一层的各个属性依次复制，不会进行递归复制。浅拷贝时,如果属性是基本类型值,拷贝的是基本类型的值,改变其中不一个对象不会改变另一个对象。如果属性是引用类型地址，并不会分配新的对地址，是将两个对象指向同一地址，修改其中一个对象的属性，则另一个对象的属性也会改变。 深拷贝：递归拷贝目标对象的所有属性。深拷贝会在堆内存开辟新的地址，两个对象对应两个不同的地址，修改其中一个不会改变另一个对象。 浅拷贝的实现方式 常用方式拷贝-遍历属性拷贝 1234567891011121314151617let obj = &#123; a: 100, b: [10, 20], c: &#123; x: 10 &#125;&#125;let obj2 = &#123;&#125;for (let key in obj) &#123; if (!obj.hasOwnProperty(key)) break obj2[key] = obj[key]&#125;// console.log(obj2) // &#123;a: 100, b: [10, 20], c: &#123; x:10 &#125;&#125;obj2.a = 200 // 修改对象属性为基本类型值 另一个对象不会改变 值类型拷贝 开辟新的栈obj2.b[1] = 50 // 修改对象属性为引用类型时 另一个对象会改变 浅拷贝时引用类型拷贝的是引用类型的指针console.log(obj2) // &#123;a: 200, b: [50, 20], c: &#123; x:10 &#125;&#125;console.log(obj) // &#123;a: 100, b: [50, 20], c: &#123; x:10 &#125;&#125; 扩展运算符 … 1234567891011121314let obj = &#123; a: 100, b: [10, 20, 30], c: &#123; x: 10 &#125;, d: /^\d+$/&#125;let obj2 = &#123;...obj&#125;// console.log(obj2) // &#123;a: 100, b: [10, 20], c: &#123; x:10 &#125;&#125;obj2.a = 200 // 修改对象属性为基本类型值 另一个对象不会改变 值类型拷贝 开辟新的栈obj2.b[1] = 50 // 修改对象属性为引用类型时 另一个对象会改变 浅拷贝时引用类型拷贝的是引用类型的指针console.log(obj2) // &#123;a: 200, b: [50, 20], c: &#123; x:10 &#125;&#125;console.log(obj) // &#123;a: 100, b: [50, 20], c: &#123; x:10 &#125;&#125; Object.assign() 1234567891011const obj1 = &#123; a:100, b: &#123; x:100 &#125;&#125;const obj2 = Object.assign(&#123;&#125;, obj1)obj2.a = 200 // 改变对象基本类型值 原对象未改变obj2.b.x = 200 // 改变对象引用类型值 原对象也被改变console.log(obj2) // &#123;a: 200, b: &#123; x: 200 &#125;&#125;console.log(obj1) // &#123;a: 100, b: &#123; x: 200 &#125;&#125; 深拷贝的实现方式 JSON.parse(JSON.stringify(obj))存在弊端 属性值为 undefined symbol 正则 函数 Date 会有问题 1234567891011121314151617// a. 属性值为正则表达式时 会将 正则转化为 &#123;&#125;// b. 属性值为任意函数, undefined, symbol时 在非数组中 出现丢失 会被忽略, 在数组中会被转化为null// c. 属性值为 new Date() 时 会转化为具体时间"2019-05-20T14:02:41.568Z"// d. 会抛弃对象原来的constructor,不管这个对象原来的构造函数是什么,深拷贝后都会变成Object// e. 无法处理对象中存在循环引用问题let obj = &#123; a: 100, b: [10, undefined], c: &#123;x: 10&#125;, d: /^\d+$/, e: function()&#123;&#125;, f: new Date(), g: undefined, h: Symbol('tew')&#125;const obj2 = JSON.parse(JSON.stringify(obj))console.log(obj2) // &#123;a:100,b:[10,null],c:&#123;x:10&#125;,d:&#123;&#125;,f:"2019-05-20T14:02:41.568Z"] 递归拷贝 1234567891011121314151617181920212223242526272829303132let obj = &#123; a: 100, b: [10, undefined], c: &#123;x: 10&#125;, d: /^\d+$/, e: function()&#123;&#125;, f: new Date(), g: undefined, h: Symbol('tew')&#125;// 比较完善的递归拷贝 不考虑对象的循环引用function deepClone(obj)&#123; // 过滤特殊情况 if (obj === null) return null if (typeof obj !== "object") return obj // 不是对象就不用拷贝 if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) // let newObj = &#123;&#125; 会使 数组变成对象&#123;&#125; 如 [10, undefined] 变成 &#123;0:10,1:undefined&#125; // 不直接创建空对象目的：克隆的结果和之前保持相同的所属类 如Array和Synmol // 防止抛弃对象原来的constructor 深拷贝后变成 Object let newObj = new obj.constructor; for (let key in obj) &#123; // 保证 key 不是原型的属性 if (obj.hasOwnProperty(key)) &#123; newObj[key] = deepClone(obj[key]) // 将值进行递归调用 &#125; &#125; console.log(JSON.stringify(newObj)) return newObj;&#125;deepClone(obj)// &#123;a:100,b:[10,undefined],c:&#123;x:10&#125;,d:/^\d+$/,e:f(),f:2019-05-20T14:02:41.568Z,g:undefined,h: Symbol(tew)&#125; 对象存在循环引用使用递归深拷贝会出现栈溢出12345678910111213141516171819202122const obj = &#123; x: 1, y: 2&#125;obj.z = objfunction deepClone(obj)&#123; // 过滤特殊情况 if (obj === null) return null if (typeof obj !== "object") return obj if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) let newObj = new obj.constructor; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = deepClone(obj[key]) &#125; &#125; console.log(JSON.stringify(newObj)) return newObj;&#125;deepClone(obj)// Uncaught RangeError: Maximum call stack size exceeded]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git cherry-pick、git rebase、git revert]]></title>
    <url>%2Fgit%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git cherry-pick可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在master合入dev某次分支的提交时，我们不能对整个dev分支进行合并，因为可能有未开发完成的内容，而是只想将dev某一次提交合入到master分支上，那么就要使用git cherry-pick了。 git cherry-pick 挑拣式提交基本语法123456789// git cherry-pick [&lt;options&gt;] &lt;commit-id&gt;// 常用options/* --quit 退出当前的chery-pick序列 --continue 继续当前的chery-pick序列 --abort 取消当前的chery-pick序列，恢复当前分支 -n, --no-commit 不自动提交 -e, --edit 编辑提交信息*/ git cherry-pick commitid 当cherry-pick时，成功自动提交，则直接git push即可 当cherry-pick时，存在冲突，未成功提交，解决冲突后再git commit手动提交 或者 git add . 再使用git cherry-pick --continue继续12345$ git cherry-pick 2555c6eerror: could not apply 2555c6e... [Description]:branch2 commit 2hint: after resolving the conflicts, mark the corrected pathshint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;'hint: and commit the result with 'git commit' git cherry-pick –quit 中断cherry-pick,当前分支中未冲突的内容状态将为modified git cherry-pick –abort 取消cherry-pick 当前分支恢复到cherry-pick前的状态，没有改变。 从一个分支cherry-pick多个commit 想在该分支合并多个连续的commit提交时, 只需要在commitId中添加两个点.. 12// git cherry-pick commitId1..conmmitId5// 注意 此时合并的commit 不包括第一个commitiId 只合并 conmmitId2到conmmitId5 想在该分支合并多个不连续commit提交时, 将commitId用空格隔开即可` 12// git cherry-pick commitId1 conmmitId3// 注意 此时合并 conmmitId1 conmmitId3 到当前分支 git rebase 变基(使提交记录更简洁) 将本地未push到远程的多条commit提交记录合并成一条记录提交到远程123// git rebase -i 将本地的多次提交合并为一个，以简化提交历史// git rebase -i HEAD~n 将本地的n次提交合并为一个，以简化提交历史// 在弹出的交互式界面中完成合并操作 将需要合并的commit选择s操作合并 不要通过rebase对任何已经提交到远程公共仓库中的commit进行修改（你自己一个人玩的分支除外）rebase 用法小结 使用git pull --rebase可以避免无用的Merge branch xxxbranch of xxx into xxxbranch在你开发提交后未push到远程时，如果其他人提交了远程记录，当你在push时，需要先git pull拉取代码，如果无冲突，再push到远程后，可以在提交记录中发现有一条类似 Merge branch xxxbranch of xxx into xxxbranch的体积记录，显然不太美观，最好的操作是使用git pull --rebase进行变基拉取代码，再提交时，就不会产生Merge这种无用的提交信息，如果有冲突需要先解决冲突再push 123// git fetch + git rebase 替换 git pull 减少分支的分叉git fetch origin devgit rebase origin/dev 当使用git rebase产生冲突时，需要先解决冲突，然后按照操作 git rebase --continue 继续执行合并提交记录 git revert 撤销某个已经提交的的快照和reset 重置到某个指定版本不一样。它是在提交记录最后面加上一个撤销上次更改的新提交，而不是从项目历史中移除这个提交，这避免了 Git 丢失项目历史。 git revert HEAD 生成一个撤销最近的一次提交的新提交 git revert HEAD^ 生成一个撤销最近一次提交的上一次提交的新提交 git revert HEAD^^ 生成一个撤销最近一次提交的上两次提交的新提交 git revert HEAD~n 生成一个撤销最近一次提交的上n次提交的新提交 git revert &lt;commit_id&gt; 生成一个撤销指定提交版本的新提交revert（撤销）是撤销公共提交的安全方式，reset（重设/回退）是重设/回退本地更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。千万不要用 git reset 回退已经被推送到公共仓库上的 提交，它只适用于回退本地修改（从未提交到公共仓库中）。如果你需要修复一个公共提交，最好使用 git revert。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle移动端调试利器]]></title>
    <url>%2Fwhistle%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[whistle基于Node实现的跨平台web调试代理工具，类似的工具有Windows平台上的Fiddler，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用，不同于Fiddler通过断点修改请求响应的方式，whistle采用的是类似配置系统hosts的方式，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种匹配方式，且可以通过Node模块扩展功能： 安装使用whistle官网 安装 npm i -g whistle 启动：w2 start 手机或浏览器设置代理：http://192.168.5.16:8899 确保手机和电脑处于同一局域网下 安装证书ios安装证书后需要添加为信任或验证 设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到证书然后验证 浏览器打开 http://192.168.5.16:8899 手机或电脑设置好代理和安装完证书之后就可以实现抓包了 线上资源文件指向本地 可修改本地代码调试在线网页在Rules中新建一个规则 https://www.test.cn/flow file://D:\project\flow12345// 替换单个文件'https://www.test.cn/flow/index.html file://D:\project\flow\index.html''https://www.test.cn/flow/js/flow.js file://D:\project\flow\js\flow/flow.js'// 替换整个项目'https://www.test.cn/flow file://D:\project\flow' 注入调试 vConsole 或者 Eruda 需安装插件该规则需要安装插件：npm i -g whistle.inspect，插件官网 如果需要注入Eruda，只需改成 whistle.inspect://e1234// 页面自动注入 vConsole'https://www.test.cn/flow/index.html whistle.inspect://'// 页面自动注入 Eruda'https://www.test.cn/flow/index.html whistle.inspect://e' 使用 log 功能打印日志：在移动端真机调试中，我们无法像浏览器控制台那样，查看输出的日志和数据，以往的替代方案是在页面上使用vconsole插件，而有了whistle后，我们可以这样做：12// 打开目标页面后 在右侧找到 log面板打开即可查看 log信息'http://www.baidu.com/ log://' 使用whistle内置的Weinre调试移动端页面：weinre相信大家都很熟悉，而whistle内置了weinre，使用方法如下：在rules配置：https://www.test.cn weinre://flow这时候，就能在http://192.168.5.16:8899/weinre/client/#flow 看到调试界面了 使用 mock 修改响应 该规则需要安装插件 whistle.vasenpm i -g whistle.vase 插件官网代理环境打开 http://vase.local.whistlejs.com123456789// 添加名为 systemDate，Engine为 mock 的数据&#123; "retCode": "000000", "retDesc": "SUCCESS", "rspBody": &#123; "date": "2018-11-16 15:55:46", "test": "@cword(1,10)" &#125;&#125; 替换接口响应 https://www.test.cn/flow/getPayRule vase://getPayRule 注：若whistle.vase为1.0.1及以下 使用以下方式 否则替换不成功https://www.test.cn/flow/getPayRule whistle.vase://getPayRule 其他用法 禁用缓存 https://www.test.cn cache://no-store 禁用缓存 https://www.test.cn cache://no-store 模拟5秒超时后网络不通 https://www.test.cn/newBillsQry/getNewBills reqDelay://5000 enable://abort 响应延时3秒 https://www.test.cn/newBillsQry/getNewBills resDelay://3000 修改响应码或模拟HTTP状态码异常 https://www.test.cn/newBillsQry/getNewBills statusCode://502 模拟低网速传输 https://www.test.cn/newBillsQry/getNewBills resSpeed://3 往页面插入脚本会在网页最后以 script 标签的形式插入，花括号的值是内置编辑器保存的文件，在主菜单 “Value” 下可找到或者是指定的文件https://www.test.cn/index.html js://{test.js} 或 js://C:\Users\Administrator\Desktop\test.js 往页面插入样式在网页里以 style 标签的形式插入https://www.test.cn/index.html css://{test.css} 或 css://C:\Users\Administrator\Desktop\test.css 配置代理非vue项目123456789101112131415161718192021222324252627282930313233# Rules1 线上资源文件指向本地https://www.test.cn/flow/js/recharge/recharge.js file://F:\flow\js\recharge\recharge.jshttps://www.test.cn/flow file://F:flow excludeFilter:///publicClient.*/i# Rules2 页面注入VConsole 需安装插件 npm i -g whistle.inspecthttps://www.test.cn/flow/detail.html whistle.inspect://# Rules3 页面注入eruda 需安装插件 npm i -g whistle.inspecthttps://www.test.cn/flow/detail.html whistle.inspect://e# Rules4 使用mock修改响应体 需全局安装 npm i -g whistle.vase# 打开http://vase.local.whistlejs.com 添加要修改的接口响应然后修改https://www.test.cn/flow/getPayRule vase://getPayRule# 若whistle.vase版本为'1.0.1'及以下使用以下方式https://www.test.cn/flow/getPayRule whistle.vase://getPayRule# Rules5 注入weinre 调试样式或查看布局https://www.test.cn/flow/addRecord.html weinre://addRecord# 禁用缓存https://www.test.cn/flow cache://no-store# 模拟 10 秒超时后网络不通https://www.test.cn/flow/getNewBills reqDelay://5000 enable://abort# 模拟接口响应延时https://www.test.cn/flow/getNewBills resDelay://3000# 模拟接口异常 HTTP状态码https://www.test.cn/flow/getNewBills statusCode://502# 模拟低网速传输https://www.test.cn/flow/getNewBills resSpeed://3 配置代理vue项目123456789101112131415161718192021222324252627282930313233343536373839# 方法一 用本地修改的代码打包后 再用打包后文件替换线上文件https://www.test.cn/flow F:\flow\build# 方法二 启动本地vue项目 将线上目录替换成本地npm run dev后的路径https://www.test.cn/flow/ 192.168.5.16:8787/ includeFilter:///\.js/ excludeFilter:///.*flow.*/https://www.test.cn/flow/ 192.168.5.16:8787/https://www.test.cn/find/ 192.168.5.16:8787/find/https://www.test.cn/public/ 192.168.5.16:8787/public/^https://www.test.cn/*.js 192.168.5.16:8787/$1.js# Rules2 页面注入VConsole 需安装插件 npm i -g whistle.inspecthttps://www.test.cn/flow/detail.html whistle.inspect://# Rules3 页面注入eruda 需安装插件 npm i -g whistle.inspecthttps://www.test.cn/flow/detail.html whistle.inspect://e# Rules4 使用mock修改响应体 需全局安装 npm i -g whistle.vase# 打开http://vase.local.whistlejs.com 添加要修改的接口响应然后修改https://www.test.cn/flow/getPayRule vase://getPayRule# 若whistle.vase版本为'1.0.1'及以下使用以下方式https://www.test.cn/flow/getPayRule whistle.vase://getPayRule# Rules5 注入weinre 调试样式或查看布局https://www.test.cn/flow/addRecord.html weinre://addRecord# 禁用缓存https://www.test.cn/flow cache://no-store# 模拟 10 秒超时后网络不通https://www.test.cn/flow/getNewBills reqDelay://5000 enable://abort# 模拟接口响应延时https://www.test.cn/flow/getNewBills resDelay://3000# 模拟接口异常 HTTP状态码https://www.test.cn/flow/getNewBills statusCode://502# 模拟低网速传输https://www.test.cn/flow/getNewBills resSpeed://3 参考链接H5 移动调试全攻略关于whistle · GitBook]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react初体验]]></title>
    <url>%2Freact%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[React是Facebook在2013年5月推出的开源的函数式编程的前端框架，用于构建用户界面的。拥有较高的性能，声明式设计（采用声明范式）、高效、灵活、JSX语法、组件、单向响应的数据流等特点，已经成为Web开发的主流框架。JSX是JavaScript中的一种语法扩展，类似于XML格式的语言。 React简介 Facebook在 2013年5月 推出的开源的函数式编程的前端框架 React开发环境的搭建 npm i create-react-app -g 全局安装Create-react-app脚手架 create-react-app my-app 使用脚手架初始化项目 cd my-app 进入工程目录 npm start 启动项目 npm run build 打包项目 npm run eject 将webpack等配置显示出来便于自定义修改 组件化理解 组件的封装：封装视图、数据、变化逻辑 组件的复用：、props传递、复用 JSX本质是什么JSX是语法糖, 需要被解析成JS才能运行, 核心方法是 React.createElement()函数 React基础 react 双向绑定 和 插值用 {} {this.state.inputValue} react 实现类似双向绑定是 state或props发生改变, render函数就会重新执行 1234567891011121314151617181920212223242526272829303132333435363738// 受控组件 form表单元素 value受 state 控制 只能通过 setState 修改import React, &#123; Component &#125; from 'react'class Todo extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; inputValue: '' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.changeInput.bind(this)&#125; /&gt; &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt; &lt;/div&gt; ) &#125; changeInput(e)&#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125;&#125;// 非受控组件 通过 ref 控制 表单元素值不受state控制import React, &#123; Component &#125; from 'react'class Todo extends Component &#123; //需要状态时，需要构造函数 constructor(props)&#123; super(props) &#125; render()&#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; ref=&#123;(textInput) =&gt; &#123;this.textInput = textInput&#125;&#125; /&gt; &lt;div&gt;&#123;this.textInput&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default Todo 事件绑定 onClick 事件名大写 JSX使用变量 {变量} 1&lt;button onClick=&#123;this.btnHandle.bind(this)&#125; &gt;提交&lt;/button&gt; props 属性 组将像一个函数，接受特定得输出，但不能修改 state 状态 组件内部得数据，可以动态改变 this.setState()更新state得唯一路径 注释 1234&#123; //todolist deomo 注释方法一 单行注释必须换行写&#125;&#123;/* todolistdemo 注释方法二 */&#125; Fragment 占位符不会在页面中渲染出来 1234import React, &#123;Fragment&#125; from 'react'&lt;Fragment&gt; &lt;div className="box" ref = 'box'&gt;&lt;/div&gt;&lt;/Fragment&gt; 不能使用class定义类名 class必须写成className 1&lt;input className = "input" /&gt; style样式 1&lt;p style="&#123;&#123;fontSize:'40px', color:'blue'&#125;&#125;"&gt; 展示html标签 123 &lt;li dangerouslySetInnerHTML = &#123;&#123;__html: item&#125;&#125;&gt;&lt;/li&gt; 使用htmlFor代替label中的for 12&lt;label htmlFor="ipt"&gt;关联input&lt;/label&gt;&lt;input id = "ipt" className = "input" /&gt; 组件使用及父子组件传值 1234567891011121314151617181920212223/* 父组件 */// 引入import TodoItemList from './TodoItemList'// 使用 传值&lt;TodoItemList list = &#123;this.state.list&#125; deleteItem = &#123;this.handleItem.bind(this)&#125;/&gt;/* 子组件 */// props 接收父组件属性传入的值render () &#123; return ( &lt;ul&gt; &#123; this.props.list.map((item, index) =&gt; &#123; return &lt;li onClick = &#123;this.handleItem.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; )&#125;handleItem (index) &#123; // 调用父组件方法 this.props.deleteItem(index)&#125; context 提供了在组件中共享值得方法 不必通过props单向传递 123456789101112131415161718192021222324252627282930313233343536373839// theme-context.js 创建context对象import React from 'react'const ThemeContext = React.createContext()export default ThemeContext// app.jsimport ThemeContext from './theme-context'import ThemeBar from './component/ThemeBar'const themes = &#123; light: &#123; className: 'btn btn-primary', bgColor: '#333333'&#125;, dark: &#123; className: 'btn btn-light', bgColor: '#eeeeee'&#125;&#125;// 使用 ThemeContext.Provider 包裹&lt;ThemeContext.Provider value=&#123;themes[this.state.theme]&#125;&gt; &lt;button className="btn btn-light" onClick=&#123;() =&gt; &#123; this.setState(&#123;theme: 'light'&#125;)&#125;&#125; &gt;浅色主题&lt;/button&gt; &lt;button className="btn btn-secondary" onClick=&#123;() =&gt; &#123; this.setState(&#123;theme: 'dark'&#125;)&#125;&#125; &gt;深色主题&lt;/button&gt; &lt;ThemeBar /&gt;&lt;/ThemeContext.Provider&gt;// ThemeBar.jsimport React from 'react'import ThemeContext from '../theme-context';const ThemeBar = () =&gt; &#123; return ( &lt;ThemeContext.Consumer&gt; &#123; theme =&gt; &#123; return ( &lt;div className="alert mt-5" style=&#123;&#123;backgroundColor:theme.bgColor,color:theme.color&#125;&#125;&gt; &lt;p&gt;样式区域&lt;/p&gt; &lt;button className=&#123;theme.className&#125;&gt;样式按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; &lt;/ThemeContext.Consumer&gt; )&#125;export default ThemeBar 无状态组件(函数组件):只根据props渲染页面，没有内部的state,只有render函数 它就是一个函数 无状态组件性能高 123456789101112131415161718import React from 'react'import &#123; Input, Button, List &#125; from 'antd';const TodoListUI = (props) =&gt; &#123; return ( &lt;div className="todo"&gt; &lt;div className="input-box"&gt; &lt;Input placeholder="Basic usage" value=&#123; props.inputValue &#125; onChange=&#123; props.InpuChange &#125;/&gt; &lt;Button type="primary" onClick=&#123; props.buttonClick &#125;&gt;todo&lt;/Button&gt; &lt;/div&gt; &lt;List size="small" bordered dataSource=&#123; props.list &#125; renderItem=&#123; (item,index) =&gt; &lt;List.Item onClick=&#123;() =&gt; &#123; props.itemDeleteHandle(index)&#125;&#125;&gt;&#123; item &#125;&lt;/List.Item&gt; &#125; /&gt; &lt;/div&gt; )&#125;export default TodoListUI props类型检查与默认值Typechecking With PropTypes – React 1234567891011import PropTypes from 'prop-types'// 类型校验MyComponent.propTypes = &#123; list: PropTypes.oneofType([Proptypes.array, Proptypes.string]), deleteItem: PropTypes.func, test: PropTypes.string.isRequired&#125;// 默认值MyComponent.defaultProps = &#123; test: 'test'&#125; props,state与render函数的关系 12// 1. 当组件的state或者props发生改变时, render函数就会重新执行// 2. 当父组件的render函数被执行时, 它的子组件的render都将被重新执行 虚拟DOM 虚拟DOM就是一个JS对象, 用它来描述真实的DOM 优点:1. 大大的提升了性能(减少了真实DOM的创建与对比,虚拟DOM创建的是js对象)2. 它使得跨端应用得以实现. React Native1234567891011121314151617181920212223242526// JSX --&gt; createElement --&gt; 虚拟DOM(JS对象) --&gt; 真实DOM// 虚拟DOM中的Diff算法 虚拟DOM同层比对 DOM key值相同比对真实DOM/*1. state数据2. JSX 模板3. 数据 + 模板 结合, 生成真实的DOM 来显示4. state 发生改变5. 数据 + 模板 结合生成真实的DOM, 替换原始的DOM缺陷: 第一次生成完整DOM 第二次生成完整DOM 用第二次DOM替换第一次DOM, 非常耗性能*/虚拟DOM/*1. state 数据2. JSX 模板3. 数据 + 模板生成虚拟DOM['div', &#123;id: 'test'&#125;, ['span', &#123;&#125; ,'hello world']]4. 用虚拟DOM的结构生成真实的DOM,来显示&lt;div id="test"&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;5. state 发生变化6. 数据 + 模板生成新的虚拟DOM['div', &#123;id: 'test'&#125;, ['span', &#123;&#125; ,'hi react']]7. 比较原始虚拟DOM和新的虚拟DOM区别, 找到区别是span中的内容变化8. 直接操作DOM, 改变span中的内容*/ ref的使用 获取DOM元素 123456// ref 是箭头函数 this.input 指向 input DOM对象// setState是异步函数 在获取DOM对象会有问题&lt;input ref = &#123;(input) =&gt; &#123;this.input = input&#125;&#125; /&gt;this.setState(&#123; inputValue: this.input.value&#125;) setState是异步函数 第二个参数解决 异步导致DOM获取问题已经数值更新后的操作 123456this.setState(prevState =&gt; (&#123; list: [...this.state.list,this.state.inputValue], inputValue: ''&#125;), () =&gt; &#123; console.log(this.ul.querySelectorAll('div').length)&#125;) setState为何需要异步以及过程 123// 1. 可能会一次执行多次setState操作// 2. 没必要每次setState都重新渲染,考虑性能// 3. 无法规定 限制用户如何使用setState React 生命周期函数生命周期函数是指在某一时刻组件会自动调用执行的函数Mountting阶段componentWillMount: 组件即将被挂载(render)到页面的时刻自动执行(第一次挂载执行)componentDidMount: 组件在被挂载(render)到页面之后自动执行render之后(第一次挂载执行)Updation阶段更新的三种情形： New props setState() fourceUpdateshouldComponentUpdate: 组件被更新之前自动执行,是否需要更新,必须返回布尔值componentWillUpdate: 组件在被更新之前自动执行,但它在shouldComponentUpdate之后执行,如果shouldComponentUpdate返回true它才会执行,如果返回false,它不会执行componentDidUpdate: 组件更新完成之后自动执行 (React更新DOM和refs会触发)componentWillReceiveProps: 组件接收参数之前自动执行,需要满足两个条件,子组件要从父组件接收参数,且子组件以前已经存在于父组件中,才会执行,不能是第一次存在UnmounttingcomponentWillUnmount: 当这个组件即将被从页面中剔除(卸载)的时候,自动执行12345678910// 当父组件的render函数被执行时, 它的子组件的render都将被重新执行// shouldComponentUpdate 避免子组件无谓的render渲染shouldComponentUpdate (nextProps, nextState) &#123; console.log(nextProps) if (nextProps.list !== this.props.list) &#123; return true &#125; else &#123; return false &#125;&#125; PureComponent 定制了shouldComponentUpdate后的Component(浅比较) react 性能优化 123456789// 1. this的绑定放在constructor里面constructor (props) &#123; super(props) this.handleButton = this.handleButton.bind(this)&#125;// 2. setState异步函数将多次数据改变结合成一次执行// 3. 虚拟DOM同层匹配 diff算法// 4. 使用shouldComponentUpdate避免子组件无谓的render渲染// 5. ajax最好放在componentDidMount中 安装React Developer Tools chrome调试工具 调试react应用 React 动画 使用react-transition-group实现动画 npm i react-transition-group -S 使用CSSTransition实现单个元素过渡 123456789101112131415161718192021import &#123; CSSTransition &#125; from 'react-transition-group'// in 控制变量 timeout 时长 classNames 自定义class前缀 test-enter// unmountOnExit 是否隐藏dom appear 是否首次也应用过渡// onEntered 过渡完成事件&lt;CSSTransition in=&#123;this.state.status&#125; timeout=&#123;1000&#125; classNames="test" unmountOnExit appear=&#123;true&#125; onEntered=&#123;(el)=&gt;&#123; el.style.color = "blue"&#125;&#125;&gt; &lt;p&gt;过渡&#123;this.state.status?'显示':'隐藏'&#125;&lt;/p&gt;&lt;/CSSTransition&gt;// transition.css.test-enter, .test-appear&#123; opacity: 0; &#125;.test-enter-active,.test-appear-active&#123; opacity: 1;transition: opacity 1s ease-in&#125;.test-enter-done&#123; opacity: 1;&#125;.test-exit&#123; opacity: 1; &#125;.test-exit-active&#123; opacity: 0;transition: opacity 1s ease-in &#125;.test-exit-done&#123; opacity: 0; &#125; 使用TransitionGroup + CSSTransition 实现一组或多个元素过渡 12345678910111213141516171819import &#123; CSSTransition, TransitionGroup &#125; from 'react-transition-group'&lt;TransitionGroup&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;CSSTransition timeout=&#123;1000&#125; classNames="test" unmountOnExit appear=&#123;true&#125; key=&#123;index&#125; onEntered=&#123;(el)=&gt;&#123; el.style.color = "blue"&#125;&#125; &gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt; &lt;/CSSTransition&gt; ) &#125;) &#125;&lt;/TransitionGroup&gt; React和Vue有何异同 本质区别 Vue是MVVM框架 React是前端组件化框架 模板的区别 Vue使用模板 React使用JSX 共同点 都支持组件化 都是以数据驱动视图 react 路由 安装 npm i react-router-dom123456789// 引入import &#123; BrowserRouter, Route &#125; from 'react-router-dom'// 使用 exact path必须相等 Route必须用元素包裹&lt;BrowserRouter&gt; &lt;div&gt; &lt;Route path="/" exact component=&#123; Home &#125;&gt;&lt;/Route&gt; &lt;Route path="/detail" exact component=&#123; Detail &#125;&gt;&lt;/Route&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 异步组件 react-loadable withRouter模块热更新 react-hot-loaderReact 服务端渲染]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid网格布局]]></title>
    <url>%2Fgrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Grid网格布局擅长于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系（前提是HTML生成了这些区域）。像表格一样，网格布局让我们能够按行或列来对齐元素。 然而在布局上，网格比表格更可能做到或更简单。 例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次。 Grid VS Flexbox Flexbox是一维布局,只能在一条直线上放置内容区块,只能指定内容区块针对轴线的位置 Grid是二维布局,将容器划分成行和列,产生单元格,根据设计需求将内容区块放置到单元格中 基本概念 网格容器: 元素应用display：grid; 它是其所有网格项的父元素网格项：网格容器的子元素，下面的item元素就是网格项网格线：组成网格项的分界线网格单元：两个相邻的列网格线和两个相邻的行网格线组成网格单元fr(单位): 剩余空间的分配数，表示比例关系 1234567891011&lt;div class="container"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; display: grid;&#125;&lt;/style&gt; 容器属性 容器属性: Grid布局定义在容器上面，称为容器属性 display属性 1234display:grid|inline-grid|subgriddisplay:grid 生成块级网格display:inline-grid 生成行内网格注：当元素设置了网格布局，column，float，clear，vertical-align等设置失效` grid-template-columns/grid-template-rows属性 12345678使用空格分隔的值列表，用来定义网格的列和行grid-template-columns:[line-name,] &lt;track-size&gt; 定义每一列的列宽grid-template-rows:[line-name,] &lt;track-size&gt; 定义每一行的高度&lt;track-size&gt;: 可以是长度值，百分比，fr单位或者关键字&lt;line-name&gt;: 网格线名称&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt; 项目属性 项目属性: Grid布局定义在项目上面，称为项目属性 参考地址网格布局 - CSS(层叠样式表)CSS Grid 网格布局教程Grid布局基础]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用代码片段]]></title>
    <url>%2Fjavascript%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[为了避免重复性劳动,日常开发中总会有哪些你曾经使用的过或者从各网站博客中找到一些特别有用的代码片段, 亦或者是某些比较好的能简化代码的片段. 在工作中,或者查看别人的代码时,总能看到一些不一样的处理方式,或者某些大神或前辈对同样的问题有更简单实用的使用方式. JavaScript中!!操作符是什么!!强制把右侧的值转化为布尔值 1234console.log(!!10) //trueconsole.log(!!0) //falseconsole.log(!!"abc") //trueconsole.log(!!"") //false JavaScript字符与ASCII码间的转换 12console.log("abc".charCodeAt(0)) // 97console.log(String.fromCharCode(97)) // a 判断一个对象是否为数组的最好方式 1234function isArray(obj)&#123; return Object.prototype.toString.call(obj) == "[object Array]";&#125;// 不能用instanceof 和 constructor来判断 取数组中的最大值/最小值 1234var arr = [100, 50, 30]var min = Math.min.apply(null, arr), max = Math.max.apply(null, arr);console.log(min, max) // 30 100 统计一个字符串中某个字符出现的次数 12var temp = "This is a string."var count = temp.match(/is/g).length // 2 把arguments/NodeList转换为Array 12var args = Array.prototype.slice.call(arguments, 0)var args = Array.form(arguments) 检查是否包含子元素const elementContains = (parent, child) =&gt; parent !== child &amp;&amp; parent.contains(child) 检测移动/PC设备 123export const detectDeviceType = () =&gt; &#123; return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop'&#125; 转义html(防XSS攻击) 12345export const escapeHTML = str =&gt;&#123; str.replace( /[&amp;&lt;&gt;'"]/g, tag =&gt;(&#123; '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', "'": '&amp;#39;', '"': '&amp;quot;' &#125;[tag] || tag))&#125; 判断js运行环境 123456789101112131415const inBrowser = typeof window !== 'undefined'const inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platformconst weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase()const UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase()const isIE = UA &amp;&amp; /msie|trident/.test(UA)const isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0const isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0const isAndroid = (UA &amp;&amp; UA.indexOf('android') &gt; 0) || (weexPlatform === 'android')const isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios')const isChrome = UA &amp;&amp; /chrome\/\d+/.test(UA) &amp;&amp; !isEdgeconst isPhantomJS = UA &amp;&amp; /phantomjs/.test(UA)const isFF = UA &amp;&amp; UA.match(/firefox\/(\d+)/)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb和moogoose]]></title>
    <url>%2Fmongoose%2F</url>
    <content type="text"><![CDATA[MongoDB是一个基于分布式文件存储的数据库。MongoDB 是一个介于关系数据库和非关系数据库之间的产品。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB支持丰富的查询语言，以支持读写操作（CRUD）,具有高可用性, 支持多种存储引擎。 mongodb 安装mongodb 安装官网下载地址 安装可视化管理工具Studio 3T或Robo 3T 配置环境变量在path变量中添加mongodb\bin所在路径 mongodb 使用 which mongod 查看mongodb安装路径 mongod 启动服务 验证是否成功 在浏览器地址栏输入 127.0.0.1:27017 ，出现以下界面则说明环境已配好。It looks like you are trying to access MongoDB over HTTP on the native driver port. 使用mongoDB客户端进入安装目录执行 mongo.exe文件 打开命令行界面执行 mongoDB操作如 show dbs 查看所有数据库 使用MongoDB可视化工具Studio 3T安装完成启动Studio 3T 类似navigat 点击Connect创建连接后, 就可以看到初始的三个数据库 在新建的connect上右键即可创建数据库(Add Database)、在数据库上右键创建数据表(Add Collection)等 点击 Open intelliShell 可以执行CRUD增删改差操作 mongoDB常用操作 插入一条数据: db.表名.insertOne({ name: &#39;tew&#39;, sex: 1}) 插入多条数据: db.表名.insertMany([{ name: &#39;tew&#39;, sex: 1}, { name: &#39;tew&#39;, sex: 1}]) 查询所有: db.表名.find()，相当于：SELECT * FROM table_name 按条件查询: db.表名.find({ke:value})，相当于SELECT * FROM 表名 WHERE name = ? 更新单个数据 db.表名.updateOne() 删除所有数据 db.表名.deleteMany() 删除与条件匹配的数据 db.表名.deleteMany() 使用moogoosemoogoose官网教程 安装 npm i mongoose 定义schema，Mongoose里，一切都始于Schema,每个schema都会映射到一个 MongoDB collection(表)1234567891011121314151617181920212223const mongoose = require('mongoose')// 连接数据库mongoose.connect('mongodb://localhost/dbs', &#123;useNewUrlParser:true, useUnifiedTopology: true&#125;)let personSchema = new mongoose.Schema(&#123; // 表 name: String, // 字段 age: Number // 字段&#125;)const Person = mongoose.model('Person', personSchema) // 创建模型app.use('/addPerson', async (ctx) =&gt; &#123; const person = new Person(&#123; // 实例化model模型 name: 'tew', age: 29 &#125;) try &#123; await person.save() // 保存到数据库 code = 0 &#125; catch (error) &#123; code = -1 &#125; ctx.body = &#123; code &#125;&#125;) 参考链接Windows下MongoDB的下载安装、环境配置 - chenhongyong - 博客园MongoDB可视化工具Studio 3T的使用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[移动端的开发由于设备的不统一会造成一些兼容性问题，经常会困扰许多web前端开发者，自从接触移动端以来也遇到过很多问题，低端机性能差容易卡顿，h5和css3新的api在低版本兼容性差等。 资源的合并与压缩 减少http请求数量 减少请求资源的大小 html代码压缩就是压缩在这些文本文件中有意义,但是在HTML中不显示的字符,包括空格,制表符,换行符,HTML注释等. css压缩 删除无效代码 css语义合并 Js压缩与混乱 删除无效字符的删除 删除注释 代码语义缩减和优化 使用在线网站进行压缩 使用构建工具进行压缩fis3,gulp,webpack,grunt等 使用clean-css对css进行压缩,html-minifier对html进行压缩,uglifyjs2对js进行压缩.文件合并 使用在线网站进行文件合并 使用nodejs实现文件合并 图片相关的优化 采用雪碧图 将多个小图片整合到一张单独的图片中 减少网站的http请求数量 使用Compass生成雪碧图 使用base64字符 使用svg绘制矢量图 使用iconfont等字体图标 在android中使用webp格式(ios webview中有兼容性问题) 可以使用构建工具或在线网站将png转换成webp格式 对图片进行压缩常用 TinyPNG 或 智图 懒加载和预加载 懒加载 &nbsp;&nbsp; 图片进入可视区域之后再请求图片资源1234567891011121314&lt;!-- 引入所需js --&gt;&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jquery.lazyload.js"&gt;&lt;/script&gt;&lt;!-- 将图片地址放在data-original属性上 给图片添加class(lazy) --&gt;&lt;img class="lazy" alt="" width="640" height="480" data-original="img/example.jpg" /&gt;&lt;script&gt;$("img.lazy").lazyload(&#123; placeholder : "img/grey.gif", //用默认图片提前占位 effect: "fadeIn", // 载入使用何种效果 threshold: 200, // 提前开始加载 event: 'click', // 事件触发时才加载 container: $("#container"), // 对某容器中的图片实现效果&#125;);&lt;/script&gt; 预加载 &nbsp;&nbsp; `图片等静态资源在使用之前的提前请求preload.js 1234567891011121314&lt;img src="xxx.jpg" alt="" style='display:none' /&gt;&lt;!-- 或者使用preload.js --&gt;&lt;script src="../preload.js"&gt;&lt;/script&gt;&lt;script&gt;var queue = new createjs.LoadQueue(false); queue.on("complete", handleComplete, this); queue.loadManifest([ &#123;id: "myImage", src:"path/to/myImage.jpg"&#125; ]); function handleComplete() &#123; var image = queue.getResult("myImage"); document.body.appendChild(image); &#125;&lt;/script&gt; 减少浏览器重绘与回流 回流或重排（Reflow） 当render tree中的一部分或全部因为元素的大小尺寸,布局,隐藏等改变而需要重新构建 当页面布局和几何属性改变时就需要回流 位置发生变化 增加、修改、删除DOM节点等 重绘（Repaint） 当render tree中的一些元素需要更新属性,而这些属性只是影响元素的外观,风格,而不会影响布局如(background-color)变化 位置不发生改变 注:回流必将引起重绘,但重绘不一定能引起回流 回流何时发生: 页面布局和几何属性改变时,如: 添加或删除可见的DOM元素, 元素位置改变, 元素尺寸改变, 浏览器窗口尺寸改变 减少重绘与回流的方式 用translate替代left,top等位置的改变 (不会触发layout) 用opacity替代visibility 不要一条条地修改DOM样式,预先定义好class,然后修改DOM的className 把DOM离线后修改,比如: 先把DOM给display:none 修改后再显示出来 启用GPU硬件加速 transform:translateZ(0)或translate3D(0,0,0) 浏览器存储 cookie 作为浏览器存储 大小4kb左右 需要设置过期时间expire localStorage 专门用于浏览器本地缓存 sessionStorage 会话级别的浏览器存储 可用于表单信息的维护 IndexedDB 用于客户端存储大量结构化数据 为应用创建离线版本 PWA (Progressive Web App) 渐进式的Web App 在没有网络的环境中也能提供基本的页面访问 不会出现”未连接到互联网”的页面 针对网页渲染及网络数据访问有较好优化 应用可以被添加到手机桌面，和普通应用一样有全屏，推送等特性 性能检测及pwa检测lighthouse Service Workers 是独立于当前页面的一段运行在浏览器后台进程里的脚本。具有拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。查看service-workers chrome://inspect/#service-workers或chrome://serviceworker-internals 缓存客户端和浏览器协商缓存 http header缓存 浏览器通过请求头 Cache-Control 来控制是否使用缓存资源，通过 ETag 来验证缓存是否可用 对于不想缓存的资源，可以使用no-store(不存储)，no-cache(不使用浏览器缓存) 对于想缓存的资源, 使用max-age来控制缓存的寿命(单位秒),只要缓存在有效期内, 那么浏览器就会使用缓存的资源, 返回的状态为 200 from disk或200 from memory 指定文件被缓存多久 如果缓存已过期, 客户端发起请求时, 会携带一个If-None-Match头给服务器, 服务器对资源的缓存进行一次检索, 如果文件没有改变, 那么就返回304, 这样就不用把响应体发送回来, 如果文件改动了, 那么就把新资源返回 强缓存 Cache-Control 相对时间内 相对于客户端 http1.1引入Cache-Controlmax-age(缓存最大有效时间) 指定文件被缓存多久s-maxage(缓存最大有效时间， 只针对public(CDN)，读取CDN缓存) 优先级高于max-ageprivate(访问当前浏览器的用户可访问)public(可以被很多用户访问例如CDN)no-cache(不会从浏览器读缓存，发请求到服务器端去判断缓存有效期)no-store(不使用任何缓存策略) expires 服务器返回的绝对时间 可能与本地客户端时间不一致缓存过期时间，用来指定资源到期时间，是服务器端的具体的时间点，告诉浏览器在过期时间内浏览器可以直接从浏览器缓存,读取文件数据，而无需再次请求。当两者都存在时，cache-control:max-age优先级高于expires, 是http1.0特性, expires使用特定的服务器时间,要求服务器和客户端严格同步,如果服务器设置的时间到期需要重新设置Expires 和Cache-Control max-age.如果两者同时出现，HTTP规范规定max-age指令将覆盖Expires头。以Cache-Control:max-age=xxx时间为准 协商缓存 last-Modified/If-Modified-Since 基于客户端和服务端协商的缓存机制 需要与cache-control共同使用last-Modified 存在于 response header中If-Modified-Since 存在于 request header中服务端文件有更新时，服务器端在response header中返回新的last-Modified,告诉浏览器文件已更新 Etag/If-None-Match 文件内容hash值 需要与cache-control共同使用Etag 存在于 response header中If-None-Match 存在于 request header中 Etag 优先级高于 last-Modified Vue-SSR 服务端渲染SSR(Server Side Readering) 其他 window.performance.timing 监控页面加载速度的api 服务器相关优化 开启gzip压缩 12345678910gzip on; # 开启Gzipgzip_static on; # 开启静态文件压缩gzip_min_length 1k; # 不压缩临界值，大于1K的才压缩gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml application/xml+rss; # 进行压缩的文件类型gzip_vary on;gzip_proxied expired no-cache no-store private auth;gzip_disable "MSIE [1-6]\."; 开启HTTP2—一个域只建立一次TCP连接，请求和响应的多路复用、头部压缩使用http2需要配合https使用, 使用https需要ca证书 阿里云https证书购买 (有免费的ca证书) 开启缓存]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域解决方案]]></title>
    <url>%2F%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[出于浏览器的同源策略限制会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）,在出现协议（protocol），主机（host）和端口号（port）有一种不一致时，就会出现跨域。在前后台交互中，ajax请求的url不是同一个服务器下面的URI，就会出现跨域请求问题。由于安全性的问题，浏览器默认不支持跨域调用. 同源策略仅限于浏览器 跨域请求是可以发出去的但是响应response被浏览器堵塞了协议 域名 端口号 一致即是 同域三者有一个不同就是跨域http:// www. baidu.com : 8080 / index.html协议 子域名 主域名 端口号 请求资源地址当协议,子域名,主域名,端口号,中任意一个不相同时,都算作不同域不同域之间的相互请求资源,就算作跨域Javascript 出于安全方面的考虑,不允许跨域调用其他页面的对象。跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致例如http://www.example.com/ http://api.example.com/detail.html 不同源 域名不同 https//www.example.com/detail.html 不同源 协议不同 http://www.example.com:8080/detail.html 不同源 端口不同 http://api.example.com:8080/detail.html 不同源 域名、端口不同 https://api.example.com/detail.html 不同源 协议、域名不同 https://www.example.com:8080/detail.html 不同源 端口、协议不同 http://www.example.com/detail/index.html 同源 只是目录不同 为什么浏览器不支持跨域cookie localStorage IndexedDB 同源策略不支持跨域DOM元素也有同源策略 iframeajax也不支持跨域 不存在跨域请求的限制 script img link 实现跨域的方式jsonp、cors、nginx、http-proxy、postMessage、doucment.domain、window.name、location.hash、websocket等 jsonp 只能处理get请求 不支持post put delete 不安全(xss攻击 ) 前端通过script标签请求指定URL，服务器返回一个函数执行语句，函数名称由查询参callback的值决定，函数的参数为服务器返回的json数据，该函数在前端执行后即可获得数据 jsonp中cb每次都要不同 JSONP原理是通过&lt;script&gt;标签的src来帮助我们请求不同域的数据.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function express() &#123; jsonp(&#123; url: 'http://localhost:3000/say', params: &#123;wd:'a',json:1&#125;, cb:'show' &#125;).then(data=&gt;&#123; console.log(data) &#125;)&#125;express()function jsonp(&#123;url,params,cb&#125;) &#123; return new Promise((resolve,reject)=&gt;&#123; let script = document.createElement('script') window[cb]=function(data)&#123; resolve(data) document.body.removeChild(script) &#125; params = &#123;...params,cb&#125; let arrs = [] for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;&lt;/script&gt;&lt;!-- 服务端处理 --&gt;let express = require('express')let app = express()app.get('/say',function(req,res)&#123; let &#123;wd,cb&#125;=req.query console.log(wd) res.end(`$&#123;cb&#125;('44444')`)&#125;)app.listen(3000) cors跨域资源共享 CORS(Cross Origin Resoure Share)跨域资源共享，后端方案解决跨域，需要服务器对请求进行检查并设置对响应头做相应处理，从而允许跨域请求 响应简单请求：method为’get/post/head’,没有自定义请求头，Content-Type是application/www-form/urlencoded,multipart/form-data或text/plain,通过添加响应头解决res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)或res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://xxx:xx&#39;) 允许任意网站请求数据或者允许指定的域名访问 响应preflight请求，需要响应浏览器发出的options请求(预检请求)，根据情况设置响应头1234567891011// 服务器 忽略options请求if(req.method == 'options') &#123; res.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://localhost:3000', 'Access-Control-Allow-Headers':'x-Token', 'Access-Control-Allow-Methods': 'PUT' &#125;) res.end()&#125;// 客户端请求axios.get('http://localhost:3000/user', &#123; headers: &#123;'x-token': 'tew'&#125; &#125;) 如果需要携带cookie信息，则请求变为credential请求res.setHeader(&#39;Access-Control-Allow-Credentials&#39;,true) //允许携带cookie 客户端发送请求(ajax/fetch) 1234567891011121314// index.html 请求接口var xhr = new XMLHttpRequest;document.cookie = 'name=tew'xhr.withCredentials = true//xhr.open('GET','http://localhost:4000/say',true);xhr.open('DELETE','http://localhost:4000/say',true);xhr.setRequestHeader('name', 'tew')xhr.onreadystatechange=function() &#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; console.log(xhr.response) console.log(xhr.getResponseHeader('name')) &#125;&#125;xhr.send() 服务端设置相关的头信息 1234567891011121314151617181920212223242526272829303132333435363738let express = require('express')let app = express()let whiteList = ['http://localhost:3000']app.use(function(req,res,next)&#123; let origin = req.headers.origin; if(whiteList.includes(origin)) &#123; // 设置哪个域名可以访问 res.setHeader('Access-Control-Allow-Origin',origin) // 设置哪个请求头可以访问 res.setHeader('Access-Control-Allow-Headers','name') // 设置哪个请求方法可以访问 res.setHeader('Access-Control-Allow-Methods','DELETE') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials',true) // options存活的时间 res.setHeader('Access-Control-Max-Age',6000) // 允许前端获取的响应头 res.setHeader('Access-Control-Expose-Headers','name') // 忽略options请求 if(req.method =='options') &#123; res.end() &#125; &#125; next()&#125;)app.delete('/say',(req,res)=&gt;&#123; console.log(req.headers) console.log(req.headers.name) console.log(req.headers.cookie) res.setHeader('name','yn') res.end('66666')&#125;)app.get('/say',(req,res)=&gt;&#123; console.log(req.headers) console.log(req.headers.name) res.end('66666')&#125;)app.listen(4000) nginxhttp-proxy 代理 实现跨域请求 请求同源服务器，通过该服务器转发请求至目标服务器，得到结果再转发给前端，前端开发中测试服务器的代理功能(例如webpack的proxy)就是采用的该方案， 但是最终发布上线时入股web应用和接口服务器不在一个域仍会跨域webpack-dev-server中的proxyTable1234567891011proxy: &#123; '/api': &#123; target: 'https://www.xxx.com', changeOrigin: true, pathRewrite: &#123; '/api': '' &#125; &#125;&#125;// 接口访问 http://localohost/api/getNews?page=1&amp;pageSize=10// 经过代理后实际访问 https://www.xxx.com/getNews?page=1&amp;pageSize=10 postMessage HTML5提供跨文档通信API(Cross-docuemnt messaging),该API为window对象新增window.postMessage方法，允许跨窗口通信12345678910111213141516171819202122232425262728293031&lt;!-- 包含iframe的父窗口 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt; &lt;iframe src="http://127.0.0.1:5500/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; function load()&#123; var frame = document.getElementById('frame') // postMessage(信息内容，接收消息窗口的源(orgin:协议+域名+端口)) frame.contentWindow.postMessage('parentData','http://127.0.0.1:5500') // 发送信息 window.onmessage = function(e)&#123; //接收iframe中发送的信息 console.log(e) // MessageEvent&#123;isTrusted:true,data:'iframeData',origin:'http://127.0.0.1:5500',…&#125; console.log(e.data) // iframeData &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- iframe b.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt; &lt;div&gt;iframe&lt;/div&gt; &lt;script&gt; window.onmessage = function(e) &#123; // 使用 window.onmessage 监听 postMessage发送的信心 console.log(e.data) // parentData e.source.postMessage('iframeData',e.origin) // 向父窗口数据 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; websocketdocument.domainwindow.namelocation.hashAjax跨域请求携带COOKIE123456789101112131415161718// 原生ajax xhr.withCredentials = true; //支持跨域发送cookies// jquery$.ajax(&#123; type:'post', url:url, // 允许携带证书 xhrFields: &#123;withCredentials: true&#125;, // 允许跨域 crossDomain: true, success: function(data)&#123; // do something &#125;, error: function(data)&#123; // do something &#125;&#125;)//服务端设置header("Access-Control-Allow-Credentials: true");]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。对于开发者而言，微信小程序开发门槛相对较低，难度不及APP，能够满足简单的基础应用，适合生活服务类线下商铺以及非刚需低频应用的转换。微信小程序能够实现消息通知、线下扫码、公众号关联等七大功能。其中，通过公众号关联，用户可以实现公众号与微信小程序之间相互跳转。 小程序 VS HTML5小程序并不是 HTML5 应用，而是更偏向于传统的 CS 架构，它是基于数据驱动的模式，一切皆组件（视图组件）。下面是小程序与普通 Web App 的对比。 普通 HTML5 都是执行在浏览器的宿主环境，浏览器提供 window、document 等 BOM 对象，但小程序没有 window、document，它更像是一个类似 Node.js 的宿主环境；因此在小程序内不能使用 document.querySelector 这类 DOM 选择器，也不支持 XMLHttpRequest、location、localStorage 等这些浏览器提供的 API，只能使用小程序自己实现的 API 小程序并非是直接通过 URL 访问的，而是通过信道服务进行通信和会话管理，所以它不支持 Cookie 存储，同时访问资源使用 wx.request 则不存在跨域的问题 小程序在 JavaScript 的模块化上支持 CommonJS，通过 require 加载，跟 Node.js 类似 小程序的页面样式完全继承了 CSS 的语法，但是在选择器上面会少一些，布局支持 flex 布局 小程序的整体框架采用面向状态编程方式，状态管理从 API 来看采用类似 Redux 的设计方式；单向数据绑定方式，当 View 在 Action 操作后，只能通过 Action 的业务处理来更新 View 页面组件模块上，WXML 提供了一整套的「自定义 UI 组件标签」，有些组件实际是 HTML5 实现的，有些组件为了解决权限、性能和适配等问题实际是 Native 实现的（如 map、input、canvas、video）。 小程序目录结构小程序项目由配置文件、页面文件、静态资源和其他相关（比如组件、小程序云函数等）内容组成，一般小程序会由四类文件组成： .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 .wxss 后缀的 WXSS 样式文件 .js 后缀的 JS 脚本逻辑文件 小程序的配置小程序有三个重要的配置，分别放在三个 JSON 文件内：project.config.json（工具项目配置）、app.json（小程序配置）、page.json（单页面配置） project.config.json：这个是配置项目工具相关的，比如开发者工具的编译设置（是否使用 ES6 语法等）、界面设置，以及云函数相关的 cloudfunctionRoot，详细可以参考项目配置文件 app.json：小程序的全局配置，包括了所有页面路径、界面表现、网络超时时间、底部 tab、插件等，常用的两个配置是 window 和 pages，详细配置参考全局配置 page.json：是相对于 app.json 更细粒度的单页面配置，详细参考页面配置 组件小程序内部定义了很多组件，可以对应 HTML5 的标签和基础能力来理解，小程序的组件根据实现不同，可以分为 Web 组件和 Native 组件，Web 组件是由 HTML5 原生 Web 组件封装的组件，比如 view、image 等；Native 组件是为了增强小程序的体验，用客户端技术实现的组件，包括一些交互复杂、原生 Web 组件性能不高的组件，例如 input、map、canvas、video 等。小程序一共提供 8 大类 30 多个组件： 视图容器：主要是实现页面布局的，对常见的布局形式进行了封装，比如滚动 sroll-view 等 基本内容：类似 HTML5 中内容相关的 p、em 等 表单相关：要比 HTML5 的 form 表单丰富一些 导航：类似 a 标签 媒体：类比 HTML5 中的 video、audio 和 img 等，但是提供更标准的界面和更丰富的 API 支持 画布：Native 实现的 Canvas 地图：结合腾讯地图数据 Native 实现的组件 开放能力：这部分组件偏通用和小程序业务 自定义组件小程序本身支持很多组件，比如地图、按钮等，开发者也可以自己做项目内公共组件，比如我们后面实战部分会介绍做一个 icon 组件，放在 components 目录下面，这样此小程序的任何页面如果要使用这个 icon 公共组件，只需在自己的 page.json 中添加如下字段：123"usingComponents": &#123; "icon": "../../components/icon/index"&#125; 添加完成之后，在页面代码中就可以直接使用 &lt;icon&gt; 的 tag 了。官方文档有更加详细的介绍。 插件插件是对一组 JS 接口、自定义组件或页面的封装，用于提供给第三方小程序调用。简单来说，插件是组件的升级版本，组件只能在自己项目中使用，插件则更独立，是可以发布到全网，供其他开发者使用的。例如实战中，笔者使用了一款日历插件，则需要在 app.json 中增加 plugins 字段：123456"plugins": &#123; "calendar": &#123; "version": "1.1.3", "provider": "wx92c68dae5a8bb046" &#125;&#125; 如果想开发一个插件，则可以参考官方文档。 数据驱动微信小程序是数据驱动模型，在 WXML 中可以对页面的数据进行绑定，小程序的 WXML 内使用的是 Mustache 语法，在 {{}} 内可以将变量名包裹起来。 例如：123456&lt;view&gt;&#123;&#123; message &#125;&#125;&lt;/view&gt;Page(&#123; data: &#123; message: 'Hello MINA!' &#125;&#125;) 但是小程序不支持复杂的表达式，目前支持简单的三元、加减和逻辑判断，如果要使用形如 {{parseInt(num)}} 的函数调用语法，需要 WXS 支持：WXML 内容：12&lt;wxs src="./demo.wxs" module="tools" /&gt;&lt;view&gt;&#123;&#123; tools.toNumber(num) &#125;&#125;&lt;/view&gt; WXS 内容：12345// demo.wxsfunction toNumber(n)&#123; return parseInt(n)&#125;module.exports.toNumber = toNumber 小程序内对页面的数据修改只能通过 setData 方法，不能使用直接赋值的方式 this.data.key = value：12345678910Page(&#123; data: &#123; message: 'Hello MINA!' &#125;, onLoad()&#123; this.setData(&#123; message: 'hello world~' &#125;) &#125;&#125;) 记住：修改页面数据，只能使用 this.setData 修改！ 路由在小程序内，不能像 HTML5 中 a 标签那样，随便跳转，也不能像 location 对象中对应的属性那样随意跳转，小程序提供了对应 a 标签和 location 对象的方法：navigator 组件和 wx 中的导航相关函数。 在小程序中，路由是由路由栈来维护的，小程序的路由栈中最多维护 5 个页面，这样在 5 个页面内，小程序维护其渲染页面，可以实现快速的切换。 小程序中跳转页面可以通过下面两种方式： 使用 navigator 组件： 1&lt;navigator url="跳转页面URL" &gt;跳转到新页面&lt;/navigator&gt; 使用 wx 中的导航相关函数： 123456789&lt;view bindtap="gotoUrl"&gt;跳转页面&lt;/view&gt;Page(&#123; gotoUrl()&#123; let url = 'pages/another/url' wx.navigateTo(&#123; url &#125;) &#125;&#125;) JavaScript 的限制和增强微信内的 JavaScript 相对于浏览器中的有限制也有增强，增强的部分是基于小程序 Native 端能力做的增强，比如增强的文件操作类（相册、录音等）；除了增强，跟 HTML5 浏览器环境最大的不同是限制部分。 小程序的执行环境是没有浏览器了，所以浏览器环境特有的 window 对象、BOM 和 DOM 等相关 API 都存在缺失（有对应的补充 API），小程序的执行环境是类似于 Node.js 的一种执行环境。因为没有浏览器环境，所以跟浏览器相关的操作如 cookie、Ajax 请求（XMLHttpRequest）、DOM 选择器、DOM 事件、路由 history、缓存、设备信息、位置等都不存在，与之相对应的是小程序的私有 API，比如我们在小程序中不能使用 XMLHttpRequest，但是可以使用功能更加强大的 wx.request 方法。 小程序架构解密 小程序架构如上图所示，分为视图层和逻辑层，视图层是在 WebView 内渲染，逻辑层则有 JavaScriptCore 来渲染；其中视图层可以多个（考虑到整体性能，最多可以 5 个），逻辑层则全局只有一个（实际通过开启 X5 内核另起一个 JavascriptCore 线程）。 视图层是 WebView，逻辑层为 JavaScriptCore，证据如下：使用 Android 手机，开启 X5 内核 debug 之后，在 Chrome inspect 中可以看到下图所示的内容。 在小程序内，视图层负责页面渲染，逻辑层负责逻辑处理、全局状态管理、请求和接口调用。逻辑层在小程序中称为 APP Service，视图层称为 View。 逻辑层和视图层通过微信的 JSBridge 来实现通信的，逻辑层数据变化通过 JSBridge 通知视图层，触发视图层更新；当视图层触发事件，则继续通过 JSBridge 将事件通知到逻辑层做处理，如此交互进行。 JSBridge 在三个环境（开发者工具、iOS 和 Android）中实现机制不同，在调用 Native 能力时主要使用 invokeHandler： 开发者工具：通过 window.postMessage 来封装 iOS：通过 WKWebview 的 window.webkit.messageHandlers.invokeHandler.postMessage Android：通过 WeixinJSCore.invokeHandler 在消息分发的时候，则使用 publishHandler： 开发者工具：通过 addEventListener(&#39;message&#39;) 来监听消息，然后处理分发 iOS：使用 WKWebview 的 window.webkit.messageHandlers.publishHandler.postMessage Android：通过 WeixinJSCore.publishHandler 其中，Android 的 WeixinJSCore 是 X5 内核暴露出来的对象，其作为 window 对象的一个属性，提供一些供 JavaScript 调用的能力。 WeixinJSBridge 提供的方法有 invoke、publish 和 subscribe 等，invoke 就是关键的调用 Native 端能力的方法，publish 是消息分发的方法。 因为在一个小程序中可以打开多个视图层（webview），要保证发送的消息准确送到每个具体的 webview 中，需要通过每个 webview 唯一标识 webviewId 来实现。发送消息时，携带 webviewId，然后逻辑层处理完对应的逻辑，如果需要通知或者执行对应 webview 的代码，则可以通过 webviewId 找到对应的 webview，下发通知。 理解小程序生命周期小程序生命周期包括应用的生命周期（逻辑层 App Service）和页面的生命周期（视图层 View），两者支持的事件不同，详见官方文档中的这张配图。 掌握了上面小程序实现原理的内容，再来看小程序的生命周期就很好理解了。 小程序启动时，会同时启动两个线程，一个负责页面渲染的 WebView（实际不止一个，后面讲解），一个负责逻辑的 JavaScriptCore。逻辑层初始化后会将初始化数据（app.js 中的 global data）通过 JSBridge 传递给渲染层进行渲染，渲染层 WebView 页面渲染完之后又会跟逻辑层通信。 cover-view/cover-image在微信小程序经常会用到一些原生组件，比如map、video、canvas、camera，这些原生组件想让其他元素覆盖在其上，必须使用cover-view或者cover-image组件. cover-view 覆盖在原生组件之上的文本视图，可覆盖的原生组件包括map、video、canvas、camera，只支持嵌套cover-view、cover-image。注意：只支持基本的定位、布局、文本样式、背景色。不支持设置单边的border、background-image、shadow、overflow: visible等。可用cover-image替换background-image cover-image 覆盖在原生组件之上的图片视图，可覆盖的原生组件同cover-view，支持嵌套在cover-view里,image组件基本一样.]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manifest离线缓存]]></title>
    <url>%2Fmanifest%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTML5提供一种应用程序缓存机制manifest，使得基于web的应用程序可以离线运行。开发者可以使用Application Cache (AppCache)接口设定浏览器应该缓存的资源并使得离线用户可用。 在处于离线状态时，应用也能正常加载与工作。用户可以在离线状态下浏览网站内容, 减轻服务器的负载, 浏览器只会下载在服务器上发生改变的资源。 应用程序缓存的优点 离线浏览: 用户可以在离线状态下浏览网站内容。 更快的速度: 因为数据被存储在本地，所以速度会更快。 减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源manifest只会缓存静态资源文件, 接口返回的数据还需要使用localstorage进行缓存, 通常将manifest与接口返回的数据进行本地存储才能达到离线访问 Application Cache的特点 Manifest文件有变化才更新 一次必须更新Manifest中的所有文件, 有一个失败则全抛弃 更新内容下一次访问才生效 manifest使用 在页面头部引入manifest文件 当第一次打开该页面时，浏览器会解析该页面中mainfest文件，并缓存里面列举的资源 12&lt;html manifest="manifest/recharge.manifest"&gt;&lt;/html&gt; 编写manifest缓存清单文件 12345678910111213141516171819//manifest/clientHome.manifestCACHE MANIFEST#VERSION v6.0.1#DATE 2020-3-2 14:00:00CACHE:../../css/public/public.css../../css/public/swiper.min.css../../images/recharge/sprite.png../../images/recharge/icon-checked.png../../js/public/autoScale.js../../js/jquery/jquery.min.jsNETWORK:*FALLBACK:*.html /offline.html manifest文件组成 CACHE MANIFEST 固定格式 必须在首行 CACHE: (必选)表示需要离线存储的资源列表，在首次加载后会被浏览器缓存到本地 可以是相对路径也可以是绝对路径 NETWORK: (可选)在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储, 离线时不可用 FALLBACK: (可选)表示如访问资源失败，就使用第二个资源来替换它 以#开头的是注释 可以是版本号或时间戳 一般用更改版本号或时间戳来告诉浏览器更新manifest manifest文件需要配置正确的MIME-type即text/cache-manifest。必须在服务器上进行配置。 manifest加载过程 浏览器后次加载页面发现html头部有manifest属性,会请求manifest文件,将manifest中的文件缓存到本地 浏览器在有缓存的情况下, 离线访问应用时, 会直接使用离线缓存的资源 如果已经访问过应用且资源已经离线存储过, 首次加载页面时,会先进行读取缓存, 如果有缓存返回cache中的资源先显示页面,再去server上检查manifest缓存文件是否有更新,无更新则不作任何操作,如果有更新,会下载更新的文件,然后更新app cache.等到用户第二次加载页面时, 才会看到更新后的内容. manifest使用过程中注意问题 如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。 对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。 浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。 在更新了资源之后，新的资源需要到下次再打开页面才会生效，如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。 applicationCache缓存中的事件 事件名称 解释 oncached 当离线资源存储完成后触发 onchecking 当浏览器对离线存储资源进行检查的时候触发 ondownloading 当浏览器开始下载离线资源的时候触发 onerror 当缓存资源失败的时候触发 onnoupdate 浏览器检查manifest文件没有更新时触发 onobsolete 过时的 onprogress 当浏览器下载每一个资源的时候都会触发一次 onupdateready 浏览器更新离线资源完成的时候触发 123456789101112131415161718192021222324252627282930313233343536373839// 离线资源存储完成之后触发window.applicationCache.addEventListener('cached', function () &#123; console.log('cached');&#125;);// 离线存储资源进行更新检查的时候会触发 每次刷新页面都会被触发，包括第一次加载window.applicationCache.addEventListener('checking', function () &#123; console.log('checking');&#125;);// 开始下载离线资源的时候会触发window.applicationCache.addEventListener('downloading', function () &#123; console.log('downloading');&#125;);// 下载每一个资源的时候会触发window.applicationCache.addEventListener('progress', function () &#123; console.log('progress');&#125;);// 离线资源更新完成之后window.applicationCache.addEventListener('updateready', function () &#123; console.log('updateready');&#125;);// 检查更新之后发现没有资源更新的时候触发window.applicationCache.addEventListener('noupdate', function () &#123; console.log('noupdate');&#125;);// obsoletewindow.applicationCache.addEventListener('obsolete', function () &#123; console.log('obsolete');&#125;);// errorwindow.applicationCache.addEventListener('error', function () &#123; console.log('error');&#125;); 如何更新缓存 用户清空浏览器缓存 manifest 文件被修改 利用浏览器缓存机制在第二次访问manifest有更新的页面时更新页面内容 由程序来手动更新应用缓存123456window.applicationCache.addEventListener('updateready', function(e) &#123; if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123; window.applicationCache.swapCache() window.location.reload() &#125;&#125;, false)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2Fwebpack%2F</url>
    <content type="text"><![CDATA[Webpack是一个现代javascript应用程序的静态模块打包工具: 它做的事情是,分析你的项目结构,找到Javascript模块以及其它的一些浏览器不能直接运行的拓展语言(Scss,Typescript),并将其打包成浏览器识别的格式. webpack功能 代码转换 Typescript编译成Javascript,Scss变异成css等 文件优化 压缩Javascript,CSS,HTML代码,压缩图片 代码分割 提取多个页面的公共代码,提取首屏不需要执行的代码让其异步加载 模块合并 构建功能将项目中的多个模块分类合并 自定刷新 监听本地源代码变化,自动重新构建,刷新浏览器 代码校验 代码提交之前校验代码是否符合规范,以及单元测试是否通过 自动发布 更新完代码,自动构建出线上代码并上传 webpack安装及初始化项目 初始化项目 npm init -y 按照默认参数初始化package.json 本地安装(局部安装) npm i webpack webpack-cli -D.\node_modules\.bin\webpack --version windows需使用\路径npx webpack --version 低版本需要安装 npxnpx 会自动查找node_modules对应的.bin下的webpack.cmd命令 不存在则会自动安装 全局安装 npm i webpack webpack-cli -g 常在终端命令窗口使用webpack --version 配置开发服务器 webpack-dev-server12345678910111213141516171819// package.json中的script 添加 start: 'webpack-dev-server'"scripts": &#123; "start": "webpack-dev-server"&#125;,// 然后配置webpack.config.js下 devServer配置module.exports = &#123; devServer: &#123; contentBase: './build', port:3000, compress: true, // 服务期压缩 open: true, // 自动打开浏览器 &#125; // 开发服务器&#125;// 或者"scripts": &#123; "dev":"webpack-dev-server --inline --hot --open --port 4009"&#125;// 参数说明： --inline 自动刷新 --hot 热加载 --open 自动在默认浏览器中打开// --port 指定监听端口为 5200 --host 可以指定服务器的ip，不指定默认为127.0.0.1(localhost) webpack基本配置 配置入口和出口 123456789101112module.exports = &#123; entry: &#123; // 入口 找到入口之后开始寻找依赖包和各种资源 index: './src/index.js', &#125;, output: &#123; // 出口 告诉webpack经过各种loader处理后的文件应该生成到哪个目录下 // 输出文件名 filename: 'build.js', // 这个路径必须是绝对路径 path: path.resolve('./build'), // path: path.join(__dirname, './build') &#125;&#125; 配置hash 12345678910111213141516171819module.exports = &#123; output: &#123; // filename: 'build.js', // 输出目录加入hash 8位 filename: 'build.[hash:8].js', // 这个路径必须是绝对路径 // path: path.resolve('./build'), path: path.join(__dirname, './build') &#125;, // 出口 plugins: [ new HtmlWebpackPlugin(&#123; // 要拷贝的模板文件路径 template: './src/index.html', // 文件末尾加入hash hash: true, &#125;) ]&#125;// src="build.60df093c.js?60df093c83b96da06c39" 多入口 多出口 多页应用 1234567891011121314151617181920212223module.exports = &#123; entry: &#123; index: './src/index.js', b: './src/b.js' &#125;, output: &#123; filename: '[name].[hash:8].js', path: path.resolve('./build') &#125;, // 出口 plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; filename: 'a.html', template: './src/index.html', chunks: ['index'] &#125;), new HtmlWebpackPlugin(&#123; filename: 'b.html', template: './src/index.html', chunks: ['b'] &#125;) ], // 插件的配置&#125; 开发环境 123module.exports = &#123; mode: 'development', // 可以更改模式&#125; webpack 插件 pluginloader与plugin区别loader用于转换某些类型的模块,是一个转换器plugin是插件, 是对webpack本身的扩展,是一个扩展器，功能强大可以用来处理各种各样的的任务 html-webpack-plugin 自动生成一个index.html文件(或者指定模板来生成)并自动引入打包后的js文件npm install html-webpack-plugin --save-dev 12345678910111213141516let HtmlWebpackPlugin = require('html-webpack-plugin')new HtmlWebpackPlugin(&#123; // 要拷贝的模板文件路径 template: './src/index.html', // 设置标题 title: 'webpack练习', // 文件末尾加入hash hash: true, // 压缩文件 minify: &#123; // 去除属性双引号 removeAttributeQuotes: true, // 压缩成一行 // collapseWhitespace: true &#125;&#125;) clean-webpack-plugin 删除清空文件 12let &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')new CleanWebpackPlugin(['dist']), webpack 自带热更新 12345678910111213141516171819202122let webpack = require('webpack')module.exports = &#123; devServer: &#123; contentBase: './build', port:3000, compress: true, // 服务期压缩 open: true, // 自动打开浏览器 hot: true, // 热更新 proxyTable: &#123;//代理 webpack-dev-server提供 '/api':&#123; target:'http://192.168.5.22:8787',//请求转发到本地服务器 pathRewrite: &#123;//替换路径 '^/api':'/public/json' &#125; &#125; &#125; &#125;, // 开发服务器 module: &#123;&#125;, // 模块配置 plugins: [ new webpack.HotModuleReplacementPlugin() // 热更新插件 ]&#125; 抽离css样式 用于生产环境npm i extract-text-webpack-plugin -D 或 mini-css-extract-plugin -D 123456789101112131415161718192021let ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: 'style-loader', use: [&#123; loader: 'css-loader'&#125; ] &#125;) &#125; ] &#125;, // 模块配置 plugins: [ new ExtractTextWebpackPlugin(&#123; filename: 'css/index.css', // 开发环境禁用 否则css无法热更新 disable: true &#125;) ]&#125; 剔除没用的css代码 purifycss-webpack postcss-loader 后处理css 兼容性检查 自动加css前缀autoprefixer copy-webpack-plugin拷贝文件 压缩js的pluginnpm install uglifyjs-webpack-plugin --save-dev 12let uglifyJsPlugin = require('uglifyjs-webpack-plugin')new uglifyJsPlugin(), 打包公共代码 webpack自带的CommonsChunkPlugin 12345678module.exports = &#123; plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', minChunks: 2 &#125;) ]&#125; 处理第三方js库 直接在html引入线上地址或使用webpakc.ProvidePlugin()注入plugins: [new webpck.ProvidePlugin({ $: &#39;jquery&#39; })] 将共用代码载入到html中以style标签或script标签中npm i html-webpack-inline-chunk-plugin -D loaderloader本身就是一个函数，对接收到的内容进行转换并返回转换后的结果。用于转换各种资源类型的模块webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。loader实际上就是一个预处理器 css处理相关的loadernpm install style-loader css-loader less less-loader stylus stylus-loader node-sass sass-loader -D 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader'&#125;, // 将css样式嵌入到文档中 &#123; loader: 'css-loader'&#125; // 负责加载css文件 ] &#125;, &#123; test: /\.less$/, use: [ &#123; loader: 'style-loader'&#125;, &#123; loader: 'css-loader'&#125;, &#123; loader: 'less-loader'&#125; ] &#125; ] &#125;&#125; 图片文件处理 url-loader file-loader img-loader postcss-spritesnpm install url-loader file-loader -D 1234567891011121314151617181920212223242526272829303132333435363738394041module.exports = &#123; module: &#123; rules: [ &#123; test: /\.(png|jpg|jpeg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, // 小于8Kb对图片进行base64编码 // 大于limit限制 // images/ 文件要打包的到的文件夹 // [name] 图片原来的名称 // [hash:8]为了防止图片名称冲突，依然使用hash只保留8位 // [ext] 使用图片原来的的扩展名 name: 'images/[name].[hash:8].[ext]' &#125; &#125;, &#123; loader:'img-loader', options: [ pngquant: &#123; quality: 80 &#125; ], &#125; ] &#125;, test: /\.css$/, use: [ &#123; loader: 'style-loader'&#125;, // 将css样式嵌入到文档中 &#123; loader: 'css-loader'&#125; // 负责加载css文件 &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: [ require('postcss-sprites')(&#123; spritePath: 'dist/assets/imgs/sprites' &#125;)] &#125; &#125; // 负责加载css文件 ] ] &#125;&#125; es6语法处理 babal-loadernpm install --save-dev babel-loader@7 babel-core babel-preset-es2015或babel-preset-env -Dbabel polyfill 对低版本浏览器不支持的 generator set map promise等做兼容性处理 全局使用 开发应用使用npm i babael-polyfill -save import babel-polyfillbabel runtime transform 局部使用 开发框架使用npm i babel-runtime babel-plugin-transform-runtime -D 在.babelrc中添加&quot;plugins&quot;:[&quot;transform-runtime&quot;]1234567891011121314151617181920212223module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|dist)/ // 不需要转化的js文件 use: [ &#123; loader: 'babel-loader', options: &#123; // presets: ['es2015'] presets: ['env'], &#123; targets: &#123; browsers: ['&gt; 1%', 'last 2 versions'] &#125; &#125; // 包含es2015 es2016 es2017 &#125; &#125; ] &#125; ] &#125;&#125; 编译typescript代码分割与懒加载require.include() 引入共用代码require.ensure([], function(){ var _ = require(&#39;lodash&#39;) }) 开发环境与生产环境异同开发环境与生产环境的相同点 同样的入口 同样的代码处理 同样的解析配置开发环境与生产环境的不同点开发环境 提取公用代码 压缩混淆 文件压缩 或是 base64编码 去除无用的代码开发环境 模块热更新 sourceMap 接口代理 代码规范检查 打包结果分析npm i webpack-bundle-analyzer -D1234const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPluginmodule.export = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 优化打包速速方法一webpack.dll.conf.js 分vendeor和app 分离第三方代码和业务代码(src) DllPlugin DllReferencePlugin方法二 uglifyJsPlugin 并行处理1234567891011const UglifyJsPlugin = require('uglifyjs-webpack-plugin')new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: false, // 去除sourcemap parallel: true, // 除主线程外所有线程 cache: true // 缓存&#125;), 方法三 HappyPack HappyPack.ThreadPool 方法四 babel-loader 设置 options.cacheDirectory include excludebabel-loader 只处理src下js文件其他 减少resolve Devtool 去除 sourcemap cache-loader 升级node及webpack版本 webpack多页面应用配置 parallel-webpack webpack配置代码vendor提取工程中所使用的的库、框架等第三方模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 //path是Nodejs中的基本包,用来处理路径const path = require('path')//引入html-webpack-pluginconst HTMLPlugin = require('html-webpack-plugin')//引入webpackconst webpack = require("webpack")//将css代码抽离出来打包成单独文件const ExtractPlugin = require("extract-text-webpack-plugin")//判断是否为测试环境,在启动脚本时设置的环境变量都是存在于process.env这个对象里面的const isDev = process.env.NODE_ENV === "development"const config = &#123; //设置webpack的编译目标是web平台 target: "web", //声明js文件入口,__dirname就是我们文件的根目录,用join拼接 entry: path.join(__dirname, 'src/index.js'), //声明出口文件 output: &#123; //将挂载的App全部打包成一个bundle.js,在浏览器中可以直接运行的代码 filename: 'bundle.js', //bundle.js保存的位置 path: path.join(__dirname, 'dist') &#125;, //因为webpack只能处理js文件,且只识别ES5的语法 module: &#123; //所以针对不同类型的文件,我们定义不同的识别规则,最终目的都是打包成js文件 rules: [ //处理.vue文件 &#123; test: /\.vue$/, loader: 'vue-loader' &#125;, //处理jsx文件 &#123; test: /\.jsx$/, loader: 'babel-loader' &#125;, // &#123; // test: /\.css$/, // use: [ // 'style-loader', //将css的样式写入到html里面去 // 'css-loader' //处理css文件 // ] // &#125;, //处理图片 &#123; test: /\.(gif|jpg|jpeg|png|svg)$/, use: [ &#123; //url-loader实际上依赖于file-loader,file-loader处理完文件可以保存为一个文件供处理 loader: 'url-loader', //loader是可以配置选项的,如下options options: &#123; //url-loader的好处是可以加一个限制的大小,对于小图片,在范围内可直接将图片转换成base64码直接存放在js中,以减少http请求. limit: 1024, //输出文件的名字,[name] 文件原名,[ext]文件扩展名. name: '[name].[ext]' &#125; &#125; ] &#125; ] &#125;, plugins: [ //主要作用是在此处可以根据isdev配置process.env,一是可以在js代码中可以获取到process.env, new webpack.DefinePlugin(&#123; //二是webpack或则vue等根据process.env如果是development,会给一些特殊的错误提醒等,而这些特殊项在正式环境是不需要的 'process.env': &#123; NODE_ENV: isDev ? '"development"' : '"production"' &#125; &#125;), //引入HTMLPlugin new HTMLPlugin() ]&#125;//如果是测试环境下的一些配置if (isDev) &#123; config.module.rules.push(&#123; test: /\.styl/, use: [ 'style-loader', //将css写入到html中去 'css-loader', //css-loader处理css &#123; loader: 'postcss-loader', options: &#123; //stylus-loader和postcss-loader自己都会生成sourceMap,如果前面stylus-loader已生成了sourceMap //那么postcss-loader可以直接引用前面的sourceMap sourceMap: true, &#125; &#125;, //处理stylus的css预处理器的问题件,转换成css后,抛给上一层的css-loader 'stylus-loader' ] &#125;) //官方推荐使用这个配置,作用是在浏览器中调试时,显示的代码和我们的项目中的代码会基本相似, //而不会显示编译后的代码,以致于我们调试连自己都看不懂 config.devtool = '#cheap-module-eval-source-map' //这个devServer的配置是在webpack2.x以后引入的,1.x是没有的 config.devServer = &#123; port: 8000, //访问的端口号 host: '127.0.0.1', //可以设置0.0.0.0 ,这样设置你可以通过127.0.0.1或则localhost去访问 overlay: &#123; errors: true, //编译中遇到的错误都会显示到网页中去 &#125;, open: true, //项目启动时,会默认帮你打开浏览器 hot: true //在单页面应用开发中,我们修改了代码后是整个页面都刷新,开启hot后,将只刷新对应的组件 &#125;, //添加两个插件用于hot:true的配置 config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125; else &#123; config.entry = &#123; app: path.join(__dirname, 'src/index.js'), vendor: ['vue'] &#125; //此处一定是chunkhash,因为用hash时app和vendor的hash码是一样的了,这样每次业务代码更新,vendor也会更新,也就没有了意义. config.output.filename = '[name].[chunkhash:8].js' config.module.rules.push(&#123; test: /\.styl/, use: ExtractPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', //css-loader处理css &#123; loader: 'postcss-loader', options: &#123; //stylus-loader和postcss-loader自己都会生成sourceMap,如果前面stylus-loader已生成了sourceMap //那么postcss-loader可以直接引用前面的sourceMap sourceMap: true, &#125; &#125;, //处理stylus的css预处理器的问题件,转换成css后,抛给上一层的css-loader 'stylus-loader' ] &#125;) &#125;), config.plugins.push( //定义打包分离出的css文件名 new ExtractPlugin('styles.[contentHash:8].css'), //定义静态文件, 库文件, 插件打包 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), //将app.js文件中一些关于webpack文件的配置单独打包出为一个文件,用于解决部分浏览器长缓存问题 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'runtime' &#125;) )&#125;//声明一个config的配置,用于对外暴露module.exports = config]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript对象与面向对象]]></title>
    <url>%2Fjavascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象是javascript的复合数据类型。对象可看做是属性的无序集合，每个属性都是一个名/值对，属性名是任意字符串，但对象中不能存在两个同名的属性，值可以是任意类型。面向过程思维方式: 把解决问题的关注点放在每一个步骤上。面向对象思维方式: 把解决问题的关键点放在解决问题需要的一系列对象上。 对象的特点 属性的值（value） 可写（writable） 表明是否可以设置该属性的值 可枚举（enumerable） 表明是否可以通过for/in或for/of遍历该属性 可配置（configurable） 表明是否可以删除或修改该属性 对象的原型（prototype） 指向另外一个对象，本对象的属性继承自它的原型对象 对象的类（class） 是一个标识对象类型的字符串 创建对象 对象直接量（对象字面量） 123456789var point = &#123;x:0, y:1&#125;var book = &#123; 'title': 'Javascript', 'sub-title': 'js', 'author': &#123; firstname: 'Bob', surname: 'David' &#125;&#125; 通过new 构造函数() 123var obj = new Object(&#123;x：1&#125;) // 创建一个对象 同 &#123;x：1&#125;var arr = new Array(1,2) // 创建一个数组 同 [1, 2]var d = new Date() // 创建一个表示当前时间的date对象 Object.create() 创建原型对象Object.create()是一个静态函数，第一个参数是这个对象的原型，第二个参数为可选参数，用以对对象的属性进行进一步的描述 12var P = &#123;name: 'tew'&#125;var o3 = Object.create(P) new 构造函数() 经历四个步骤 创建一个新对象 将构造函数的作用域赋值给新对象（this指向新对象） 执行构造函数中的代码（为新对象this添加属性） 返回新对象（默认是 return this） 获取和设置对象的属性 可以通过点（.）和方括号（[]）运算符来获取属性的值 1234567891011var book = &#123; 'title': 'Javascript', 'sub-title': 'js', 'author': &#123; firstname: 'Bob', surname: 'David' &#125;&#125;console.log(book.title) // 得到book的title属性console.log(book['sub-title']) // 得到book的sub-title属性book.title = 'jquery' // 设置或修改book的title属性 对象的方法 toString()方法 将对象转换为字符串 12s = &#123;x:1, y:2&#125;.toString();console.log(s) // "[object Object]" toLocalString()方法 返回对象的本地化字符串 123456var local = new Date().toLocaleString()console.log(local) // "2017/12/26 上午14:30:14"var date = new Date().toLocaleDateString()console.log(date) // "2017/12/26"var time = new Date().toLocaleTimeString()console.log(time) // "上午14:30:14" 面向对象 面向对象概念: 用对象的思想去写代码,就是面向对象编程 面向对象特点: 抽象:抓住核心问题 封装:只能通过对象来访问方法 将一些属性和方法封装起来 继承:从已有对象上继承出新的对象 多态:多对象的不同形态,父类的成员可以共享给所有子类,子类可以给父类添加属性 对象:带有属性和方法的特殊数据类型 对象下面的变量 叫做对象的属性 状态,静态的 对象下面的函数 叫做对象的方法(行为,操作) 过程,动态的 创建对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var obj = new Object()// 为对象添加属性和方法obj.name = "tew"obj.showName = function()&#123; console.log(this.name)&#125;obj.showName() //tew// 工厂方式: 封装函数function Person(name)&#123; //原料 空对象 var obj = new Object() //加工 obj.name = name obj.showName = function()&#123; console.log(this.name) &#125; //出厂 return obj&#125;var p1 = Person('tew')p1.showName() // tewvar p2 = Person('cj') //cjp2.showName()// 当new去调用一个函数: 这个时候函数中的this就是创建出来的对象,而且函数的返回值就是this对象(隐式返回)// 构造函数 new 后面调用的函数 (构造函数名第一个字母大写)function Person(name)&#123; this.name = name this.showName = function()&#123; console.log(this.name) &#125;&#125;var p1 = new Person('tew')p1.showName() // tew// 对象的引用// 基本类型: 赋值的时候只是值得复制 在内存中重新开辟空间// 对象类型: 赋值不仅是值得复制,而且是引用的传递 var a = [1, 2, 3] //两者地址绑在一起var b = ab.push(4)console.log(a) //1,2,3,4 对象进行比较的时候,值和引用都要相同var a = [1,2,3]var b = ab = [1,2,3,4] //重新复制地址改变console.log(a) //1,2,3// 原型:去改写对象下面公用的方法或属性,让公用的方法或者属性在内存中存在一份(提高性能)// 原则: 相同的属性和方法可以加载到原型上 自己和原型中都有的属性或方法,优先用自己的// 原型方法或属性 相当于css中的class 多个公用// 普通方法或属性 相当于css中的stylevar arr = [1,2,3,4,5]var arr2 = [1,2,3,4]arr.sum = function()&#123; var res = 0 for(var i=0;i&lt;this.length;i++)&#123; res+=this[i] &#125; return res&#125;console.log(arr.sum()) //15//arr2.sum();//arr2.sum is not a functionarr2.sum = function()&#123; var res = 0 for(var i=0;i&lt;this.length;i++)&#123; res+=this[i] &#125; return res&#125;console.log(arr2.sum()) //10//原型写法prototype 要写在构造函数下面 只有构造函数才能有原型Array.prototype.sum = function()&#123; var res = 0 for(var i=0;i&lt;this.length;i++)&#123; res+=this[i] &#125; return res&#125;console.log(arr.sum()) //15console.log(arr2.sum()) //10 更改this指向 将this用全局变量存起来 使用call方法改变this指向 fn.call(参数1,参数2,参数3) 参数1 可以改变函数执行过程中的this指向 参数2以后就是执行函数的参数 使用apply方法改变this指向 fn.apply(this(要修改的那个对象),[参数1,参数2])注: 使用call和apply传入的第一个参数可以是null,表示为函数调用模式,this指向window当第一个参数为值类型的时候,会将值类型转换为对应的对象 包装对象系统对象也是基于原型的程序 尽量不要去修改或者添加系统对象下面的方法和属性所有的基本类型都有自己的包装对象: Number String Boolean基础类型在执行方法或者属性的时候,会找到对应的包装对象1234567var a = new String('abc') //console.log(typeof a)// 通过包装对象去执行方法或者属性a.charAt(0)// 基本类型的包装对象 只存在于一行代码的执行瞬间 执行完后,包装对象立即被销毁var str = 'abc'str.num = 10console.log(str.num) //undefined 原型和原型链: 实例对象和原型之间的链接 proto原型里面默认的属性和方法 不能for in打印原型链的最外层是 Object.prototype instanceof 对象 instanceof 函数 判断函数是不是这个对象原型链上的构造函数 hasOwnProperty() 对象.hasOwnPeroperty(‘属性’) 最外层Object的属性 Object.prototype.hasOwnPeroperty 对象中是否有某属性,返回布尔值 原型如果改成json写法 会影响这个属性 constructor 对象.constructor 查看对象的构造函数 构造函数:原型里面默认的属性 每一个函数都会有的,都是自动生成的 Aaa.prototype.constructor = Aaa; 原型如果改成json写法 会影响这个属性 原型查找原则1.当访问一个对象的成员的时候,先在自身找有没有,如果有,直接使用2.如果没有找到,则去当前对象的原型对象中去找,如果有,直接使用3.如果没有找到,则去原型对象的原型对象中去找,如果有,直接使用4.直到Object,如果还是没有,则返回null 构造函数显式原型prototype上的constructor属性等于构造函数本身Person.prototype.constructor===Person) //true 实例对象的隐式原型等于它构造函数的显示原型person.__proto__===Person.prototype //true es6中操纵原型的内置函数 Object.create 根据指定的原型创建新对象, 原型课时是null Obejct.getPrototypeOf() 获取一个对象的原型 Object.setPrototypeOf() 设置一个对象的原型 构造函数模式用于定义实例属性，而原型模式用于定义共用方法和共享的属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//构造函数function Foo(name,age)&#123; this.name = name this.age = age //return this //默认有着一行&#125;var f = new Foo('wangwu',20);//构造函数--扩展/* var a = &#123;&#125; 其实就是 var a = new Object()的语法糖 var a = [] 其实就是 var a = new Array()的语法糖 function Foo()&#123;&#125; 其实就是 var Foo = new Function()*///5条原型规则 原型规则是学习原型链的基础//a. 所有的引用类型(数组 对象 函数) 都具有对象特性 即可自由扩展属性(null除外)//b. 所有的引用类型(数组 对象 函数) 都有一个__proto__属性, 属性值是一个普通对象(null除外)(隐式原型)//c. 所有的函数,都有一个prototype属性,属性值也是一个普通的对象(显示原型)//d. 所有的引用类型(数组 对象 函数),__proto__属性值指向它的构造函数'prototype'属性值//e. 当试图得到一个对象(引用类型)的某个属性时,如果这个对象(引用类型) 本身没有这个属性,那么会去它的__proto__(即它的构造函数的prototype)中寻找&#123; //1. 都有可自由扩展属性 var obj = &#123;&#125;; obj.a = 100; var arr = []; arr.a = 100; function fn()&#123;&#125;; fn.a = 100; //2. 所有的引用对象都有 __ptoto__属性 隐式原型属性 指向其构造函数 console.log(obj.__proto__); // &#123;constructor: f...&#125; Object console.log(arr.__proto__); // [constructor: ƒ...] Object console.log(fn.__proto__); // ƒ () &#123; [native code] &#125; //3. 有的函数都有一个prototype属性 显示原型属性 console.log(fn.prototype); // &#123;constructor: ƒ&#125; //4. 所有的引用类型的__proto__ 属性值都指向它的构造函数'prototype'属性值 console.log(obj.__proto__===Object.prototype); // true //构造函数 function Foo(name)&#123; this.name = name; &#125; //原型扩展 Foo.prototype.alertName = function()&#123; console.log(this.name) &#125; //创建实例 var f = new Foo('zhangsan'); f.printName = function()&#123; console.log(this.name) &#125; //测试 f.printName(); //zhangsan f 本身的属性方法 f.alertName(); //zhangsan f 的显示原型去找 prototype中去找 f.__proto__ // &#123;alertName: ƒ, constructor: ƒ&#125; f.__proto__.__proto__ // &#123; constructor: ƒ... &#125; Object f.toString(); //"[object Object]" 要去 f.__proto__.__proto__去找&#125;// 调用构造函数时会为实例添加一个指向最初原型的prototype指针// 如果重写整个原型对象(即将原型修改为另一个对象) 就等于切断了构造函数与最初原型之间的联系// 实例中的指针仅指向原型 而不指向构造函数 实例仍然引用的是最初的原型function Person() &#123;&#125;var person = new Person()// Person.prototype.name = 'tew'// Person.prototype.sayName = function () &#123;// console.log(this.name)// &#125;// person.name // 'tew'// person.sayName() // tewPerson.prototype = &#123; constructor: Person, name: 'tew', sayName: function () &#123; console.log(this.name) &#125;&#125;// person.name // undefined// person.sayName() // Uncaught TypeError: person.sayName is not a function 继承 一个对象没有一些方法和属性,而把另一个对象的属性和方法,拿过来自己用就是继承 子对象可以继承父对象子对象拥有父对象有的东西子对象可以扩展子对象的扩展不会影响到父对象 继承的方式(1) 混入式继承(2) 原型继承(3) 经典继承(4) 原型链继承 js对象的默认继承是原型继承 123function Phone&#123;&#125;Phone.prototype = new Object() // 默认就会有这一步Phone.prototype.__proto__ === Object.prototype 继承的方式 原型链继承 借用构造函数继承 原型+构造函数继承 寄生式继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 1. 原型链继承function Animal () &#123; this.age = 20&#125;function Cat () &#123; this.name = 'jack'&#125;var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // undefined// 让Cat对象拥有了Animal对象的属性和方法Cat.prototype = new Animal()var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // 20// 2. 借用构造函数继承 在子类构造函数内部调用父类构造函数function Animal () &#123; this.age = 20&#125;function Cat () &#123; // Cat的所有对象借用了Animal对象的构造函数 借用构造函数可以传参 // Animal.call(this, '30') Animal.call(this) this.name = 'jack'&#125;var cat = new Cat()console.log(cat.name); // jaackconsole.log(cat.age); // 20// 3. 组合继承 原型链 + 借用构造函数继承// 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承function SuperType(name)&#123; this.name = name this.colors = ['blue', 'green']&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name)&#125;function SubType(name, age)&#123; // 继承属性 SuperType.call(this, name) this.age = age&#125;// 继承方法SubType.prototype = new SuperType()SubType.prototype.sayAge = function()&#123; console.log(this.age)&#125;var sub = new SubType('tew', 28)sub.colors.push('red')console.log(sub.colors) // ["blue", "green", "red"]sub.sayName() // tewsub.sayAge() // 28var sub2 = new SubType('bob', 26)console.log(sub2.colors) // ["blue", "green"]sub2.sayName() // bobsub2.sayAge() // 26// 4. 寄生式继承function Person(name, age)&#123; this.name = name this.age = age&#125;function createPerson(name, age)&#123; var obj = &#123;&#125; Person.call(obj, name, age) return obj&#125;var person = createPerson('tew', 28)console.log(person) // &#123;name: "tew", age: 28&#125;console.log(person.constructor) // ƒ Object() &#123; [native code] &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql进阶使用]]></title>
    <url>%2Fmysql%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL是最流行的关系型数据库管理系统之一。有很多的高级用法包括：视图view,索引操作,数据库的备份和恢复,数据控制语言(DCL),数据事务语言(DTL),存储函数, 存储过程(procedure),触发器(trigger)等 mysql高级操作 视图 view 123456789101112view是由sql的查询结果形成的一张虚拟表创建视图 create view 视图名 as select 语句create view vgoods as select goods_id,goods_name,shop_price from goods使用视图 基本上当成一张表用即可删除视图 drop view 视图名1.权限控制时使用 通过视图开放其中的一列或几列起到权限控制的作用2.简化复杂的查询3.如果视图的每一行是与物理表一一对应的则可以修改,如果view的行是有物理表的 多行经过计算得到的结果view是不可以更新的视图的algorithmmerge 把查询视图的语句与创建时的语句where子句等合并temptable是根据创建语句瞬间创建一张临时表 存储引擎 12345engine=myisam或InnoDB(默认)myisam 插入速度快 支持全文索引 不支持事务 表锁InnoDB 支持事务安全 行锁 支持外键myisam 方式存储的数据表 会比InnoDB 多出2个文件 在mysql/data/MyISAM 对应三个文件 *.frm表信息 *.MYD 存储数据 *.MYI 存储索引信息) 索引操作 1234567891011121314主键索引 primary key一张表只能有一个主键只能有一列为auto_increment 主键不能为空唯一索引 unique 防止创建重复的值索引是数据的目录,能快速定位行数据的位置 不好的是降低了增删改的速度对大数据的范围内查找时,查找速度特别快 有索引和无索引查找速度区别很大创建原则 1.不要过度索引 2.在where条件最频繁的列上加 3.尽量索引散列值key 普通索引 unique 唯一索引 primary key 主键索引 fulltext全文索引查看索引 show index from 表名增加索引 alter table stu_mess add 索引名(列名)删除索引 drop index 索引名 on 表名或alter from 表名 drop index 索引名增加主键 alter table stu_mess add primary key(id)删除主键 alter table stu_mess drop primary key删除外键 alter table 表名 drop foreign key(外建名) 添加外键时自命名的名字 或 在表结构中 查看系统命名的外建名 数据库的备份和恢复 1234567a.备份 将一个数据库,完整的转换为一个可以 携带和传送的文件mysqldump -h 服务器地址 -u 用户名 -p 数据库名 &gt; 文件名(绝对路径)用于数据库的迁移 将数据库从一个服务器搬迁到另一个服务器用于数据的安全备份 防止数据库系统崩溃b.恢复 将一个备份的的数据库文件,完整的还原为一个可以使用的数据库mysql -h 服务器地址 -u 用户名 -p 数据库名 &lt; 文件名(绝对路径)登陆后 mysql &gt; source "备份数据库文件的完整路径" 数据控制语言(DCL) 用户管理 123456789mysql中的所有用户,都存储在系统数据库mysql中的user表中a.创建用户 create user '用户名'@允许登录的地址/服务器 identified by '密码' 允许登录的地址:指允许用户登录到mysql服务器的客户端的地址,本机localhost 也可是某服务器名,或某IP地址b.删除用户 drop user '用户名'@'允许登录的地址'c.修改用户密码 修改自己的密码 set password=password('密码'); 修改其他用户的密码(前提是有权限) set password for '用户名'@'允许登录的地址'=password('密码') 权限管理 123456789A. 授予用户权限(增加权限)grant 权限列表 on 某库.某个对象 to "用户名"@'允许登录的地址'[identified by'密码']a. 权限列表 各个权限之间用逗号隔开b. 某库 . 某对象 给指定的某个数据库中的某个下级单位 下级单位有 表名 视图名 存储过程名 存储函数名 * . * 所有数据库中的所有下级单位 某库 . * 代表指定库的所有下级单位c. [identified by '密码'] 不写表示不修改密码 写上表示授权的同时修改密码B. 取消用户权限(减少权限)revoke 权限列表 on 某库.某对象 from "用户名"@'允许登录的地址' 数据事务语言(DTL) (汇款)123456789101112131415161718192021222324252627282930313233343536事务只针对与"增删改"语句而言事务就是用来保证多条"增删改"语句执行的"一致性",要么都执行完成,要么都没有执行事务只能使用engine=InnoDB存储引擎事务特性:原子性 指一个事务中的操作要么都执行要么都不执行隔离性 在所有的操作没有执行完毕之前其他会话不能够看到中间改变的过程一致性 事务发生前和发生后数据的总额依然匹配(数据保持逻辑上的合理性)持久性 事务产生的影响不能够撤销 如果发生错误只能通过补偿性事务事务模式查看事务模式 show variables like "%autocommit%"默认情况下,事务模式是开启的,称为自动提交模式开启 set autocommit=1或on 每条增删改语句 都会立即生效可以手动关闭,非自动提交模式,则需要人为提交关闭set autocommit=0或off所有增删改语句 都必须使用commit之后 才能生效事务执行的基本流程1.开启一个事务start transaction //也可以写成: begin2.执行多条增删改语句 //相当于希望这多条语句要作为一个不可分割的整体去执行3.判断这些语句执行的结果情况if(没有出错)&#123; commit; //提交事务,此时一次性完成&#125;else&#123; rollback;//事务回滚,此时就是都没有做&#125;a.在cmd中 开启事务之后 直接看多条'增删改'是否query ok 都ok则执行 commit; 有一条失败则rollback;b.在php中mysql_query("start transaction") //开启事务msyql_query(多条sql语句)if($res1 &amp;&amp; $res2 &amp;&amp;....)&#123; mysql_query("commit"); echo "事务执行成功!所有任务都已完成";&#125;else&#123; mysql_query("rollback"); echo "事务执行失败!数据没有被修改";&#125; Mysql编程 语句块包含符 //相当于js或php中的大括号写法 123[标识符]:begin //语句.....end [标识符]; 变量形式 1234567891011121314A:普通变量 定义 declare 变量名 类型名 [default 默认值] 赋值 set 变量名 = 值 取值 直接使用变量名 使用场所 a. 定义函数的内部 b. 定义存储过程的内部 c.定义触发器的内部B:会话变量 set @变量名 = 值 //和php一样 无需定义 直接赋值 使用场所 基本上任何环境都可以用C:变量赋值 a. set 变量名 = 表达式 //针对普通变量 必须先declare声明 b. set @变量名 = 表达式 c. set @变量名 := 表达式 d. set 表达式 into @变量名 存储函数 1234567891011121314相当于php或js中有返回值的函数 它必须在完成计算后返回单个具体数据值或变量数据a. create function 函数名(形参1,形参2)returns 返回类型begin #这里写完整的函数语句 return XX值;end #必须有return语句 返回类型必须和设定的类型一致b.调用函数可用于select语句中 select now(),函数名(实参1,实参2..)set @v1 = now(); set @v2 = 函数名(实参1,实参2...)c.删除函数drop function [if exists] 函数名;注: 在函数内部,可以有各种变量和流程控制的使用,也可以有各种增删改的语句 但不可以有select或其他返回结果集的查询类语句,因为函数只返回单个数据 存储过程(procedure) 123456789101112131415161718192021222324252627282930313233相当于php或js中没有返回值的函数它只执行不返回单个数据但可以得到(select结果集)a 形式 create procedure 存储过程名(in|out|inout 形参1 类型,...) delimiter // create procedure insert_get(p1 varchar(20),p2 varchar(20),p3 tinyint) begin //类型必须和表中的字段一致 insert into result value(p1,p2,p3); select * from result order by score desc limit 0,3; end // 注: in 用于设定该变量是用来"接受实参数据"的 即传入 默认是in out 用于设定该变量是用来存储存储过程中的数据的,即传出 函数必须对它赋值 inout 是in和out的结合 具有双向作用 对于out和inout设定,对应的参数 就必须是一个变量,要用于接受传出数据 create procedure insert_get1(in p1 varchar(20),out p2 varchar(20),inout p3 tinyint) begin set p2=concat("建",p1); set p3=p3+5; insert into result values(p1,p2,p3); end set @s3=80 //设定变量并赋值 call insert_get1('筑',@s2,@s3); //调用存储过程 out和inout对应的必须是变量 select * from result; //查看插入结果b 调用存储过程 有select则返回结果集 call insert_get("周七","高数",91)c 删除存储过程 drop procedure 存储名在php中使用存储函数或存储过程调用存储函数$sql="insert into tab1 values(null,now(),func1($v1,$v2))"调用存储过程$sql="call insert_user($v1,$v2,$v3)"调用又返回结果集的存储过程$sql="call get_user_info($id)" 触发器(trigger) 在数据库 对应表下可以看到 12345678910111213141516171819202122232425也是一段预先定义好的编程代码,不能调用,而是在某个表发生(增删改)事件的时候,会自动触发create trigger 触发器名 触发时机 触发事件 on 表名 for each rowbegin //触发器的内部语句end //在执行之前先要用delimiter更改语句结束符说明: 1.触发时机 在某个事件发生之前还是之后触发 before after 2.触发事件 表上的什么事件发生的时候 insert update delete 3.特殊的关键字 old 代表当前正要执行delete的"旧行数据" old.id //获得这一旧行数据的任意字段的值 new 代表当前正要执行insert或update的"新行数据" new.id //获得该新插入或更改行的id字段的值触发器的含义 在某个表上进行insert/update/delete之前或之后,会去执行 其中写好的语句,每个表只有6个情形可能调用该触发器,通常 用于在对某个表进行增删改操作的时候,需要同时去做另外一 件事的时候ex create trigger max after insert on result for each row begin delete from maxscore; #先删除max表中的数据 select max(score) into @mc from result; insert into maxscore select * from result where score=@mc; end删除触发器drop trigger [if exists] 触发器名 其他 Mysql 常用函数 121.concat('a','b'..) 连接多个字符串2.now() 获取当前时间 如何备份某个数据库的所有表mysqldump -u 用户名 -p 数据库名 &gt; e:\\文件名.sql 如何备份库的表mysqldump –u 用户名 –p密码 数据库 表1 表2 表3.. &gt; d:\\文件名.sql 如何备份数据库,会多 CREATE DATABASE 语句.mysqldump –u 用户名 –p密码 –B 数据库1 数据库2 .. &gt; d:\\文件名.sql 恢复数据库[以库为单位] Source 文件名.sql 恢复数据库[以表为单位] use 某个库 Source 文件名.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基本用法]]></title>
    <url>%2Fmysql%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MySQL是一个关系型数据库管理系统,属于Oracle旗下产品。MySQL 是最流行的关系型数据库管理系统之一.MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言.MySQL特点: 体积小、速度快、成本低，开源免费. mysql安装 下载MySQL 安装参考链接 配置环境变量 path路径添加D:\PHP\mysql\bin 常用数据库 DB2、Oracle、SQL Server、Mysql、Access、MangoDB等 常用图形化管理工具 phpmyadmin navicat SQLyog等 结构化查询语句 数据定义语言(DDL) 用于定义数据对象,包括数据库,数据表 create drop alter 数据操作语言(DML) 用于操作数据库对象中所包含的数据 insert update delete 数据查询语言(DQL) 用于查询数据,进行单表,连接,嵌套查询 并将数据返回 select 数据控制语言(DCL) 用来管理数据库,包含管理权限及数据更改 grant remove rollback 数据事务语言(DTL) 用来保证多条”增删改”语句执行的”一致性” start transaction 启动/停止mysql服务 命令行模式 net start/stop nysql 控制面板-&gt;管理工具-&gt;服务-&gt;mysql-&gt;启动/停止 数据库操作 连接数据库 mysql -h 服务器主机地址 -u 用户名 -p 回车后输入密码 -P3306 退出数据库 exit或quit 查看所有数据库 show databases 创建数据库 create database [if not exists] stu charset utf8 [collate 排序规则] 删除数据库 drop database [if exists] stu(必须指定删除那个数据库) 显示数据库的创建语句 show create database test; 修改数据库 修改字符编码 修改排序规则 alter database 数据库名 charset 新的编码名 collate 新的排序规则 选择数据库 use stu 表的操作操作表时, 首先得先选择要操作的数据 即 use xxx数据库名 创建一张表 create table stu_mess(id int,name char(20)) 查看库下所有表 show tables 查看表结构 desc stu_mess 插入数据 insert into 查询数据 select * from stu_mess 更新数据 update stu_mess set name=&#39;lisi&#39;,age=&#39;19&#39; where id=5 删除数据 delete from stu_mess where id=2注:使用update更新数据或使用delete删除数据时,必须加条件限制(where),否则会更改或删除所有列 重命名表 rename table 表名1 to 表名2 同 alter table 表名 rename to 新表名 清空表数据 truncate books 同 delete form books (谨慎使用) 删除表 drop table [if exists] 表名 显示数据表的创建语句 show create table 表名 创建表时 对该表的整体设定 charset=要使用的字符编码 engine=要使用的存储引擎(也叫表类型) 指表中的数据以何种方式存放在文件或内存中 auto_increment=10001 自增字段的初始值 comment=”对该表的说明文字” 表中插入数据 插入单行数据 方式一 insert into book values(所有字段必须有值) 方式二 insert into book(列1,列2) values(&quot;值一&quot;,&quot;值二&quot;) 方式三 insert into book select * from 其他表 (两表的字段必须对应) 插入多行数据 方式四 insert into book values(101,&#39;mysql&#39;,55),(102,&#39;php&#39;,33) 方式五 insert into book select &#39;103&#39;,&#39;css&#39;,&#39;77&#39; union select &#39;104&#39;,&#39;html&#39;,&#39;88&#39;注:方式二可以只给需要赋值的字段插入数据,还可以按自定义字段顺序赋值 (列与值必须严格对应) 数字可以不加引号,但字符和时间必须加单引号 方式五 最后一行不加union 每个select 之间不能写逗号 插入数据时可以使用md5()对密码进行加密后 不可逆 修改表字段 添加字段 alter table 表名 add 新字段名 字段类型 修改字段并改名 alter table 表名 change 旧字段名 新字段名 新字段类型 修改字段属性 alter table 表名 modify 字段名 新字段类型 删除字段 alter table 表名 drop 字段名 添加字段默认值 alter table 表名 alter 字段名 set default 默认值 删除字段默认值 alter table 表名 alter 字段名 drop default 修改表选项 alter table 表名 选项1=值1,选项2=值2..... 从已有表复制表结构 create table if not exists 新表名 like 旧表名 表的数据类型 数值型 123456789101112在整型数据列后面加上unsigned 禁止负数 声明时可以指定显示长度整型 tinyint smallint mediuint int bigint 1字节 2字节 3字节 4字节 8字节默认是有符号 tinyint -128~127 smallint -32768~32768 int -2147483648~2147483647 1字节=2^8(8位)浮点型float(M,D) 10^38 M&lt;=24 4字节 否则占8字节 有精度损失 精度只有6位左右double(M,D) 使用8字节存储 精度更高m一共几位(总位数),d小数点后保留几位decimal(M,D) 变长字节 也可写成 numeric fixed dec把整数部分和小数部分,分开存储的 比float精度更高适合存储货币等要求精确的数字 字符型 12345678910111213char(m) 定长字符串 长度不够右侧空格填充 (自助餐) 取出数据时,再把后面的空格去掉,如果后面有空格 将会丢失 char长度范围是0~255 默认为1varchar(m) 可变长度 长度取决于实际存放在列中的值(内容)的长度 如果存储中文gbk 则最多存65533/2个字符 如果存储中文utf8 则最多存65533/3个字符 长度范围是0~65535 char比varchar更快text 存大段文本 区分大小写bolb 存大段二进制 不区分大小写 常用来存储图像,音频等二进制信息enum('val1','val2') 枚举类型 只能选择其中的一个(最多65535个)注:插值时可以直接写值,也可以用集合中的索引 0 代表 '' 1 '男' 2 '女'set('val1','val2',..) 集合类型 可以选择多个(最多64个)注:插值时也可用索引但索引是从1,2,4,8,16,....64最多(可用多个选项的索引和) 日期型 1234567Year 年 1990date YYYY-MM-DD 表示日期 可用分隔符多种time (H:i:s) 表示时分秒datetime(1990-12-10 H:i:s)timestamp YYMMDDhhmmss 格式的时间戳 插入或更新时自动获取当前时间时间戳now() 获取当前时间注:在时间日期类型中 在自己给定的情况下 需使用单引号或用now()函数 null 123null意味着没有值或未知值 可以插入表中 但是查询时 不能用=判断 必须用is null 或 is not null 来判断 也不能对null进行算术运算对null值进行运算 其结果都为null 在mysql中 0和null 被看作假其他为真 数据字段属性 123456789101.unsigned无符号 只能用在数值型中 且unsigned必须放在数值型后面2.zerofill 该数字不足参数M位时,数值前面自动补0 补够M位 只能用在数值型中 XXXint(M) 如果没有zerofill属性 单独的参数M 没有任何意义 如果设置某列为zerofill 则该列自动应用unsigned 无符号类型3.auto_increment 只能用于整数数据每增加一条会自动增加1不允许重复 自动增长为以前出现过的加14.null和not null 默认是否为空 查询不便,索引效果不高5.default() 默认值6.comment '字段说明文字' 备注 不会在表中显示 注:表数据的优化 定长与变长分离 常用与不常用分离 索引与约束 索引列表 12345678910111213索引时系统内部自动维护的隐藏的数据表 作用是极大的加快的查找速度建立索引其实是指定一个表的某个或某些字段的作为索引数据字段索引类型(要建立的索引的字段名) 共同作用(加快查找速度)1.普通索引 key(字段名) email varchar(20) ,key(email)2.唯一索引 unique key(字段名) 设定其字段的值不能重复(唯一性) username varcahr(20),unique key(username)3.主键索引 primary key(字段名) 区分表中的任何一行数据 id int not null auto_increment,primary key(id)4.全文索引 fulltext(字段名)5.外键索引 foreign [constrian 外建名] key(字段名) references 其他表(对应字段名)外键就是指设定表student的字段classId的值必须在另一个表class中的某个classId中存在(主键),在student插入数据时, classId字段的值,就不可以随便插入,必须在class表classId字段已存在值才可以添加,否则会报错 约束 12345678约束 就是要求数据需要满足什么条件的规定1.主键约束 primary key(字段名)2.唯一约束 unique key(字段名)3.外键约束 foreign key(字段名) references 其他表(对应字段名)4.非空约束 not null 设定not null属性5.检查约束 check(age&gt;=0 and age&lt;=100) 在mysql目前不支持主键约束,唯一约束,外键约束同时也被称为主键索引,唯一索引,外键索引只是同一件事情按不同的角度的两种说法 1.查找角度 有了索引查找快 2.数据要求,满足规定 mysql查询语句 基本查询 12345678910111213141516171819202122select [all(默认) distinct] 字段或表达式或函数 [from 表] [where子句] [group by子句] [having子句] [order by子句] [limit子句]a.列出要查询的字段,可以用as为字段起别名(关键字,多表查询)b.使用distinct取消重复的数据,返回没有重复所有数据 all不取消重复行(默认)①条件 where 表达式 true或false false取不出来结果 针对磁盘的数据(固有数据) 比较运算符 &lt; &lt;= = !=或&lt;&gt; &gt;= &gt; 逻辑运算符 not或! or或|| and或&amp;&amp; (符号的不推荐) 布尔值和null XX is true XX is false XX is null XX is not null in(n,m)在某集合内 (常用散列值) not in不在某集合内 between and 在某个范围内 not between and 不在某个范围之内 like "" 模糊匹配 (%匹配任意字符,_匹配单个字符) 对于含% 或 _的 需要转义\②分组 group by分组使用 一般要配合聚合函数(avg()sum()max()min()count(*)行数) 把行按某列(字段)进行分组 count(*) 每一组的数量的信息 哪怕都为null 也计算在内 select count(列名) from 表名 查询该列不为null的所有行的行数③筛选 having 对分组之后的数据结果集进行筛选 一般与as一起使用(主要用于结果集中) where 对原始数据进行筛选④排序 order by 将前面取得的数据以设定的字段排序 默认升序(asc) 降序desc 把行按某列(字段)进行排序 多列排序 order by 字段1 asc,字段2 desc⑤限制 limit order by price limit len 一般和order by一起配合使用 或limit n,m 从n开始取m个(注意n从0开始) 跳过n个 注: 顺序 where,group by,having,order by,limit 顺序不能颠倒 子查询 12345678910111213141516① where子查询 内层的查询结果作为外层的查询条件 select goods_id,cat_id,goods_nmae from goods where goods_id in (select max(goods_id) from goods group by cat_id) 使用 in(列子查询) 在某个范围内 使用 &gt; = &lt; 等运算符 使用 any(列子查询)(some) 当某字段对于子查询中任意一个值满足比较运算 则就算满足条件 select * from tab1 where id &gt; any(select f1 from tab2) 使用 all(列子查询) 当某字段对于子查询中所有值满足比较运算 才能算满足条件 select * from tab2 where f1 &gt; all(select id from tab1)② from子查询 将内层的查询结果当成一张新表 select goods_id,cat_id,goods_name from( select * from goods order by cat_id,goods_id desc) group by cat_id③ exist子查询 where exists(子查询) 子查询如果有数据 则exists结果为true,否则为false 要么全部取出,要么都不取出 select * from catgory where exist( select * from goods where goods.cat_id=catgroy.cat_id) 连接查询 1234567891011121314将两个或两个以上的表,连接起来 当作一个数据源,并从中取得所需要的字段①交叉连接 (笛卡尔积) 没有条件只是将所有数据行连接起来的结果 表1(n1个字段,n2行) 表2(m1个字段,m2行) 交叉连接结果 有n1+m1列 有n2+m2行 select * from 表一,表二 select * from 表一 join 表二②内连接查询 两表都有的相关数据则取出 交集 将在两表交叉连接之后的结果集中取得满足给定的连接条件的数据行,此连接条件通常是 表与表之间的外键关系.select xx from table1 inner jion table2 on table1.xx=table2.xx select xx from table1,table2 where table1.xx=table2.xx③左连接查询 以左表数据为准 查询右边的相关数据,查不到的补null select xx from table1 left jion table2 on table1.xx=table2.xx④右连接查询 以右表数据为准 查询左边的相关数据,查不到的补null select xx from table1 right jion table2 on table1.xx=table2.xx 联合查询union 123456789就是把2条或多条sql的查询结果合并成一个结果集满足条件 每条语句取出的列数(字段)必须相同1.完全相等的行将会被合并2.列名称未必要一致 列名称会使用第一条sql的列名称为准3.合并比较耗时 所以一般用 union all 可以避免合并4.union子句 写order by完全没意义 合并后的结果可以用order by5.如果第一个select语句中有别名,则order by子句中就必须使用该别名select 语句1 union [all|distinct(默认)] select 语句2注:一个查询需求,可以使用连接查询,也可以使用子查询得到,通常用连接查询,效率更高]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm、nrm和yarn的安装与使用]]></title>
    <url>%2Fnvm%E4%B8%8Enrm%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当我们同时在进行多个项目，而多个不同的项目所使用的node版本又是不一样的，或者是要用更新的node版本进行试验和学习。这种情况下，对于维护多个版本的node将会是一件非常麻烦的事情，而nvm就是为解决这个问题而产生的，他可以方便的在同一台设备上进行多个node版本之间切换，而这个正是nvm的价值所在。 nvm下载github上下载最新版本nvm nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置 nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。 Source code(zip)：zip压缩的源码 Sourc code(tar.gz)：tar.gz的源码，一般用于*nix系统 nvm安装安装方式特别简单,一路next就行. 安装完成命令行输入nvm 查看,如果出现nvm版本号和一系列帮助指令，则说明nvm安装成功(需要先配置) nvm修改配置在安装目录下找到settings.txt文件,打开后加上以下两句,将npm镜像改为淘宝的镜像，可以提高下载速度。node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ nvm使用 nvm version或nvm v 显示当前运行的nvm本版本 nvm list或nvm ls 显示所有已安装的node.js版本. nvm use &lt;version&gt; 切换到指定的node.js版本 nvm install &lt;version&gt; 安装需要的node.js版本. nvm uninstall &lt;version&gt; 卸载指定的node.js nvm list available 显示可下载node.js版本的部分列表 nrm是npm镜像源地址切换工具 全局安装 npm install -g nrm 查看当前可选的镜像源 nrm ls 123456npm ---- https://registry.npmjs.org/cnpm --- http://r.cnpmjs.org/taobao - https://registry.npm.taobao.org/nj ----- https://registry.nodejitsu.com/npmMirror https://skimdb.npmjs.com/registry/edunpm - http://registry.enpmjs.org/ 切换镜像源 nrm use taobao 可在.npmrc查看到 nrm test 测试各个源的链接时间 npm uninstall nrm -g 卸载nrm yarn的使用 安装 npm i -g yarn 初始化 yarn init 或 yarn init -y 安装项目依赖 yarn add axios 或 yarn add axios -S 或 yarn add axios --save 安装开发依赖 yarn add less --dev 或 yarn add less -D 卸载依赖 yarn remove less 安装全部依赖 yarn 或 yarn install]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2简单使用]]></title>
    <url>%2Fkoa2%2F</url>
    <content type="text"><![CDATA[Koa是一个新的web框架，由Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。通过利用async函数，Koa帮你丢弃回调函数，并有力地增强错误处理。Koa并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 kao1与koa2区别 koa1采用ES6中的Gnerator生成器函数+yield+promise来处理异步操作 koa2基于ES7中的async/await+promise来处理异步操作基本操作 安装 npm i koa -g安装nodemon监视文件改动自动重启服务器 npm i -g nodemon 使用 nodemon xx.js123456789// index.js 体验koa helloworldconst Koa = require('koa')const app = new Koa() // 生成服务器实例// ctx 是 koa的应用上下文 next 就是串联中间件的钩子函数app.use(async (ctx,next) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3000)// 在命令行执行 node index.js 然后在浏览器访问 localhost:3000 页面输出 hello world koa核心对象 context koa将Node.js的Request请求和Response响应对象封装到Context对象中，通过加工context对象就可以控制返回给用户的内容，koa的每一次请求都将创建一个context，并在中间件中被作为参数引用，context对象内置了一些常用属性，如context.state、context.app、context.cookie、context.throw等 12345678910111213141516171819202122const Koa = require('koa')const app = new Koa()// app.use(async (ctx,next) =&gt; &#123;// console.log(ctx) // 请求的上下文对象// console.log(ctx.request) // ctx的request对象// console.log(ctx.response) // ctx的response对象// ctx.body = 'hello world'// &#125;)app.use(async ctx =&gt; &#123; ctx.response.body = &#123; url: ctx.request.url, query: ctx.request.query, querystring: ctx.request.querystring &#125;&#125;)// 访问该地址 http://localhost:3000/?name=tew&amp;sex=1 页面打印如下/*&#123; url: "/?name=tew&amp;sex=1", query: &#123; name: "tew", sex: "1" &#125;, querystring: "name=tew&amp;sex=1"&#125;*/app.listen(3000) application web服务类 request http请求对象 response http响应对象 koa中间件 在koa一切的流程都是中间件 http请求都会流经预先配置好middleware中 在中间件的执行策略中使用compose将中间件组合在一起依次执行，通过next将控制权向下传递 每个中间件都会拿到http请求的上下文context12345678910111213// ./middleware/path.js 定义中间件function path(ctx) &#123; console.log(ctx.path, 'path')&#125;module.exports = function()&#123; return async (ctx, next) =&gt; &#123; path(ctx) await next() // 必须要有 next() &#125;&#125;// app.js 引入并使用中间件const path = require('./middleware/path')app.use(path()) koa-views 与 pug模板结合使用 npm i pug -S npm i koa-views -S1234567891011121314const Koa = require('koa')const app = new Koa()const views = require('koa-views')const &#123; resolve &#125; = require('path')app.use(views(resolve(__dirname, './views'),&#123; extension: 'pug'&#125;))app.use(async (ctx, next) =&gt; &#123; await ctx.render('index', &#123; you: 'Luke', me: 'Scott' &#125;)&#125;)app.listen(3333) 12345678910111213141516// views/index.pughtml(lang="en") head meta(charset="UTF-8") meta(name="viewport", content="width=device-width, initial-scale=1.0") meta(http-equiv="X-UA-Compatible", content="ie=edge") title Document link(rel="stylesheet", href="https://cdn.bootcss.com/twitter-bootstrap/4.1.0/css/bootstrap.min.css") body .container .row .col-md-8 h1 Hi #&#123;you&#125; p This is #&#123;me&#125; .col-md-4 p 测试动态 Pug 模板 puppeteer爬虫 npm i puppeteer -S123456789101112131415161718192021222324252627282930313233343536373839404142const url = `https://movie.douban.com/tag/#/?sort=U&amp;range=7,10&amp;tags=`const puppeteer = require('puppeteer')const sleep = time =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, time)&#125;)!(async () =&gt; &#123; console.log('target page') const browser = await puppeteer.launch(&#123; args: ['--no-sandbox'], dumpio: false &#125;) const page = await browser.newPage() await page.goto(url, &#123; waitUntil: 'networkidle2' &#125;) await sleep(3000) await page.waitForSelector('.more') for (let i=0;i&lt;10;i++)&#123; await sleep(3000) await page.click('.more') &#125; const result = await page.evaluate(() =&gt; &#123; var items = $('.list-wp a') var links = [] if (items.length &gt;= 1) &#123; items.each((index, item) =&gt; &#123; let doubanId = $(item).find('div').data('id') let title = $(item).find('.title').text() let rate = Number($(item).find('.rate').text()) let poster = $(item).find('img').attr('src').replace('s_ratio', 'l_ratio') links.push(&#123; doubanId, title, rate, poster &#125;) &#125;) &#125; return links &#125;) browser.close() console.log(result)&#125;)() koa-router 路由 npm i koa-router 安装路由123456789101112131415161718// 1. 项目目录新建router/index.jsconst router = require('koa-router') // 引入 koa-routerconst app = new router() // 初始化 routerconst mongoose = require('mongoose') // 引入mongooseapp.get('/movies/all', async (ctx, next) =&gt; &#123; // 定义路由 const Movie = mongoose.model('Movie') // 得到电影模型实例 const movies = await Movie.find(&#123;&#125;).sort(&#123; //查询所有movie并排序 'meta.createdAt': -1 &#125;) ctx.body = &#123; movies &#125;&#125;)// 2. 入口文件 index.index 使用router中间件const Koa = require('koa')const router = require('./router')const app = new Koa()// 引入路由app.use(router.routes()).use(router.allowedMethods())// 3. 浏览器测试路由 localhost:3000/movies/all koa-generator 安装 npm i -g koa-generator 创建项目 koa2 project 启动项目 npm run dev|npm start cookie 设置cookie ctx.cookies.set(&#39;timer&#39;, new Date().getTime()) 获取cookie ctx.cookies.get(&#39;timer&#39;)session]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端混合开发]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目前市场上主流的APP分为三种：原生APP、Web APP（即HTML5）和混合APP三种，相对应的定制开发就是原生开发、H5开发和混合开发。原生开发（Native App开发），是在Android、IOS等移动平台上利用提供的开发语言、开发类库、开发工具进行App软件开发。HTML5应用开发，是利用Web技术进行的App开发。Web技术本身需要浏览器的支持才能进行展示和用户交互，因此主要用到的技术是HTML5、Javascript、CSS等。混合开发（Hybrid App开发），是指在开发一款App产品的时候，为了提高效率、节省成本而利用原生与H5的开发技术的混合应用。 主流应用程序大体分为三类 Web App 采用Html5语言写出的web App，不需要下载安装，运行在手机浏览器中，开发成本低，更新快，不需要手动升级。但无法获取使用系统功能，设计受限制诸多，性能体验较差。 Hybrid App 半原生半Web的混合类App, 使用webview作为容器,来承载一个web页面,使用JSbridge进行原生和H5交互。可以快速进行迭代更新，无需审核，体验流畅。 Native App 原生程序，一般依托于操作系统，有很强的交互，是一个完整的App，可拓展性强。需要用户下载安装使用，性能稳定，操作速度快，用户体验好。 但不能跨平台，维护和开发成本高，更新缓慢，上线流程较复杂。 混合开发: 混合了Native(原生)技术和web技术进行开发移动应用的开发模式. 其他移动端产品形态ReactNative，Weex，Flutter，小程序开发，快应用，uni-app等 流行的混发开发方案 基于JS + WebView渲染(JSBridge)通过webview渲染UI,JSBridge给webview提供常用原生功能如: 摄像头、GPS、通信录等 基于JS + Native UI(ReactNative、Weex)开发技术仍然使用 JS 等 Web 元素，但 UI 渲染、动画、网络等都通过原生实现。JS 到原生的调用通过 JS 桥接器实现。 小程序方案(微信、支付宝小程序) 快应用 Hybrid App 适用场景 使用Native: 体验要求到极致,变化不频繁(如APP首页) 使用Hybrid: 体验要求高, 变化迭代频繁(如详情页) Hybrid App Hybrid本质是在原生(Native)App中,使用webview作为容器,来承载一个web页面Hybrid核心是原生(Native)和web端的双向通讯层(跨语言解决方案)JSBridgeJSBridge:用javascript链接web和Native的桥,目的是让Native可以调用web的javascript代码,也可以让web可以调用Native的原生代码 原生端调用web方法,web方法必须是挂载到web端window对象下面的方法构建JSBridge对象, JSBridge字符串会被挂载到网页的window对象下面 webview是app的一个组件, 用于加载h5页面, 是一个小型的浏览器内核 file协议就是打开本地文件,加载快 Hybrid 具体实现 前端将做好的静态页面文件交给客户端 客户端将静态页面文件,以本地文件形式存储在app中 客户端在一个webview中使用file协议加载静态页面 Hybrid 更新流程 前端将更新的静态文件上传到服务端server 客户端去服务端server下载最新静态文件 前端只需要维护server上的静态文件 JS和客户端通信 JS和客户端通讯的基本方式JS 访问客户端能力, 传递参数和回调函数客户端通过回调函数返回内容 schema协议使用和封装schema协议--前端和客户端通讯的约定 其他Hybird App`PhoneGap，APPcan，DCloud(mui)，wex5，APIcloud(aui)]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node服务端开发]]></title>
    <url>%2Fnode%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Node.js在server服务端开发常用模块，HTTP模块处理客户端的网络请求，URL模块用于处理与解析请求的URL， Query Strings模块处理客户端通过get/post请求传递过来的参数，Path模块文件路径处理服务，stream处理body提交数据，HTTPS模块 是基于TLS/SSL的HTTP协议，File System模块服务端操作文件或图片资源等，Net模块用于创建基于流的TCP或IPC的服务器。 nodejs的真正用途 运行在服务器, 作为web server 运行在本地 作为打包 构建工具 nodemon 监视文件改动，自动重启 npm i -g nodemon 启动 nodemon xx.js 创建http服务器12345678910111213141516171819202122232425262728// 引入核心对象httpconst http = require('http')// 创建服务const server = http.createServer((req, res) =&gt; &#123; // req IncomingMessage类的实例的对象，提供当前请求的客户端信息 // res ServerResponse类的实例对象，提供响应的相关方法 // console.log( req.httpVersion ); // 查看http版本 // console.log( req.method ); // 请求方法 // console.log( req.headers ); // 请求头 // console.log( req.url ); // 请求地址 // 设置并写入头信息 // res.writeHead(状态码, 状态码描述, 头信息) res.writeHead(200, http.STATUS_CODES[200], &#123; 'Content-Type': 'text/html;charset=utf-8' &#125;) // 设置头信息 // res.setHeader(头信息名称, 值); // res.getHeader(头信息名称); // 获取某个请求头 // res.removeHeader(头信息名称); // 删除某个请求头 // 头信息的写入与设置必须在res的write、end之前 res.setHeader('Content-Type', 'text/html;charset=utf-8') res.end()&#125;)// 监听端口及主机server.listen(4004, () =&gt; &#123; console.log('listening on port 4004') &#125;) server端开发注意事项 服务稳定性 避免恶意攻击和误操作 服务端不能随便挂掉 PM2进城守候 考虑内存和CPU(优化,扩展) 服务端承载很多请求 CPU和内存都是稀缺资源 stream写日志 使用redis存session 日志记录 服务端记录日志 存储日志 分析日志 安全 服务端要防止xss攻击和sql注入 集群和服务拆分 服务拆分来承载大流量 处理get请求get请求 客户端向服务器获取数据12345678910111213141516const http = require('http')const queryString = require('querystring');const server = http.createServer((req, res) =&gt; &#123; console.log('methods: ', req.method) const url = req.url console.log('url: ', url) req.query = queryString.parse(url.split('?')[1]) console.log('query: ', req.query) res.end(JSON.stringify(req.query))&#125;)server.listen(4004, () =&gt; &#123; console.log('server running on port 4004');&#125;)// 浏览打开 http://localhost:4004/?id=1&amp;name=tew// 客户端输出 输出 &#123;"id":"1","name":"tew"&#125;// 服务端输出 methods： GET url: /?id=1&amp;name=tew query: &#123; id: '1', name: 'tew' &#125; 处理post请求post请求 客户端要像服务端传递数据1234567891011121314151617181920const http = require('http')const server = http.createServer((req, res) =&gt; &#123; if(req.method === 'POST')&#123; console.log('content-type', req.headers['content-type']) let postData = '' req.on('data', chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on('end', () =&gt; &#123; console.log('postData', postData) res.end('hello world') &#125;) &#125;&#125;)server.listen(4004, () =&gt; &#123; console.log('server is running on port 4004');&#125;)// 使用 postman 发送post请求 并设置 content-type：application/x-www-form-urlencoded// 发送 请求体为 &#123;id:1, name:tew&#125;// 服务器端输出 content-type application/x-www-form-urlencoded postData id=1&amp;name=tew]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础(二)]]></title>
    <url>%2Fnode%E5%9F%BA%E7%A1%80(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Node.js 开发方向,GUI(图形用户界面 ), CLI(命令行界面), server(提供服务), CLI常用第三方工具: commander(命令行开发工具), chalk(命令行样式风格控制器),inquirer(交互式命令行工具). GUI开发桌面级应用第三方工具: NW.JS, Electron 开发方向 GUI-Graphical User Interface：图形用户界面office、vscode、浏览器、播放器…… CLI-Command-Line Interface：命令行界面，也称为 CUI，字符用界面虽然没有GUI操作直观，但是CLI更加节省计算机资源（所以一般用于服务器环境）babel、tsc / webpack / vue-cli Server - 服务提供（Web Server、IM……）12345command：命令，比如 vue[subCommand]：子命令，比如 vue create[options]：选项，配置，同一个命令不同选项会有不一样的操作结果，比如 vue -h，vue -v, 选项一般会有全拼与简写形式 全拼：以 -- 开头 / 简写：以 - 开头[arguments]：参数，某些命令需要使用的值，比如 vue create myApp选项与参数的区别：选项是命令内置实现，用户进行选择，参数一般是用户决定传入的值 CLI常用第三方框架commander 命令行开发工具 commander.parse(argv: string[]) 解析执行传入的 argv 命令字符串，通常改命令字符串来自用户在命令行的输入，process.argv， commander 同时会默认创建一个 -h, –help 的选项 commander.version(str, flags?) 设置版本信息，该方法会自动为命令注册一个 -V, –version 的 option， str：版本号，flags：指定的 option，默认为：”-V, –version” commander.option(flags, description?, fn?, defaultValue?) 设置命令选项，flags 中的格式可以接收参数，[] 可选 &lt;&gt; 必填 commander.action(fn)指定命令要执行的动作行为，该函数执行过程会接收到至少一个参数 如果命令中带有参数，则是对应的参数列表，参数的最后一个永远都是 commander 实例 commander.description(str) 命令描述 commander.alias(str) 设置命令别名 commander.usage(str) 设置或获取当前命令的使用说明 chalk 命令行样式风格控制器 安装 npm i chalk / yarn add chalk 引入 const chalk = require(&#39;chalk&#39;) 使用 console.log(chalk.blue(&#39;Hello world!&#39;)) chalk.hex(&#39;#DEADED&#39;), chalk.keyword(&#39;orange&#39;) ,chalk.rgb(15, 100, 204) inquirer 交互式命令行工具 安装 npm i inquirer 使用 require(&#39;inquirer&#39;) inquirer.prompt(questions).then(answers=&gt;{}) questions(type, name, message, default, choices, validate, filter) type: 提问类型，input, confirm, list, rawlist, expand, checkbox, password, editor GUI 图形用户界面(桌面应用) GUI 图形用户界面(桌面应用),使用JavaScript, HTML和CSS构建跨平台的桌面应用 基于Node.js的GUI框架 NW.JS 或 Electron]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常见问题(二)]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[WEB前端开发中，除了对PC端浏览器进行各浏览器兼容，移动端页面中android端和ios端的页面兼容也是有很多问题，特此整理一下遇到过的或者可能遇到的常见问题。 1. 解决页面使用overflow: scroll在iOS上滑动卡顿的问题在滚动的容器中增加: -webkit-overflow-scrolling: touch 2. input输入框ios的光标问题在ios上有时候看到光标和输入的文字错位比较明显 是因为设置了line-height导致的解决办法: 使用padding去撑开需要的高度,不使用line-height 3. 移动端click事件300ms的延迟移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效解决方案: fastclick插件可以解决在手机上点击事件的300ms延迟 使用zepto的tap事件也是为了解决在click的延迟问题 通过绑定ontouchstart事件,touchstart --&gt; touchmove --&gt; touchend --&gt; click 4. 在ios和andriod中,audio元素和video元素在无法自动播放123$('html').one('touchstart',function()&#123; audio.play()&#125;) 5. 如何在手机上实现弹出框弹出时，弹出框内可以上下滚动，背后的页面锁定不能滚动？弹出模态框 html,body{ height:100%; overflow:hidden }关闭模态框 html,body{ overflow: visble } 6. flex：固定宽度+flex：1 之后单行或多行省略不生效 在父级加 min-width：012345678910&lt;div class="wrap"&gt; &lt;div class="item"&gt;宽度不确定&lt;/div&gt; &lt;div class="item"&gt;&lt;p class="ellipsis"&gt;单行文字省略单行文字省略单行文字省略单行文字省略单行文字省略&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.wrap &#123; display: flex; &#125;.ellipsis &#123; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; &#125;/* 需要添加 .item &#123; min-width:0 &#125; 单行省略才能生效 */.item &#123; min-width: 0 &#125;&lt;/style&gt; 7. flex 多列布局中 将最后一列居右显示123// flex 垂直方向 单独设置某一列对象方式时 可以使用 align-self:flex-end// 但水平方向是没有这样的属性 但可以使用 margin-left: auto 来达到单独居右的效果.btn &#123; margin-left: auto; &#125; 8. ios的input设置disabled属性后默认样式问题12345678input:disabled, input[disabled]&#123; background-color : #fff; //修改默认灰色样式 filter: alpha(opacity=100); -webkit-text-fill-color:#bbb; //字体颜色安卓与IOS适配 -webkit-opacity:1; // 不透明级别安卓与IOS适配 opacity:1; color: #bbb;&#125; 9. ios input自动填充后出现黄色背景问题12345// 解决ios浏览器中 input自动填充黄色背景问题input:-webkit-autofill,input:-webkit-autofill:focus&#123; // -webkit-text-fill-color: #fff !important; transition: background-color 55000s ease-in-out 0s;//设置5000s后改变填充密码框的背景色，使背景透明&#125; 10. 鉴于clip裁切隐藏是最佳可访问隐藏1234.clip&#123; position:absolute; clip:rect(0,0,0,0)&#125; 11. ios机型margin属性无效问题？最底部元素的margin-bottom在safari里失效,直接padding代替margin 12. ios绑定点击事件不执行？ ios手机,事件委托失效添加样式cursor:pointer 消除背景的css -webkit-tap-highlight-color:transparent$(&#39;body&#39;).on(&#39;click&#39;,selector,function(){}) 点击无效时,只需要css设置 selector { cursor: pointer; }即可 13. h5底部输入框被键盘遮挡问题 让dom元素出现在可见视图的顶部或底部document.querySelector(&#39;#inputId&#39;).scrollIntoView(); 14 .ios页面橡皮弹回效果遮挡页面选项卡？(1) 有时body和html的height: 100%去除掉问题可能就没有了。(2) 到达临界值的时候在阻止事件默认行为1234567891011121314151617var startY,endY;//记录手指触摸的起点坐标$('body').on('touchstart',function (e) &#123; startY = e.touches[0].pageY;&#125;);$('body').on('touchmove',function (e) &#123; endY = e.touches[0].pageY; //记录手指触摸的移动中的坐标 //手指下滑，页面到达顶端不能继续下滑 if(endY&gt;startY&amp;&amp; $(window).scrollTop()&lt;=0)&#123; e.preventDefault(); &#125; //手指上滑，页面到达底部能继续上滑 if(endY&lt;startY&amp;&amp; $(window).scrollTop()+ $(window).height()&gt;=$('body')[0].scrollHeight)&#123; e.preventDefault(); &#125;&#125;) 15. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决 16. 屏蔽手机系统自带软键盘(用于自定义键盘)&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; unselectable=&quot;on&quot; onpaste=&quot;return false&quot; onfoucs=&quot;this.blur()&quot; /&gt;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常见问题(一)]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[移动端的开发由于设备的不统一会造成一些兼容性问题，经常会困扰许多web前端开发者，自从接触移动端以来也遇到过很多问题，低端机性能差容易卡顿，h5和css3新的api在低版本兼容性差等。 移动端常见的meta标签12345678910111213&lt;!-- 自适应屏幕大小 页面的宽度与设备的宽度保持一致，最大和最小缩放比例是1，且不允许用户点击屏幕放大 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/&gt;&lt;!-- 优先使用最新版本 IE 和 Chrome --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;!-- 启用双核浏览器的极速模式(webkit) --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 禁止手机号码和邮箱自动识别 --&gt;&lt;meta name="format-detection" content="telephone=no, email=no"/&gt;&lt;!-- 启用 WebApp 全屏模式 --&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;meta name="apple-touch-fullscreen" content="yes" /&gt;&lt;!-- 不使用缓存 --&gt;&lt;meta http-equiv="Cache-Control" content="no-cache" /&gt; 移动端常用的css技巧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 去除元素被触摸时产生的半透明灰色遮罩的高亮效果 */*&#123; -webkit-tap-highlight-color: rgba(0,0,0,0)&#125;/* 禁止文字缩放 */html &#123; -webkit-text-size-adjust: 100%;&#125;/* 清除输入框内阴影 清除按钮圆角 */input,textarea,select &#123; border: 0; -webkit-appearance: none; border-radius:0;&#125;/* 移动端禁止选中内容 */div &#123; -webkit-user-select: none; /* Chrome all */ -moz-user-select: none; /* Firefox all */ -ms-user-select: none; /* IE 10+ */&#125;/* 自定义placeholder的颜色 */input::-moz-placeholder,textarea::-moz-placeholder&#123;color:#ccc;&#125;input:-ms-input-placeholder,textarea:-ms-input-placeholder&#123;color:#ccc;&#125;input::-webkit-input-placeholder,textarea::-webkit-input-placeholder&#123;color:#ccc;&#125;/* 清除浮动 */.clearfix:before,.clearfix:after&#123;content:"";display:table;clear:both;&#125;/* 单行文本省略 */.ellipsis&#123; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; -webkit-text-overflow:ellipsis&#125;/* 多行文本省略 */.elli-two&#123; text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125;/*1px边框*/.onepx &#123; position: relative;&#125;.onepx::before &#123; content: ''; display: block; width: 200%; height: 200%; position: absolute; left: 0; top: 0; pointer-events:none; /* 屏蔽鼠标事件 */ transform: scale(0.5); -webkit-transform: scale(0.5); transform-origin: 0 0; -webkit-transform-origin: 0 0;&#125;/* 上下拉动滚动条时卡顿、慢 */body &#123; -webkit-overflow-scrolling:touch; overflow-scrolling: touch;&#125;/* iphone及ipad下输入框默认内阴影 */input, select &#123; -webkit-appearance:none; &#125;/* 滚动条美化 *//*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 7px; height: 7px; background-color: #F5F5F5;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track &#123; box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); border-radius: 10px; background-color: #F5F5F5;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 10px; box-shadow: inset 0 0 6px rgba(0, 0, 0, .1); -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .1); background-color: #c8c8c8;&#125; 其他 拨打电话 &lt;a href=&quot;tel:15509271855&quot;&gt; 请拨打电话1550971855&lt;/a&gt; 发送邮件 &lt;a href=&quot;mailto:tew@163.com&quot;&gt; 请拨打电话1550971855&lt;/a&gt; 长按在移动端执行顺序 touchstart touchmove touchend mousemove mousedown mouseup click]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础(一)]]></title>
    <url>%2Fnode%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Node.js 是一个基于事件驱动、非阻塞I/O的Web服务器,采用Chrome V8 引擎, node.js具有异步I/O处理, 事件与回调函数, 单线程, 跨平台等特点. 优点: 高并发, 适合I/O密集型应用, 缺点: 不适合CPU密集型应用. node安装nodejs下载 注:windows 下载后缀为 .msi mac 下载后缀为 .pkg 命令行运行node.js文件 node 文件路径node特点 主线程是单线程(异步)callback,将后续的逻辑写成函数,传入当前执行的函数中,当执行的函数得到结果后,执行传入的函数(回调函数) web中的异步 setTimeout callback onclick ajax i/o操作 读写操作, 异步读写 event-driven 事件驱动(发布订阅) nodejs基础篇 全局对象 global 类似浏览器全局对象window,但node环境中没有window console对象 console.log(),console.error(),console.warn()等 __dirname 当前文件(模块)所在目录 __filename 当前文件(模块)的文件名称(包含文件绝对路径) 全局变量 可以不声明直接使用 console process 进程 设置环境变量 process.env process.nextTick()异步 Buffer 缓冲区 模块化 模块化 用来模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能 模块化系统 1. 定义模块 2. 模块导入(依赖) 3.模块导出 一个文件就是一个独立的模块 模块加载采用同步模式 通过require函数导入, exports对象导出 模块 在node中,文件和模块都是一一对应的的,也就是一个文件就是一个模块,每个模块都有自己的作用域,我们通过var声明的变量并非全局而是该模块作用域下的, 外部不能直接访问 模块的加载和使用 require(‘模块’) 模块的路径可以是绝对路径(/a.js)也可以是相对路径(./a.js)模块路径如果没有以/或者./开头,那么这个模块要么是核心模块 要么是node_modules文件夹下 模块加载机制 文件名称 -&gt; .js -&gt; .json -&gt; .node 首先按照加载的模块的文件名称进行查找 如果没有找到,则会在文件名称后加上.js的后缀,进行查找 如果还没有找到,则会在文件名称后加上.json后缀,进行查找 如果还没有,则会在文件名称后加上.node的后缀,进行查找 最后还是没找到则会报错 Cannot find module ‘./est’` 如果我们想一个模块能够访问另外一个模块定义的变量,可以用以下方法 把变量作为global对象的一个属性值,但是这样的做法不推荐(污染全局变量) 使用模块对象module下的exports对象将模块中的局部变量对外提供访问 module.exports === exports 但不要为他们重新赋值 导出 module.exports = xxx 导入 require(‘xxx’)1234// tew/a.js tew/b.jsrequire('b.js') // a.js 引入文件 b.js// tew/index.jsrequire('./tew') // 引入文件夹时可简写 等同于 require('./tew/index.js') Event(事件) 事件是整个 Node.js 的核心，Node.js中大部分模块都使用或继承了该模块（类似 WebAPI 中的EventTarget） 使用: require(‘event’) 123456EventEmitter 类 .emit(eventName[, ...args]) .addListener(eventName, listener) .on(eventName, listener) .off(eventName, listener) .removeListener(eventName, listener) Process(进程) process 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程, 作为一个全局变量, 无需使用 require() process.argv 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。 第一个元素是 process.execPath。 第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数。 12345678console.log(process.argv)// node process app -i[ 'C:\\Program Files\\nodejs\\node.exe', // 执行路劲 'C:\\Users\\Administrator\\Desktop\\tew\\process', // 文件路径 'app', // 命令行参数 '-i' // 命令行参数] process.env 属性返回包含用户环境的对象, 如获取或设置node运行的环境变量 process.exit() 可以用来立即退出进程。即使当前有操作没执行完 process.cwd() 当前的工作目录 process.stdin或process.stdout 进程的标准输入、标准输出123456process.stdout.write('请输入你要创建的项目名称:')process.stdin.on('data', (e) =&gt; &#123; fs.mkdirSync(e.toString().replace('\r\n', '')) process.stdout.write('项目创建成功') process.exit()&#125;) Buffer 用于操作二进制数据的类 类似数组 长度固定 只能操作二进制数据12345678910// 创建const buf1 = Buffer.alloc(10)const buf2 = Buffer.from('buffer')const buf3 = Buffer.from([1,2,3])// 写入buf1.write('hello')// 读取console.log(buf1.toSring())// 合并Buffer.concat([buf1, buf3]) 通过长度定义 12345var buffer = Buffer.alloc(6)console.log(buffer) // &lt;Buffer 00 00 00 00 00 00&gt;var buffer = Buffer.allocUnsafe(6)console.log(buffer) // &lt;Buffer 00 00 00 00 4f 00&gt;console.log(buffer.length) // 6 通过数组定义 123var buffer = Buffer.from('阿萨达')console.log(buffer) // &lt;Buffer e9 98 bf e8 90 a8 e8 be be&gt;console.log(buffer.length) // 9 字符串创建 123var buffer = Buffer.from([1, 'a', '阿'])console.log(buffer) // &lt;Buffer 01 00 00&gt;console.log(buffer.length) // 3 常用buffer方法 buffer.fill() 填充buffer中的内容 buffer.toString() 将buffer转化为字符串 buffer.slice() 截取想要的buffer buffer.copy() 拷贝buffer buffer.concat() 拼接buffer buffer.isBuffer() 判断是否是buffer类型 FileSysterm fs模块提供了一些与文件系统进行交互的 API,使用需要引入require(‘fs’),fs中的方法都是由同步和异步组成 写入数据到文件 fs.writeFileSync(file, data[, options], callback) 文件追加内容 fs.appendFileSync(‘./1.txt’, ‘ 我是追加的内容’) 读取文件内容 content = fs.readFileSync(‘./1.txt’) 获取文件其他信息 info = fs.statSync(‘./1.txt’)常用: info.size 文件大小 info.isFile() 是否是文件 info.isDirectory() 是否是目录 删除文件 fs.unlinkSync(‘1.txt’) 判断文件、目录是否存在 fs.existsSync(‘./yn’) 创建目录 不会进行递归创建 fs.mkdirSync(‘./yn’) 删除目录 fs.rmdirSync(‘./yn’); 读取目录 files = fs.readdirSync(‘../node’)文件操作时最好将路径使用path.resovle或path.join转化 且路径中不能有中文否则会报错 1234567891011121314151617181920212223242526272829303132333435// 递归删除文件及目录function rmAll(dirPath) &#123; if (fs.existsSync(dirPath)) &#123; // 路径或文件是否存在 let state = fs.statSync(dirPath) //读取路径或文件属性 if (state.isDirectory()) &#123; // 是目录 let files = fs.readdirSync(dirPath) //路径信息 files.forEach( child =&gt; &#123; rmAll(path.join(dirPath, child)) &#125;) fs.rmdirSync(dirPath) // 删除文件夹 &#125; else if(state.isFile())&#123; // 是文件 fs.unlinkSync(dirPath) &#125; &#125; else &#123; console.log('该文件或文件夹不存在') &#125;&#125;rmAll('./yn')// 遍历文件function readFile(dirPath) &#123; if (fs.existsSync(dirPath)) &#123; // 路径或文件是否存在 let state = fs.statSync(dirPath) //读取路径或文件属性 if (state.isDirectory()) &#123; // 是目录 let files = fs.readdirSync(dirPath) //路径信息 files.forEach(child=&gt; &#123; readFile(path.join(dirPath, child)) &#125;) &#125; else if(state.isFile())&#123; // 是文件 console.log(dirPath) &#125; &#125; else &#123; console.log('该文件或文件夹不存在') &#125;&#125;readFile('../') 更多node文件操作请查看 Node.js 中文网 核心对象path 引入path const path = require(&#39;path&#39;) 拼接路径 path.join(__dirname,&#39;a&#39;,&#39;b&#39;) c:tew/a/b 相对路径转绝对路径 path.resovle(&#39;./xxx&#39;) 接收一个合法的路径字符串，转换成一个对象 let pathObj = path.parse(mypath) 接收一个路径对象，转换成一个字符串路径 let str = path.format(pathObj) 取文件后缀名 path.extname(&#39;1.js&#39;) stream流123const rs = fs.createReadStream('./conf.js')const ws = fs.createWriteStream('./conf2.js')rs.pipe(ws)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element初次使用]]></title>
    <url>%2Felement%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库，提供了配套设计资源，帮助你的网站快速成型，由饿了么公司前端团队开源。多用于开发PC网站及后台管理系统。 Element-UI 入门官网地址: Element-UI 基本用法-全局引入 初始化项目 vue create element-test 安装 npm i element-ui -S 或在已有项目中全局引入 1234// 项目入口 main.js中引入import ElementUI from 'element-ui'Vue.use(ElementUI) // 作为插件使用import 'element-ui/lib/theme-chalk/index.css' // 引入样式 在组件中使用 12345678910111213141516&lt;template&gt; &lt;div id="app"&gt; &lt;el-button type="success" @click="show"&gt;点我&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', methods: &#123; show() &#123; this.$message.success('Toast from element-ui') &#125; &#125;&#125;&lt;/script&gt; 全量引入npm run build打包后vendors体积较大 按需加载 安装babel-plugin-component npm install babel-plugin-component -D 修改 babel.config.js 123456789101112&#123; "presets": [["es2015", &#123; "modules": false &#125;]], "plugins": [ [ "component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125; ] ]&#125; 在组件中按需引入 123456789101112131415161718&lt;template&gt; &lt;div id="app"&gt; &lt;el-button type="success" @click="show"&gt;点我&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Button, Message &#125; from 'element-ui'export default &#123; name: 'app', components: &#123; Button &#125;, methods: &#123; show() &#123; Message.success('Toast from element-ui') &#125; &#125;&#125;&lt;/script&gt; 在vue-cli@3.x以上作为插件引用 在vue-clie3项目中使用 vue add element 可以看见它在安装 vue-cli-plugin-element 选择引入方式 Fully import 全量引入 Import on demand 按需引入 安装完成 和自行按需引入一样 引入组件只需要在src/plugins/element.js 中添加你使用到的组件即可123456import Vue from 'vue'import &#123; Button, Form, FormItem, Input &#125; from 'element-ui'Vue.use(Button)Vue.use(Form)Vue.use(FormItem)Vue.use(Input) 表单基本用法 el-form容器， 通过model绑定数据 el-form 容器，通过 model 绑定数据 表单组件通过 v-model 绑定 model 中的数据12345678910111213141516171819&lt;template&gt; &lt;div id="app"&gt; &lt;el-form inline :model="data"&gt; &lt;el-form-item label="审批人"&gt; &lt;el-input v-model="data.user" placeholder="审批人"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data() &#123; return &#123; data: &#123; user: 'sam', region: '区域二' &#125; &#125; &#125;&#125;&lt;/script&gt; 表单校验基本用法定义校验规则，可以绑定到 el-form 或 el-form-item, 只需要通过 rules 属性传入约定的验证规则,并指定 el-form-item 的 prop 属性为需校验的字段名即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div id="app"&gt; &lt;el-form inline :model="data" :rules="rules" hide-required-asterisk&gt; &lt;el-form-item label="审批人" prop="user" &gt; &lt;el-input v-model="data.user" placeholder="审批人"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="primary" @click="submitForm('ruleForm')"&gt;查询&lt;/el-button&gt; &lt;el-button type="primary" @click="resetForm('ruleForm')"&gt;清空&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data () &#123; return &#123; data: &#123; user: 'sam', region: '区域二' &#125;, rules: &#123; user: [ &#123; required: true, trigger: 'change', message: '用户名必须输入' &#125;, &#123; validator: (rule, value, callback) =&gt; &#123; if (value.length &gt; 3) &#123; callback() &#125; else &#123; callback(new Error('用户名长度必须大于3')) &#125; &#125;, trigger: 'change' &#125; ] &#125; &#125; &#125;, methods: &#123; // 对整个表单进行校验的方法 submitForm (formName) &#123; // 提交验证 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; alert('submit!') &#125; else &#123; console.log('error submit!!') return false &#125; &#125;) &#125;, // 对该表单项进行重置，将其值重置为初始值并移除校验结果 resetForm (formName) &#123; // 清空表单 this.$refs[formName].resetFields() &#125; &#125;&#125;&lt;/script&gt; 表单相关属性或方法 label-position：标签位置，枚举值，left right和 top label-width：标签宽度 inline：行内表单 disabled: 设置整个 form 中的表单组件全部 disabled，优先级低于表单组件自身的 disabled hide-required-asterisk：隐藏必须输入红色星号标识` inline-message：验证消息是否在一行显示` size：设置表单组件尺寸 取值为medium/small/mini status-icon：属性为输入框添加了表示校验结果的反馈图标。 validate(callback): 对整个表单进行校验的方法，参数为一个回调函数 resetFields(): 对整个表单进行重置，将所有字段值重置为初始值并移除校验结果]]></content>
      <categories>
        <category>element</category>
      </categories>
      <tags>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex与vue-router]]></title>
    <url>%2Fvuex%E4%B8%8Evue-router%2F</url>
    <content type="text"><![CDATA[vuex和vue-router是vue生态系统中的很重要的两个工具。vuex 是vue用来管理数据状态的一种机制，将Vue中所有的状态（数据）抽离出来进行统一管理。Vue Router 是 Vue.js 官方的路由管理器。它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌，是SPA（单页应用）的路径管理器。 Vuex Vuex是一个专门为vue.js应用程序开发的状态(数据)管理模式.它采用集中式存储应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化. Vuex使用场景：多个视图依赖于同一状态或相同数据， 来自不同视图的行为需要 使用方式 npm install vuex -S 安装vuex模块 import Vuex from &#39;vuex&#39; 引入vuex模块 Vue.use(Vuex) 作为插件使用 new Vuex.Store() 定义store容器 new Vue({store}) 注入到根实例中123456789101112// src/store/index.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) // 将vuex作为插件使用let store = new Vuex.store(&#123;&#125;) // 定义store容器export default store // 将store导出// main.jsimport store from './store'new Vue(&#123; el: "#app", store, // 将store注入到根实例中&#125;) Vuex核心概念 Store 类似容器 包含应用的大部分状态 不建议直接修改state中的状态 使用提交mutations显式修改 State 包含所有应用级别状态的对象 1234567// 定义store容器let store = new Vuex.Store(&#123; state: &#123; conut: 10 &#125;&#125;)// 组件内取出状态（数据） hello.vuethis.$store.state.count// Getters 对state数据进行处理 在组件内部获取store中的状态函数 12345678910111213141516let store = new Vuex.Store(&#123; state: &#123; shopList: [&#123; id: 123, count: 20 &#125;,&#123; id: 124, count: 30 &#125;] &#125;, getters: &#123; // gettres可以定义为一个函数 total(state)&#123; return state.shopList.reduce((prev, item) =&gt; prev + item.count, 0) &#125; &#125;&#125;)//xx.vue 中使用this.$store.getters.total Mutation vuex的state状态更新的唯一方式提交mutationsMutation主要包含两部分 type 字符串的事件类型 handle该回调函数的第一个参数就是statemutation必须是同步更新状态，不要在mutation中进行异步的操作 12345678910111213mutations: &#123; // 第一个默认参数是state 第二个参数 payload是commit传递过来的值 可以是对象 updateCount(state, payload)&#123; state.count += payload.add &#125;&#125;methods: &#123; // 修改store中state的数据 提交一个mutations // 如果不包含异步操作 可以直接在组建中 使用commit提交mutations changeState()&#123; this.$store.commit('updateCount', &#123;add: 5&#125;) &#125;&#125; Action 包含异步操作都放在action里面 提交mutations改变状态context是和store对象具有相同方法和属性的对象，在action中可以通过context进行commit一个mutations操作，也可以获取context.state等。在vue组件中调用 this.$store.dispatch(‘action’)去触发action。可以将异步操作放在一个Promise中，并且成功或者失败后，调用对应的resolve或reject 12345678910111213141516171819// action 中返回一个promiseactions: &#123; increment(context) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; // 异步操作 context.commit('incrementMutation') resolve() &#125;, 2000) &#125;) &#125;&#125;methods: &#123; incrementHandle()&#123; // 派发action操作 this.$store.dispatch('increment').then(res =&gt; &#123; console.log('完成更新操作') &#125;) &#125;&#125; Module 模块Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等module下的局部状态通过state获取， 根节点(全局)的状态则通过rootState获取 123456789// 获取全局的stateconst moduleA = &#123; action: &#123; test(&#123;state, commit, rootState&#125;)&#123;&#125; &#125;, getters: &#123; test(state, getters, rootState)&#123;&#125; &#125;&#125; 使用vuex-persistedstate实现vuex持久化vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态, 使用此插件可以将state存储到localstorage或sessionstorage中 123456import createPersistedState from "vuex-persistedstate"const store = new Vuex.Store(&#123; plugins: [createPersistedState(&#123; storage: window.sessionStorage &#125;)]&#125;) Vuex的工具函数/语法糖/钩子函数 ...mapState([&#39;count&#39;]) 取state中的数据 ...mapGetters([&#39;total&#39;]) 对state数据的处理 ...mapMutations([&#39;updateCount&#39;]) 调用mutations执行同步操作 ...mapActions([&#39;updateCountSync&#39;]) 调用action提交mutations执行异步操作12345678910111213141516// index.vueimport &#123; mapState,mapGetters,mapMutations,mapActions &#125; from 'vuex'new Vue(&#123; computed()&#123; // mapState 和 mapGetters 需要放在computed中 ...mapState(['count']), // 后面还有内容时 需要加上 逗号，state数据放在字符串数组中 ...mapState('goods', ['count']), // 有modules ...mapGetters(['total']), ...mapGetters('goods', ['total']), // 有modules &#125;, methods: &#123; // mapMutations 和 mapActions 需要放在 methods中 ...mapMutations(['updateCount']), // 后面还有内容时 需要加上 逗号，方法放在字符串数组中 ...mapMutations('goods', ['updateCount']), // 有modules ...mapActions(['updateCountSync']), ...mapActions('goods', ['updateCountSync']), // 如果是某个modules下action需要加namespaced命名空间 &#125;&#125;) vuex实现原理使用 Vue 实例管理状态,只能在vue中使用 Vue Routervue-router实现原理 SPA(single page application) 单页面应用程序 页面url改变, 但页面不进行整体的刷新 Hash模式 12// vue-router 默认 hash 模式 hash模式会在url中自带#// Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 onhashchange 事件(监测hash值变化) History模式 1234567// 用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用了html5 history interface 中新增的 pushState() 和 replaceState() 方法。// 对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求// 需要后台配置支持 后台没有正确的配置 就会返回 404 如nginx配置/* location / &#123; try_files $uri $uri/ /index.html;&#125; */// &#123;path: "*", redirect: "/"&#125;] 前端路由设置 如果URL输入错误 路由不存在 自动跳到到首页 或设置404页面 基础配置 安装 npm install vue-router --save 配置路由文件 router/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// router/index.js// 引入vue-router插件import Router from 'vue-router'// 安装路由插件routerVue.use(Router)// 生成路由实例// Router 常用参数// routes: [] 路由信息 mode: 'hash' 路由模式 linkActiveClass: 'highlight' 路由高亮// scrollBehavior(to,from,savedPosition) 滚动行为 fallback:true 对于不支持history路由时, 自动跳转到hash模式下let router = new Router(&#123; // 配置组件和路由的映射关系 // 定义路由模式 默认为 hash mode: 'history', // 需要后端配合 // 设置当前路由高亮样式 linkActiveClass: 'is-active', // 配置组件和路径的映射关系 routes 常见参数 // path: '/home' redirect: '/app' 重定向 name: 路由名称 component: 'todo' 路由组件 // meta: 元信息 设置meta信息 children: [&#123;&#125;] 子路由 嵌套路由 routes: [&#123; path: '/', redirect: '/index' // 将根路径重定向到首页 &#125;, &#123; path: '/index', name: Home, component: Home &#125;, &#123; path: '/Management', name: 'Management', component: Layout, children:[&#123; path: '/project', name: 'Project', component: Project, meta: &#123; login: true, title: '标题', auth: true &#125; &#125;] &#125;]&#125;)new Vue(&#123; el: '#app', router, // 将路由挂载到Vue实例中&#125;)// app.vue 中&lt;router-view&gt;路由对应组件显示的位置&lt;/router-view&gt; 通过&lt;router-link&gt;和&lt;router-view&gt;使用声明式路由&lt;router-view /&gt; 组件显示的位置&lt;router-link to=&quot;/index&quot; tag=&quot;li&quot;&gt;主页&lt;/router-link&gt; 跳转链接tag可以指定&lt;router-link&gt;之后渲染成什么标签,默认是a 编程式导航跳转this.$router.push() 会向history栈添加一个新的记录并导航到改URL下 this.$router.push(&#39;index&#39;) 字符串 this.$router.push({ name: &#39;user&#39;, params: { userId: &#39;123&#39; }}) 命名的路由 使用的是name和params 如果使用path则params无效 this.$router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }}) 带查询参数 使用的是path和querythis.$router.replace() 它不会向 history 添加新记录, 替换掉当前的 history 记录。this.$router.go(n) 在 history 记录中向前或者后退多少步 this.$router.go(1) 在 history 记录中前进一步，等同于 history.forward() this.$router.go(-1) 在 history 后退一步记录，等同于 history.back() $router与$route $router 路由实例对象 使用new VueRouter创建的实例，包括了路由的跳转方法，钩子函数等。常用于编程式导航 $route 当前路由信息对象 在组件内部可以通过 this.$route 的方式进行调用。 123456// 1. $route.fullPath 为当前路由的全路径// 2. $route.path 为当前路由的绝对路径// 3. $route.params 包含路由中动态片段和全匹配片段的键值对// 4. $route.query 包含路由中查询参数的键值对// 5. $route.name 当前路由设置的name属性。// 6. $route.meta 当前路由元信息 $route与$router的区别$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法$route为当前路由对象，里面可以获取name、path、query、params等 滚动行为12345678910111213141516//点击浏览器的前进后退或切换导航时触发scrollBehavior(to,from,savePosition)&#123; console.log(to) //要进入的目标路由对象 要到哪里去 console.log(from) //离开的路由对象 从哪里离开 console.log(savaPosition) //记录滚动条的坐标 点击前进后退的时候记录值 if(savePosition)&#123; return savePosition // 滚动到记录的位置 &#125;else&#123; return &#123;x:0, y:0&#125; &#125; if(to.hash)&#123; // 滚动到某锚点 return &#123; selector:to.hash &#125; &#125;&#125; 路由传参传递参数方式一: &lt;router-link&gt;123456&lt;router-link :to="&#123; path: '/detial/:id' // params形式 query: &#123; name: 'tew', age: '28' &#125; // query模式 &#125;"&gt;简介&lt;/router-link&gt; 传递参数方式二: JavaScript代码1234this.$router.push(&#123; path: '/detial/:id', query: &#123; name: 'tew', age: '28' &#125;&#125;) 传递参数主要有两种类型: params和query123456789101112/*params的类型: 配置路由格式: /router/:id 传递的方式: 在path后面跟上对应的值 传递后形成的路径: /router/123, /router/abc 通过this.$route.params 获取params方式参数query的类型: 配置路由格式: /router, 也就是普通配置 传递的方式: 对象中使用query的key作为传递方式 传递后形成的路径: /router?id=123, /router?id=abc 通过this.$route.query 获取query方式参数*/ 路由导航守卫全局路由导航守卫 router.beforeEach(to, from, next) 全局前置守卫 常用beforeEach来完成页面标题的修改. router.beforeResolve(to, from, next) 全局解析守卫 router.afterEach(to, from, next) 全局后置守卫 123456789101112// 每个守卫方法接收三个参数// to: 即将要进入的目标 路由对象// from: 当前导航正要离开的路由// next: 同意跳转 进行下一步执行 resolverouter.beforeEach((to, from, next) =&gt; &#123; // 路由跳转前的特定的业务逻辑 修改路由跳转、设置title等 NProgress.start() // start progress bar document.title = to.meta.title // 设置页面标题&#125;)router.afterEach(() =&gt; &#123; NProgress.done() // finish progress bar&#125;) 路由独享的守卫在路由配置上直接定义 beforeEnter1234567const router = new VueRouter(&#123; routes: [&#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123;&#125; &#125;]&#125;) 组件内的守卫 beforeRouteEnter beforeRouteUpdate 路由参数更新时触发 详情页面id变化 mounted里的函数只执行一次的问题 可以代替watch beforeRouteLeave 12345678910111213141516171819const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` 因为当守卫执行前，组件实例还没被创建 // 但可以使用 通过 `vm` 访问组件实例 next(vm =&gt; &#123;&#125;) &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` // 生命周期 beforeDestroy/destroyed 在beforeRouteLeave 之后 &#125;&#125; 使用router.addRoutes动态添加路由123this.$router.addRoutes([&#123; path: '/test', component: Test, meta: &#123; title: 'test'&#125;&#125;]) 路由守卫触发过程 导航被触发 调用全局的beforeEach前置守卫 在重用的组件里调用beforeRouterUpdate守卫 在路由配置里面调用路由独享守卫 调用被激活组件的beforeRouterEnter守卫 调用全局的beforeResolve守卫 调用全局的afterEach后置守卫 触发DOM更新 keep-alive与 vue-router123456789101112// keep-alive 是 Vue 内置的组件，可以使被包含的组件保留状态，或避免重新渲染。// 它们有两个非常重要的属性:// include - 字符串或正则表达，只有匹配的组件会被缓存// exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存// router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：// 组件使用keep-alive专有 生命周期// activated: function()&#123; console.log('activated') &#125;// deactivated: function()&#123; console.log('deactivated') &#125;// Detail,City 不被缓存组件name&lt;keep-alive exclude="Detail, City"&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; vue项目实现按需加载或懒加载的3种方式 路由懒加载的主要作用就是将每个路由对应的组件打包到单独的js中.只有在这个路由被访问到的时候, 才加载对应的组件 vue异步组件 AMD 123456789101112// vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .// 但是,这种情况下一个组件生成一个js文件/* vue异步组件技术 */&#123; path: '/home', name: 'home', component: resolve =&gt; require(['@/components/home'],resolve)&#125;, &#123; path: '/index', name: 'Index', component: resolve =&gt; require(['@/components/index'],resolve)&#125; 路由懒加载(使用import) 123456// 没有指定webpackChunkName，每个组件打包成一个js文件。/* const Home = () =&gt; import('@/components/home')const Index = () =&gt; import('@/components/index')// 指定了相同的webpackChunkName，会合并打包成一个js文件。 把组件按组分块*/const Home = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home')const Index = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/index') webpack的require.ensure() 12345678910// 使用webpack的require.ensure, 多个路由指定相同的chunkName，会合并打包成一个js文件。&#123; path: '/home', name: 'home', component: r =&gt; require.ensure([], () =&gt; r(require('@/components/home')), 'demo')&#125;, &#123; path: '/index', name: 'Index', component: r =&gt; require.ensure([], () =&gt; r(require('@/components/index')), 'demo')&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信的多种方式]]></title>
    <url>%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件是vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。而组件间的通信成为必须解决的话题。vue中组件通信的方式有很多：props/$emit、vuex、eventBus（总线）、provide/inject、$parent/$children/ref、$attrs/$listeners等 props/$emit 适合父子组件通信 子组件获取父组件data可以在父组件上使用自定义属性绑定（传递）数据(动态的数据需使用 :m=&#39;msg&#39;,静态的不需要加),在子组件中需要显式的用props声明自定义属性名（接收数据） 123456789101112// &lt;father :msg="动态数据" /&gt; 传递的是变量// &lt;father msg="静态数据" /&gt; 传递的是字符串// 父组件 list: [1,2]&lt;child :msg="list" test="list" /&gt;// 子组件接收export default &#123; props: ['msg', 'test'], mounted () &#123; console.log(this.msg) // [1, 2] console.log(this.test) // list &#125;&#125; 父组件获取子组件数据/子组件向父组件传值需要用到自定义事件,父组件用$on监听自定义事件,子组件使用$emit触发父组件关联的自定义事件 1234567891011121314151617181920212223242526&lt;template&gt; &lt;child @childMsg="getChildData" /&gt;&lt;/template&gt;&lt;script&gt;new Vue(&#123; el: '#app', components: &#123; "child": &#123; data() &#123; return &#123; msg: '子组件数据'&#125; &#125;, template:`&lt;button @click="send" &gt;发送&lt;/button&gt;`, methods: &#123; send () &#123; this.$emit('childMsg', this.msg) &#125; &#125; &#125; &#125;, methods: &#123; getChildData(arg)&#123; console.log(arg) // 子组件数据 &#125; &#125;&#125;)&lt;/script&gt; eventBus(总线/发布订阅模式/观察者模式) vue本身支持的自定义事件 $on和$emit通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,轻量地实现了任何组件间的通信，包括父子、兄弟、跨级12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 子组件 --&gt;&lt;button @click="addTitle"&gt;add&lt;/button&gt;&lt;script&gt;import eventBus from './eventBus'export default &#123; data() &#123; return &#123; title: 'tew' &#125; &#125;, methods: &#123; addTitle() &#123; // 调用自定义事件 eventBus.$emit('onAddTitle', this.title) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- eventBus.js --&gt;&lt;!-- 创建一个事件总线并将其导出，以便其他模块可以使用或者监听它 --&gt;import Vue from 'vue'export default new Vue()&lt;!-- 其他组件 --&gt;&lt;script&gt;import eventBus from './eventBus'export default &#123; methods: &#123; addTitleHandler(title) &#123; console.log('on add title', title) &#125; &#125;, mounted() &#123; // 绑定自定义事件 eventBus.$on('onAddTitle', this.addTitleHandler) &#125;, beforeDestroy() &#123; // 及时销毁，否则可能造成内存泄露 eventBus.$off('onAddTitle') &#125;&#125;&lt;/script&gt; Vuexvuex是vue用来管理数据状态的一种机制，将Vue中所有的状态（数据）抽离出来进行统一管理。 更多vuex用法参考：Vuex官网地址 provide/injectprovide/inject是Vue2.2.0后新增的API 只要一个组件使用了provide向下提供数据，那其下所有的子组件都可以通过 inject 来注入，不管中间隔了多少代，而且可以注入多个来自不同父级提供的数据。主要解决了子组件跨级获取上级组件的状态，建立主动提供与依赖注入的关系123456789101112131415161718192021222324252627&lt;!-- 父组件 --&gt;&lt;template&gt;&lt;div id="app"&gt; &lt;childCom /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import childCom from './childCom'export default &#123; provide: &#123; name: 'tew' &#125;, // 将name值提供给子孙组件 components: &#123; childCom &#125;&#125;&lt;/script&gt;&lt;!-- 子组件 --&gt;&lt;template&gt;&lt;div id="app"&gt; &lt;div&gt;子组件&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: ['name'], // 注入父组件或祖先组件的name mounted () &#123; console.log(this.name); // tew &#125;&#125;&lt;/script&gt; $parent/$children或#refs通过$parent/$children或#refs获取到的是组件实例，使用组件实例可以直接调用组件的方法或数据 父组件访问子组件：使用$children或$refs通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。想明确获取其中一个特定的组件，可以使用$refs,通过ref给子组件绑定一个特定的ID，通过this.$refs.ID就可以访问到该组件了 12345678910111213141516171819202122232425262728293031&lt;template&gt;&lt;div id="app"&gt; &lt;childCom ref="child" /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'export default &#123; data()&#123; return &#123; msg: '父组件数据' &#125; &#125;, components: &#123; "childCom": &#123; template: '&lt;grandsonCom ref="grandson" /&gt;', data () &#123; return &#123; msg: '子组件数据' &#125; &#125; &#125; &#125;, mounted ()&#123; console.log(this.$refs.child.msg) // 子组件数据 console.log(this.$refs.child.$refs.grandson.msg) // 孙组件数据 console.log(this.$children[0].msg) // 子组件数据 console.log(this.$children[0].$children[0].msg) // 孙组件数据 &#125;&#125;Vue.component('grandsonCom', &#123; template: '&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;', data()&#123; return &#123; msg: '孙组件数据'&#125; &#125;&#125;)&lt;/script&gt; 子组件访问父组件：使用$parent我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。避免直接访问父组件的数据，因为这样耦合度太高,父 组件中的状态将变得难以维护 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;&lt;div id="app"&gt; &lt;parentCom /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'export default &#123; data() &#123; return &#123; msg: 'grandpa组件数据' &#125; &#125;, components: &#123; "parentCom": &#123; template: '&lt;child-com /&gt;', data () &#123; return &#123; msg: 'parent组件数据' &#125; &#125;, methods: &#123; handle()&#123; console.log('父组件方法') &#125; &#125; &#125; &#125;, methods: &#123; handle()&#123; console.log('祖先组件方法') &#125; &#125;&#125;Vue.component('child-com', &#123; template: '&lt;button @click="showParent"&gt;显示父元素信息&lt;/button&gt;', methods: &#123; showParent () &#123; console.log(this.$parent.msg) // parent组件数据 this.$parent.handle() // 父组件方法 console.log(this.$parent.$parent.msg) // grandpa组件数据 this.$parent.$parent.handle() // 祖先组件方法 &#125; &#125;&#125;)&lt;/script&gt; dispatch/boardcastvue1中有$dispatch和$boardcast两个方法，但vue2中被删除，可自己模拟，原理是通过$parent和$children来获取父组件和子组件，然后递归即可12345678910111213141516171819202122232425// dispatch 递归获取$parentVue.prototype.$dispatch = function (eventName, data) &#123; let parent = this.$parent // 查找父元素 while(parent)&#123; if (parent) &#123; parent.$emit(eventName, data) // 父元素用$emit触发 parent = parent.$parent // 递归查找父元素 &#125; else &#123; break &#125; &#125;&#125;// boardcastVue.prototype.$boardcast = function(eventName, data)&#123; boardcast.call(this, eventName, data)&#125;function boardcast(eventName, data) &#123; this.$children.forEach(child =&gt; &#123; child.$emit(eventName, data) if (child.$children.length) &#123; // 递归调用 通过call修改this指向 child boardcast.call(child, eventName, data) &#125; &#125;)&#125; $attrs/$listeners $attrs：包含了父作用域中没有被props接受的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v-bind=&quot;$attrs&quot;传入内部组件。通常配合interitAttrs选项一起使用。 $listeners：包含了父作用域中的(不含.native 修饰器的)v-on事件监听器。它可以通过 v-on=&quot;$listeners&quot;传入内部组件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前段日常开发中常用的正则表达式收集，js正则表达式，js中的象形文字。正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，可用于文本搜索和文本替换。 校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; ( 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行* 首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios使用及封装]]></title>
    <url>%2Faxios%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[axios 是基于Promise用于浏览器和nodejs的与服务器端通信库，支持跨平台xhrhttp请求。功能特点：支持Promise API、跨平台可在浏览器和node.js中使用、拦截请求和响应、转换请求和响应数据、取消请求、自动转换JSON数据等。 axios 安装使用 安装 npm i axios -S 引入 import axios from axios12345678910111213// index.vueimport axios from axiosexport default &#123; created () &#123; axios.get('http://192.168.5.16:8888/category') .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) axios.post('http://192.168.5.16:8888/category', &#123; &#123; type: 'sell', page:1 &#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) &#125;&#125; axios 多种请求方式 返回值为promise axios(config) axios[method]() axios.get(url,[config]) axios.post(url,[data,[config]]) axios.delete(url,[config]) axios.head(url,[config]) axios.options(url,[config]) axios.put(url,[config]) axios.patch(url,[config]) axios 发送并发请求使用axios.all([])发送多个请求，返回结果是一个数组。使用axios.spread()将返回数组展开123456789export default &#123; created () &#123; axios.all([axios.get('ulr1'), axios.post('url2')]) .then(axios.spread((res1, res2) =&gt; &#123; console.log(res1) console.log(res2) &#125;)) &#125;&#125; axios 全局配置 axios.default.baseUrl = &#39;http://123.123.23.8:8888&#39; 设置axios的默认请求前缀地址 axios.default.timeout = &#39;30000&#39; 设置默认的请求超时时间 axios.default.headers.post[&#39;Content-type&#39;] = &#39;application/x-www-form-urlencode;charset=UTF-8&#39; 设置post默认请求头 axios 常见配置选项 请求地址 url: &#39;/user&#39; 请求类型 method: &#39;get&#39; 请求根路径 baseURL: &#39;http://www.mt.com/api&#39; 请求前的数据处理 transformRequest:[function(data){}] 请求后的数据处理 transformResponse: [function(data){}] 自定义的请求头 headers:{&#39;x-Requested-With&#39;:&#39;XMLHttpRequest&#39;} URL查询对象 params:{ id: 12 } 查询对象序列化函数 paramsSerializer: function(params){ } request body data: { key: &#39;aa&#39;} 超时设置s timeout: 5000 跨域是否带Token withCredentials: false 自定义请求处理 adapter: function(resolve, reject, config){} 身份验证信息 auth: { uname: &#39;&#39;, pwd: &#39;12&#39;} 响应的数据格式 responseType: &#39;json&#39; axios 拦截器与取消请求 请求拦截器 axios.interceptors.rquest.use(config =&gt; {}) 响应拦截器 axios.interceptors.response.use(response =&gt; {})* axios 简单封装12345678910111213141516171819202122232425262728293031import axios from 'axios'export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: 'http://123.207.32.32:8000', timeout: 5000 &#125;) // 2.axios的拦截器 // 2.1.请求拦截的作用 instance.interceptors.request.use(config =&gt; &#123; // 1. 发送网络请求时 添加loading动画 // 2. 对请求参数进行序列化或加密 // 3. 某些请求要求用户登录 判断是否有token 无totken跳转login页面 return config &#125;, err =&gt; &#123; // console.log(err); &#125;) // 2.2.响应拦截 instance.interceptors.response.use(res =&gt; &#123; // 1. 对响应数据进行过滤 // 2. 对加密的响应数据解密 return res.data &#125;, err =&gt; &#123; // 3. 利用不同的错误码进行不同的提示 console.log(err); &#125;) // 3.发送真正的网络请求 return instance(config)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sticky footers效果]]></title>
    <url>%2FstickyFooter%2F</url>
    <content type="text"><![CDATA[在前端日常开发中，Sticky footers设计是最常见的效果之一，大多数人都遇到过这样的需求,如果页面内容content内容比较少时的时候，页脚块不挨着内容区域而是始终显示在视窗底部；如果内容足够长时，页脚块会随着文档流撑开始终挨着内容区域显示在页面最下方. 效果图 方法一 使用min-height加calc计算高度为内容区域添加最小的高度,用vh(viewpoint height)来计算整体视窗的高度(1vh等于视窗高度的1%),然后减去底部footer的高度，从而求得内容区域的最小高度123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding: 0;&#125; .footer&#123; height: 100px; background: black; color: #fff; font-size: 24px; line-height: 100px; text-align: center; &#125; .content&#123; min-height:calc(100vh - 100px); box-sizing:border-box; padding: 10px 20px; font-size: 18px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt;如果页面内容不够长的时候，页脚块粘贴在视窗底部；&lt;br /&gt;如果内容足够长时，页脚块会被内容向下推送&lt;/div&gt; &lt;div class="footer"&gt;sticky footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法二 使用flex布局对footer和content父元素盒子(如body)使用flex布局, 利用flex布局对视窗高度进行分割。footer设为固定高度，content的flex设为1，这样content会充满除去footer的其他部分12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding: 0;&#125; body&#123; display: flex; flex-direction: column; min-height: 100vh; &#125; .footer&#123; height: 100px; background: black; color: #fff; font-size: 24px; line-height: 100px; text-align: center; &#125; .content&#123; padding: 10px 20px; font-size: 18px; flex: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt;如果页面内容不够长的时候，页脚块粘贴在视窗底部；&lt;br /&gt;如果内容足够长时，页脚块会被内容向下推送&lt;/div&gt; &lt;div class="footer"&gt;sticky footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法三 利用绝对定位和padding完美兼容为外部容器body设置min-height为100vh, 使其内容较少时也能撑开,主体内容设置padding-bottom值为底部footer的高度,避免被遮挡一般会设置比底部高度稍微大一点,留一部分空白间距,footer使用绝对定位,固定高度123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding: 0;&#125; body &#123; position: relative; min-height: 100vh; height: auto !important; &#125; .content &#123; box-sizing:border-box; padding: 10px 20px 100px; font-size: 18px; &#125; .footer &#123; position: absolute; width: 100%; line-height: 100px; text-align: center; bottom: 0px; background: black; color: #fff; font-size: 24px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt;如果页面内容不够长的时候，页脚块粘贴在视窗底部；&lt;br /&gt;如果内容足够长时，页脚块会被内容向下推送&lt;/div&gt; &lt;div class="footer"&gt;sticky footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法四 使用Grid网格布局外部容器设为grid网格布局并设置min-height:100vh, grid-template-rows: 1fr auto设置一个网格行, footer中grid-row-start和grid-row-end属性设置单元格开始和结束的行线1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding: 0;&#125; .content &#123; box-sizing:border-box; padding: 10px 20px; font-size: 18px; &#125; body &#123; min-height: 100vh; display: grid; grid-template-rows: 1fr auto; &#125; .footer &#123; grid-row-start: 2; grid-row-end: 3; background: black; color: #fff; font-size: 24px; line-height: 100px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt;如果页面内容不够长的时候，页脚块粘贴在视窗底部；&lt;br /&gt;如果内容足够长时，页脚块会被内容向下推送&lt;/div&gt; &lt;div class="footer"&gt;sticky footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识前端模块化]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[常见模块化规范有CommonJS,AMD,CMD,ES6模块化。CommonJS核心思想是通过require方法来同步加载依赖的其他模块,通过module.exports导出需要暴露的接口，通过require引入模块，同步执行。AMD规范主要是为了解决针对浏览器环境的模块化问题,最具代表性的实现是requireJS. 模块化模块化是指把一复杂的系统分解到多个模块中 CommonJSCommonJS 是一种使用广泛的javascript模块化规范,核心思想是通过require方法来同步加载依赖的其他模块,通过module.exports导出需要暴露的接口，通过require引入模块，同步执行 主要用在node中 用法 12345// 采用CommonJS来进行导入导出// 用require方法导入const moduleA = require('./b.js');// 用module.exports导出module.exports = someFunc; 原理 123456789101112let fs = require('fs');let path = reqiure('path');let b = req('./b.js');function req(mod)&#123; let filename = path.join(__dirname,mod); let content = fs.readFileSync(filename, 'utf-8'); let fn = new Function('exports', 'require', 'module', '__dirname', '__filename', content + '\n return module.exports;') let module = &#123; exports: &#123;&#125; &#125; return fn(module.exports, req, module, __dirname, __filename)&#125; AMDAMD 也是一种Javascript 模块化规范, 与CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块. AMD规范主要是为了解决针对浏览器环境的模块化问题,最具代表性的实现是requireJS.AMD的优点 可在不转换代码的情况下直接在浏览器中运行 可加载多个依赖 代码可运行在浏览器环境和Node.js 环境下1234567891011// 定义一个模块define('a', [], function()&#123; return 'a';&#125;)define('b', ['a'], function(a)&#123; return a + 'b';&#125;)// 导入和使用require(['b'], function(b)&#123; console.log(b)&#125;) CMD一个文件最为一个模块，使用define来定义模块，modules.exports对外导出模块， 使用require来加载一个模块，代表是SeaJS, 尽可能懒执行123456789// 通过 define 来定义模块define(function(require, exports, module)&#123; // 通过 require 引入模块 var $ = require('jquery') // 通过 exports 对外提供接口 exports.doSomething = ... // 通过 module.exports 提供整个接口 module.exports = ...&#125;) ES6模块化(ES Module)ES6 模块化是ECMA提出的javascript模块化规范,它在语言的层面上实现了模块化.浏览器厂商和Node.js都宣布要原生支持该规范,它将逐渐取代CommonJS和AMD规范,成为浏览器和服务器通用的模块化解决方案.ES6模块目前还无法直接运行在javascript环境下,必须通过工具转换成ES5后才能正产运行1234// 使用export导出export const name = 'asd'// 使用import导入import &#123;name&#125; = from 'xxx.js' ConmmonJS与ES6 Module的区别 ConmmonJS的require的模块路径可以根据if判断条件动态指定加载那个文件。ES6 Module导入和导出的路径不支持表达式，导入导出的语句必须位于顶层作用域，不能放在if等判断语句中 在导入模块时CommonJS获取的是一份值拷贝，对导出的值修改，不会影响源文件的值。而ES6 Module则是值的动态映射，对导出的值进行修改，会影响源文件的值12345678910111213141516171819202122232425262728293031/* ES6 Module */// add-content.jsvar count = 0const add = function () &#123; count += 1&#125;export &#123; count, add &#125;// index.jsimport &#123; count, add &#125; from './add-content.js'console.log(count)add()console.log(count)count += 1 // 直接修改会报错// connot set property count of #&lt;Object&gt; which has only e getter/* ConmmonJS */// add-content.jsvar count = 0module.exports = &#123; count: count, add: function () &#123; count += 1 &#125;&#125;&#125;// index.jsvar count = require('./add-content.js').countvar add = require('./add-content.js').addconsole.log(count) // 0add()console.log(count) // 0count += 1console.log(count) // 1 自动化构建把源代码转换成在线上可执行的 Javascript、CSS、HTML代码。包括如下内容 代码转换: Ecmascript6 变异成 Ecmascript5, less编译成css等 文件优化: 压缩Javascript、CSS、HTML代码，图片压缩与合并。 代码分割: 提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：使用构建工具将多个模块与文件合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：检验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动打包代码并发布到服务器上。 前端工程化 前端工程化 是指将前端开发的流程规范化,标准化,包括开发流程,技术选型,代码规范,构建发布等]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件、动画、生命周期]]></title>
    <url>%2Fvue%E7%BB%84%E4%BB%B6%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue.js是一个构建数据驱动的web界面的库,是一套用于构建用户界面的渐进式框架. 目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统，它让数据与DOM保持同步非常简单。 vue组件vue中组件是组件是一组可被复用的具有一定功能,独立的完整的代码片段,这个代码片段可以渲染一个完整的视图结构,每一个组件都是一个vue实例对象,都会包含vue实例的所有属性和方法 vue组件分类： vue-router对应的每一个.vue页面组件 不包含业务的、独立的基础功能组件如UI组件，具有通用性可以在不同项目中使用 只包含某个功能的业务组件、只在当前项目中使用不具有通用性 vue组件的三个API： prop、event、slot 一个再复杂的组件，都是由三部分组成的：prop、event、slot，它们构成了 Vue.js 组件的 API 属性props定义了有哪些可配置的属性，写通用组件时，props最好用对象的写法，便于设置每个属性的类型、默认值和校验属性的值* 组件使用步骤 1. 引入组件 2. 注册组件 3. 使用组件 全局组件 可以在任何模板中使用,使用之前需要先注册 123456789101112// 注册 Vue.component(‘组件名’,选项对象)// Vue.component(‘my-component’,&#123;&#125;)// 使用 &lt;my-component&gt;&lt;/my-component&gt;&lt;div id='app'&gt;&lt;Counter /&gt;&lt;/div&gt;Vue.component('Counter', &#123; template: '&lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;', data () &#123; return &#123; text: '全局组件' &#125; &#125;&#125;) 局部组件 在组件实例中通过选项对象注册,只在所注册的作用域中使用 1234567891011121314151617// 注册 components:&#123; 组件名:选项对象 &#125;// 子组件中的data必须是函数// 每个组件都是相互独立的,如果共用一个对象,产生引用关系,在更改一个的时候,会影响其他组件.// 但如果是函数,每个组件都有自己独立的作用域,不会互相影响new Vue(&#123; el: '#app', components: &#123; 'Counter': &#123; template: '&lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;', data () &#123; return &#123; text: '全局组件' &#125; &#125; &#125; &#125;&#125;) 组件可多次使用 不希望Vue重复利用的问题，可以给对应的组件添加不同的key，key的作用主要是为了高效的更新虚拟DOM。 动态组件多个组件可以使用同一个挂载点,动态地在他们之间切换,使用保留的&lt;component&gt;元素,使用is特性进行动态绑定可以使用keep-active把切出去的组件保留在内存中,这样还可以保留它的状态及样式,避免重新渲染或者使用 v-once&lt;component :is=&quot;组件名称&quot;&gt;&lt;/component&gt; vue 单向数据流数据从父组件流向(传递)给子组件.只能单向绑定,在子组件内部不应该修改父组件传递过来的数据 会报错解决办法： props作为子组件data中局部数据的初始值使用 克隆一份数据改变自己的 作为子组件中的computed属性 slot插槽使用一种方式混合父组件的内容与子组件自己的模板,这个过程被称为内容分发在子组件中使用元素作为内容测插槽,这样会使组件的可扩展性更强 单个slot 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. 在子组件模板中有slot标签,被视为备用内容,在父组件不提供内容的情况下使用`&lt;div id='app'&gt; &lt;h2&gt;自定义组件&lt;/h2&gt; &lt;myslot&gt;&lt;/myslot&gt;&lt;/div&gt;Vue.component('myslot', &#123; template: ` &lt;div&gt; &lt;slot&gt;我是默认的slot&lt;/slot&gt; &lt;p&gt;这是一个提醒&lt;/p&gt; &lt;/div&gt;`&#125;)/*自定义组件我是默认的slot这是一个提醒*/// 2. 如果父组件提供内容,则把整个内容插入到slot所在的位置,并替换掉slot本身&lt;div id='app'&gt; &lt;h2&gt;自定义组件&lt;/h2&gt; &lt;myslot&gt; &lt;div&gt;我是父组件的内容&lt;/div&gt; &lt;/myslot&gt;&lt;/div&gt;Vue.component('myslot', &#123; template: ` &lt;div&gt; &lt;slot&gt;我是默认的slot&lt;/slot&gt; &lt;p&gt;这是一个提醒&lt;/p&gt; &lt;/div&gt;`&#125;)/*自定义组件我是父组件的内容这是一个提醒*/// 3. 子组件模板中没有solt标签,父组件提供的内容会被抛弃&lt;div id='app'&gt; &lt;h2&gt;自定义组件&lt;/h2&gt; &lt;myslot&gt; &lt;div&gt;我是父组件的内容&lt;/div&gt; &lt;/myslot&gt;&lt;/div&gt;Vue.component('myslot', &#123; template: ` &lt;div&gt; &lt;p&gt;这是一个提醒&lt;/p&gt; &lt;/div&gt;`&#125;)/*自定义组件这是一个提醒*/ 具名slot插槽&lt;slot&gt;元素可以用一个特殊的属性name来配置如何发布内容.可以使用匿名的的slot,处理那些没有对应的slot的内容 slot-scope作用域插槽父组件替换插槽的标签，父组件决定怎么展示，但是内容由子组件来提供。 1234567891011121314151617181920212223242526272829303132333435363738394041// 子组件中包括一组数据，比如：pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']Vue.component('MySlot',&#123; template: `&lt;div :data="pLanguages"&gt;&lt;/div&gt;`, data () &#123; return &#123; pLanguages: ['JavaScript', 'Python', 'Swift'] &#125; &#125;&#125;)// 需要在多个界面进行展示：某些界面是以水平方向展示的，某些界面是以列表形式展示的// 内容在子组件，希望父组件告诉我们如何展示// 在父组件使用我们的子组件时，从子组件中拿到数据：// 我们通过&lt;template slot-scope="slotProps"&gt;获取到slotProps属性// 在通过slotProps.data就可以获取到刚才我们传入的data了// 父组件&lt;div id="app"&gt; &lt;!-- 列表展示 --&gt; &lt;MySlot&gt; &lt;template slot-scope="slotProps"&gt; &lt;ul&gt; &lt;li v-for="(item,index) of slotProps.data"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/MySlot&gt;&lt;/div&gt;/*. JavaScript. Python. Swift*/&lt;div id="app"&gt; &lt;!-- 水平展示 --&gt; &lt;MySlot&gt; &lt;template slot-scope="slotProps"&gt; &lt;span v-for="(item,index) of slotProps.data"&gt;&#123;&#123;item&#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/MySlot&gt;&lt;/div&gt;/*JavaScript Python Swift*/ 编译作用域父组件的模板的内容在父组件作用域内编译子组件的模板的内容在子组件作用域内编译 Vue动画 单元素/组件的过渡 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- appear 初始渲染的过渡 --&gt;&lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt;&lt;/transition&gt;&lt;style&gt;/* 过渡类名 name="fade" 过渡类名的前缀可自定义 默认前缀 v- v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效， 在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效， 在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。*/.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125;&lt;/style&gt;&lt;script&gt;/* 动画过渡钩子函数 v-on:before-enter="beforeEnter" 动画执行之前 v-on:enter="enter" 动画执行过程中 v-on:after-enter="afterEnter" 动画执行之后 v-on:before-leave="beforeLeave" 动画执行完成之前 v-on:leave="leave" 动画执行完成过程中 v-on:after-leave="afterLeave" 动画执行完成之后 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;,*/&lt;/script&gt; 多个元素/组件的过渡 123456&lt;!-- tag 默认为span 渲染成真实DOM元素 --&gt;&lt;transition-group tag="ul" name="slide"&gt; &lt;li v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; Vue动画详情 Vue生命周期函数生命周期函数就是vue实例在某一个时间点会自动执行的函数挂载阶段 更新阶段 销毁阶段123456789101112131415161718192021222324252627282930313233343536373839//vue实例部分初始化的时候 组件实例刚刚被创建 属性都没有beforeCreate:function()&#123; console.log('beforeCreate')&#125;,//vue实例初始化完成 属性已经绑定created:function()&#123; console.log('created')&#125;,//页面渲染之前 模板编译之前 dom还未显示beforeMount:function()&#123; console.log('beforeMount')&#125;,//页面渲染完毕 (才有$el对象) dom显示完成mounted:function()&#123; console.log('mounted');&#125;,//vue实例被销毁之前 组件销毁前 操作: 解除绑定 销毁子组件及事件监听器beforeDestroy:function()&#123; console.log('beforeDestroy')&#125;,//vue实例被销毁 组件销毁后destroyed:function()&#123; console.log('destroyed')&#125;,//数据发生改变未渲染之前beforeUpdate:function()&#123; console.log('beforeUpdate')&#125;,//数据发生改变渲染完毕updated:function()&#123; console.log('updated')&#125;// 组件使用keep-alive专有activated: function()&#123; console.log('activated')&#125;deactivated: function()&#123; console.log('deactivated')&#125; Runtime-Compiler和Runtime-only的区别vue有两种形式的代码 compiler（模板）模式和runtime模式（运行时）如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-onlyRuntime-only 性能更好 体积更小vue模块的package.json的main字段默认为runtime模式， 指向了”vue/dist/vue.runtime.common.js”位置。如要使用template修改vue指向 vue/dist/vue.esm.js1234567891011// Runtime-Compilernew Vue(&#123; el: '#app', component: &#123; App &#125;, template: '&lt;App /&gt;'&#125;)// Runtime-Onlynew Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp简单实用]]></title>
    <url>%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp是基于node实现Web前端自动化开发的工具，利用它能够极大的提高开发效率。 在Web前端开发工作中有很多’重复工作’，比如压缩CSS/JS文件。编写 gulp配置代码,让gulp自动执行这些’重复工作’。gulp主要是基于任务流(stream)的自动化构建工具 安装 npm install gulp -g 使用gulp -v 查看安装好的全局gulp版本 npm init -y 创建package.json文件 新建gulp配置文件gulpfile.js(固定写法) 要运行gulp任务,只要在命令行切换到当前目录执行gulp命令即可,默认会执行任务名为default的任务 gulp使用流程首先通过gulp.src()方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中, 文件流可以继续使用,执行后续操作 gulp的常用API gulp.task() 用来定义任务 12345678/* 语法 gulp.task(name[, deps], fn)name 为任务名deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。*/gulp.task('mytask', ['array', 'of', 'task', 'names'], function() &#123; //定义一个有依赖的任务 // Do something&#125;); gulp.src() 用来获取虚拟文件流的 12345678/* gulp.src(globs[, options])globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。options为可选参数。通常情况下我们不需要用到。*///使用数组的方式来匹配多种文件gulp.src(['js/*.js','!bob*.js','css/*.css','*.html'])//匹配所有js文件，但排除掉以b开头的js文件gulp.src([*.js,'!b*.js']) gulp.dest() 方法是用来写文件的 12345678910/* gulp.dest(path[,options])path为写入文件的路径 用来指定要生成的文件的目录，而不能指定生成文件的文件名 修改名称可以用gulp-renameoptions为一个可选的参数对象，通常我们不需要用到*/var gulp = reruire('gulp');gulp.src('script/jquery.js').pipe(gulp.dest('dist/foo.js'));//最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js').pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js gulp.watch() 用来监视文件的变化，当文件发生变化后，可以用它来执行相应的任务，例如scss编译等 1234567/* gulp.watch(glob[, opts], tasks)glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到tasks 为文件变化后要执行的任务，为一个数组*/gulp.task('sass',function()&#123;&#125;)gulp.watch('v2.0/src/sass/*.scss', ['sass']) 常用gulp插件 gulp-rename 重命名 npm install --save-dev gulp-rename gulp-uglify js文件压缩 npm install --save-dev gulp-uglify gulp-minify-css css文件压缩 npm install --save-dev gulp-minify-css gulp-minify-html html文件压缩 npm install --save-dev gulp-minify-html gulp-concat 文件合并 npm install --save-dev gulp-concat gulp-less less和sass的编译 npm install --save-dev gulp-less gulp-sass less和sass的编译 npm install --save-dev gulp-sass gulp-imagemin 图片压缩 npm install --save-dev gulp-imagemin gulp-zip 将文件压缩成zip npm install --save-dev gulp-zip gulp-sftp 将文件上传至ftp npm install --save-dev gulp-sftp browser-sync 自动刷新 npm install --save-dev browser-sync gulp-autoprefixer 为css文件添加浏览器前缀 npm install gulp-clean-css --save-dev gulp-if 条件判断及环境变量设置 npm install gulp-if —save-dev gulp-babel gulp中配置babel编译es6 需安装babel相关插件并配置.babelrc文件 还需要在项目中引入babel-polyfill编译es6新增api npm install gulp-babel —save-dev gulp-load-plugins 自动加载插件 npm install -D gulp-load-plugins 123456789101112131415/* 能自动帮你加载package.json文件里的gulp插件 无需将每一个插件都require进来 但前提是插件要以gulp-开头 已经安装过这些插件 *//* package.json 中的gulp插件"devDependencies": &#123; "gulp": "~3.6.0", "gulp-rename": "~1.2.0", "gulp-concat": "~0.4.3", "gulp-load-plugins": "~0.5.1"&#125;*/var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')();gulp.task('rename', function () &#123; gulp.src('js/jquery.js').pipe(plugins.rename()) //压缩&#125; 添加error事件监听 123456789var babel = require("gulp-babel"); gulp.task("babel", function () &#123; return gulp.src(srcJs) .pipe(babel()) .on('error',function(err)&#123; console.log(err) &#125;) .pipe(gulp.dest(distJs))&#125;) 由于Gulp 4并不向后兼容Gulp 3使用最新版时, 需要修改gulpfile.js参考链接: Gulp 4 入门指南 相对完整的Gulp4升级指南 gulp最新文档 gulpfile.js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102var gulp = require('gulp'), concat = require('gulp-concat'),//多个文件合并为一个 cleanCss = require('gulp-clean-css'),// 压缩css为一行 ugLify = require('gulp-uglify'),//压缩js imageMin = require('gulp-imagemin'),//压缩图片 pngquant = require('imagemin-pngquant'),//深度压缩 htmlMin = require('gulp-htmlmin'),//压缩html changed = require('gulp-changed'),//检查改变状态 less = require('gulp-less'),//压缩合并less del = require('del'), browserSync = require('browser-sync').create();//浏览器实时刷新//删除dist下的所有文件gulp.task('delete',function(cb)&#123; return del(['dist/*','!dist/images'],cb)&#125;)//压缩htmlgulp.task('html',function()&#123; var options = &#123; removeComments:true,//清除HTML注释 collapseWhitespace:true,//压缩HTML removeScriptTypeAttributes:true,//删除script的type='text/script' removeStyleLinkTypeAttributes:true,//删除style和link的type='text/css' minifyJS:true,//压缩页面JS minifyCSS:true//压缩页面CSS &#125;; gulp.src('src/index.html') .pipe(changed('dist',&#123;hasChanged:changed.compareSha1Digest&#125;)) .pipe(htmlMin(options)) .pipe(gulp.dest('dist')) .pipe(browserSync.reload(&#123;stream:true&#125;))&#125;)//实时编译lessgulp.task('less',function()&#123; gulp.src(['./src/less/*.less']) //多个文件以数组形式传入 .pipe(changed('dist/css',&#123;hasChanged:changed.compareSha1Digest&#125;)) .pipe(less()) //调用less模块编译less .pipe(concat('main.css')) //合并之后生成main.css .pipe(gulp.dest('dist/css')) //输出到指定目录下 .pipe(browserSync.reload(&#123;stream:true&#125;));&#125;)//压缩jsgulp.task('script',function()&#123; gulp.src(['src/js/api.js','src/js/index.js']) .pipe(changed('dist/css',&#123;hasChanged:changed.compareSha1Digest&#125;)) .pipe(concat('index.js')) .pipe(ugLify()) .pipe(gulp.dest('dist/js')) .pipe(browserSync.reload(&#123;stream:true&#125;))&#125;)//压缩图片gulp.task('image',function()&#123; gulp.src('./src/images/*.*') .pipe(imageMin(&#123; progressive:true,//无损压缩JPG图片 svgoPlugins:[&#123;removeViewBox:false&#125;],//不移除svg的viewbox属性 use:[pngquant()] //使用pngquant插件进行深度压缩 &#125;))&#125;)// 将文件压缩成zipgulp.task('zip', function () &#123; return gulp.src('【build】/**/*', &#123; base: '【build】' &#125;) .pipe(zip(dateFormat(now, 'yyyymmddHHMM') + folderName + '.zip')) .pipe(gulp.dest('【build】'))&#125;)//上传项目文件到ftpgulp.task('up', function () &#123; return gulp.src('【build】/*' + folderName + '.zip', &#123; base: '【build】' &#125;) .pipe(sftp(&#123; host: 'xx', user: 'xx', pass: 'xx', remotePath: 'xx', timeout: 100000 &#125;))&#125;)//启动热更新gulp.task('serve',['delete'],function()&#123; gulp.start('script','less','html'); browserSync.init(&#123; port:2017, server:&#123; baseDir:['dist'] &#125; &#125;); gulp.watch('src/js/*.js',['script']); //监控文件变化 自动更新 gulp.watch('src/less/*.less',['less']); gulp.watch('src/*.html',['html']); gulp.watch('src/images/*.*',['images']);&#125;)//执行任务gulp.task('default',['serve']); 参考链接前端构建工具gulpjs的使用介绍及技巧gulp.js 中文网gulp构建项目系列教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础语法]]></title>
    <url>%2Fvue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue.js是一个构建数据驱动的web界面的库。核心概念：插值语法、插值表达式、v-model双向绑定、监听器 $watch、计算属性computed、动态绑定class、动态绑定内联样式、指令、过滤器等 MVVM1234MVVM模式可以极大的简化我们开发的工作量M: Model 模型 前端中的数据 例如数组 对象等V: View 视图、模板 前端中的dom对象 例如下拉框,弹层等VM: ViewModel 视图模型 双向绑定 连接Model和View 将模型中的数据与视图中的数据绑定在一起 事件监听和数据绑定 插值语法 语法{{}}实现将模型中的数据渲染到视图中 v-text=&#39;js环境&#39; 渲染数据 v-html=&#39;js环境&#39; 可以将标签和数据渲染出来 注意: 写在里面的不需要{{}} 插值表达式插值的语法的本质上是提供了一个js环境,在js环境中我们可以使用js表达式(变量,运算符,方法等)1234567&lt;div&gt;&#123;&#123;msg.toUpperCase()&#125;&#125; &#123;&#123;width*height&#125;&#125;&lt;/div&gt;nue Vue(&#123; data () &#123; return &#123; msg: 'tew', width: 20, height: 30&#125; &#125;&#125;// &lt;div&gt;TEW 40&lt;/div&gt; v-model双向绑定通过data属性实现数据模型到vue实例化对象的绑定(通过属性的特性实现)通过v-model指令,实现视图到vue实例化对象的绑定(通过事件实现)v-model的属性值是一个js作用域(一般用于表单元素中)1234// v-model 修饰符// v-model.number='' 输入内容转化为数值类型// v-model.trim = '' 去除首尾空格// v-mode.lazy='' 等同于change事件 监听器 $watch$watch 用于观察Vue实例上的数据变动 回调函数得到的参数为新值和旧值watch 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。12345678910111213141516171819202122232425// $watch 或 watch 值变化时才执行 加上 immediate:true 绑定之后立即执行handle// deep:true 会遍历监听对象下所有属性开销较大时, 可以写成字符串监听对象具体的属性// $watchvm.$watch( 'a', // 监听的值 或 函数的计算结果 function(newval, oldVal)&#123; // 回调函数 console.log(newVal+'--'+oldVal) &#125;, &#123; deep: true, // 深度监听对象内部值的变化 immediate: true // 立即执行回调函数 &#125;)// watchnew Vue(&#123; watch: &#123; a: &#123; handle () &#123; console.log(newVal+'--'+oldVal) &#125;, deep: true, //任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 immediate: true // 侦听开始之后被立即调用 &#125; &#125;&#125;) 计算属性 computed在插值前对数据进行处理,vue提供了动态插值语法,允许在插值前调用一个函数来处理数据,动态函数要定义在computed属性中,属性值是一个对象,返回值就是插入视图中的数据计算属性与methods普通方法好处: 计算属性中的计算结果会被缓存，多次使用时，计算属性只会调用一次。减少模板的复杂度,节省性能计算属性依赖data数据只要有一个发生改变就会重新计算 计算的结果会被缓存 计算属性会挂载所在的实例上私有属性上 值是函数的返回值123456789101112131415// &lt;li v-fot="(item, index) in limtList" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/item&gt;nue Vue(&#123; data () &#123; return &#123; list: [1,2,3,4,5,6,7,8,9] &#125; &#125; computed: &#123; limtList () &#123; return this.list.filter(item =&gt; item &gt; 7) &#125; &#125;&#125;)/*&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;*/ :class绑定HTML Class类v-bind:class 简写 (:class) 动态的渲染元素上的类 只需要计算出表达式的最终的字符串 可以与普通的class特性共存 对象方式绑定类 1234// 对象中的每个属性名称代表一个类的名称 属性值只能是布尔值// true 表示保留这个属性类名 false 表示删除这个类名// 属性中出现特殊字符 需要加上引号,&lt;div v-bind:class="&#123;acitve: isActive, 'has-bg':hasBg&#125;"&gt;&lt;/div&gt; 数组方式绑定类 12345// 数组每个成员是变量,一旦加上引号就将变量转化成字符串 每个成员只能代表一个类&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;// 数组语法中也可以使用对象语法：&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; :style绑定内联样式 对象语法 1234// CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：// 对象的属性名称 表示css的属性名称// 对象的属性值 表示css的样式属性值&lt;div v-bind:style="&#123; color: textColor, 'font-size': fontSize + 'px' &#125;"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 指令指令(Directives)是特殊的带有前缀v-的特性.指令就是扩展html标签功能和属性的 v-once 只绑定一次 只渲染一次 保留在内存中 v-text 插值&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 等同于 &lt;span&gt;{{msg}}&lt;/span&gt; v-html 避免html元素被编译&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; v-bind 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式 可简写成 : 123&lt;img v-bind:src="imageSrc"&gt;&lt;img :src="imageSrc"&gt; &lt;!-- 缩写 --&gt;&lt;my-component :prop="someThing"&gt;&lt;/my-component&gt; v-model 在表单控件或者组件上创建双向绑定 v-pre 跳过这个元素和它的子元素的编译过程 v-cloak 可以隐藏未编译的 Mustache 标签直到实例准备完毕。 12&lt;div id='app' v-cloak&gt;&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;[v-cloak] &#123; display: none &#125;&lt;/style&gt; v-show 切换元素的 display CSS 属性。v-show是简单的切换元素的CSS display属性, 有v-show的元素会始终渲染到并保持在dom中,只是隐藏了而已,不支持template, 也不支持v-else&lt;h1 v-show=&quot;isShow&quot;&gt;Hello!&lt;/h1&gt; v-if 动态渲染一个元素 123456789// v-if的属性值是true 会将这个元素渲染到页面中// v-if的属性自是false 会将这个元素从页面中删除// 切换多个元素,可以把多个元素放入template中,为其添加v-if指令,而最终的渲染结果并不会包含它&lt;div id='app'&gt; &lt;template v-if="isShowDetail"&gt; &lt;sapn&gt;姓名: tew&lt;/span&gt; &lt;sapn&gt;性别: 男&lt;/sapn&gt; &lt;/template&gt;&lt;/div&gt; v-else 为 v-if 或者 v-else-if 添加“else 块”。v-else元素必须紧跟v-if或v-show元素的后面 否则它不能被识别 123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else-if注: v-if是真实的条件渲染,它会在切换当中销毁与重建条件块内的事件监听器和子组件,有更高的切换消耗. v-show只是简单的基于css切换,有更高的初始渲染消耗,如果需要频繁的切换 使用v-show更好,如果条件不大可能改变则用v-if v-on 绑定事件监听器, 事件类型由参数指定 简写@ 12345678910111213141516171819202122232425262728293031323334353637&lt;button v-on:click="doThis"&gt;&lt;/button&gt;// &lt;!-- 内联语句 --&gt;&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;// &lt;!-- 缩写 --&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;// &lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;// &lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;// &lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;// &lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;// &lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter="onEnter"&gt;// &lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13="onEnter"&gt;// &lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;// &lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;// &lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;// &lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;// &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;// &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;// &lt;!--只触发一次--&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt;// passive 会告诉浏览器你不想阻止事件的默认行为, 不用执行是否有preventDefault事件查询了&lt;div v-on:scroll.passive="onScroll"&gt;...&lt;/div// 全部的按键别名：// @keyup.enter="" .tab .delete .esc .space .up .down .left .right .ctrl .alt .shift .meta// 给组件绑定事件 需要事件加修饰符 @click.native=’handleClick’&lt;Child @click.native='test'/&gt; 获取事件对象的两种方式 123456789101112// 方式一 带括号 固定参数 $event// 如果带括号而不传$event参数 则获取不到事件对象event&lt;button @click="btnClick(1, $event)"&gt;事件对象1&lt;/button&gt;btnClick(a, ev) &#123; console.log(a) console.log(ev)&#125;// 方式二 不带括号&lt;button @click="btnClick"&gt;事件对象1&lt;/button&gt;btnClick(ev) &#123; console.log(ev)&#125; 多个事件处理程序 123456789101112131415161718&lt;!-- 方式一 使用逗号分隔多个事件处理程序 --&gt;&lt;button @click="one($event), two($event)"&gt; 触发多个事件&lt;/button&gt;&lt;!-- 方式二 使用@xxx 和 v-on:xxx --&gt;&lt;button @click="one" v-on:click="two"&gt; 触发多个事件&lt;/button&gt;&lt;script&gt;methods: &#123; one(event) &#123; console.log('one') &#125;, two(event) &#123; console.log('two') &#125;&#125;&lt;/script&gt; v-for 指令基于一个数组会对象来渲染一个列表。 12345678910111213141516// v-for 也可以接受一个整数,此时他将重复数次&lt;div&gt; &lt;span v-for="n in 3"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt;// &lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;// items 是源数据数组 item 迭代元素的别名 index 当前迭代元素的索引// 可以使用 of 替代 in 如 v-for="(item, index) of items"// :key 提升循环显示的性能 表示唯一key属性 可以避免重用或重排 2.2.0+以后key是必须的// 当v-for与v-if处于同一节点，v-for 的优先级比 v-if 更高，v-if // 将分别重复运行于每个 v-for 循环中,可实现渲染部分项节点&lt;ul id="example-1"&gt; &lt;li v-for="(item, index) in items" :key="item.message"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;div v-for="(val, key) of object"&gt;&lt;/div&gt;&lt;div v-for="(val, name, index) of object"&gt;&lt;/div&gt; 表单元素 多选 type=&#39;checkbox&#39; 对多选实现双向绑定,通过添加v-model指令绑定一个变量变量的值是布尔值 true表示选中 false表示未选中,对于变量的值vue会进行类型的转化 单选 type=&#39;radio&#39; 对单选框实现双向绑定,通过给每个radio项添加v-model指令v-model绑定的变量是谁,就会选中谁 单选框的v-model要设置同一个变量 下拉框 select 通过添加v-model属性实现下拉框双向绑定 过滤器过滤器可以用在两个地方：双花括号插值和v-bind表达式 在双花括号中&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 在v-bind中123456789101112131415161718192021// &#123;&#123; message | capitalize &#125;&#125;// 全局过滤器Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)// 局部过滤器new Vue(&#123; filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)// 多个过滤器 &#123;&#123; message | filterA | filterB &#125;&#125;// 表达式 message 的值将作为参数传入到函数A中处理完成。然后继续调用filterB，将 filterA 的结果传递到 filterB 中// 过滤器参数 &#123;&#123; message | filterA('arg1', arg2) &#125;&#125;// filterA 被定义为接收三个参数的过滤器函数。其中 message的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 数组或对象值的更新问题因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化：不会触发视图更新直接用索引设置元素，如 vm.items[0] = {}；修改数据的长度，如 vm.items.length = 0。数组变异方法会触发试图更新push() pop() shift() unshift() splice() sort() reverse()12345678910111213// 改变数组或对象的某一项值时,试图未更新, 触发试图更新的方法如下// 1. 改变数组或对象的引用 重新为其赋值// 2. 使用数组的变异方法 或 对象拷贝 新对象替换老对象vm = &#123; list: [&#123;id: '11', name: 'bob'&#125;,&#123;id: '22', name: 'tom'&#125;] &#125;vm.list.splice(1,1, &#123;id: '33', name: 'tew'&#125;)// &#123; list:[&#123;id: "11", name: "bob"&#125;, &#123;id: "33", name: "tew"&#125;] &#125;// 新对象 替换 旧对象obj = Object.assign(&#123;&#125;, this.obj, &#123; a: 1, e: 2 &#125;)obj = &#123;...this.obj, &#123; a: 1, e: 2 &#125;&#125;// 3. 使用 Vue.set()或者 vm.$set()Vue.set(vm.list,'name','tew')vm.$set(vm.list,'name','tew')// 4. 使用 this.$forceUpdate() 强制组件重新渲染 props 参数校验 与非props特性 props值方式一：字符串数组，数组中的字符串就是传父组件传递的名称 props值方式二：对象，对象可以设置传递时的类型， 默认值，是否必须等123456789101112131415161718192021222324// 非props 特性// 如果子组件没有用props接受 会报错// 父组件的属性会展示在子组件最外层的元素属性中// props参数校验Vue.comonent('child', &#123; props: &#123; content: &#123; type: String, // String Number Boolean Array Object Date Function Symbol required: false, // 必填 default: '默认值', // 字符串的默认值 validator(value)&#123; // 自定义验证函数 return value.length &gt; 5 &#125; &#125;, person: &#123; type: Object, // 对象或数组 默认值 必须从一个工厂函数获取 default: function ()&#123; return &#123;name: 'tew'&#125; &#125; &#125; &#125; template: '&lt;div&gt;&#123;&#123;person.name&#125;&#125;--&#123;&#123;content&#125;&#125;&lt;/div&gt;'&#125;) Vue-cli2 脚手架 npm install vue-cli -g 安装 vue命令环境 脚手架工具 验证安装ok? vue –V 生成项目模板vue init &lt;模板名&gt; 本地文件夹名称 vue list 查看官方提供模板模块名 webpack 大型项目 Eslint 检测代码规范 单元测试webpack-simple simple browserify browserify-simple 进入到生成目录里面 cd xxx npm install 安装项目依赖 npm run dev 启动项目注: 使用npm init 初始化项目的时候 路径不能有中文 不能有大写字母vue-cli2 初始化项目过程vue-cli2 项目目录结构]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git暂存，撤销更改等进阶用法]]></title>
    <url>%2Fgit%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[当我们在开发项目的时候，突然来一个变更需要修改，但你又不想提交，这时我们除了将当前项目提交（commit）后切换（checkout） 到其他分支外，我们还可以先将当前的修改暂存（stash）起来，然后再切换（checkout）到其他分支，而不需要提交（commit），这样就可以减少一个 commit git stash 暂存文件git stash 或 git stash save ‘注释’ 暂存修改1、文件已经被git跟踪，只是修改了代码(而不是新增加文件)，我们可以使用git stash或git stash save “注释” 来暂存修改。2、如果有新添加的文件，那么就需要添加参数 -a(会把隐藏的文件或.gitnore忽略的文件也暂存)慎用 -u 只暂存未跟踪的文件 添加 -a 参数 (git stash -a 或 git stash save -a “注释”)慎用 先 git add . 然后再使用 git stash 或 git stash save “注释” 来暂存修改 添加 -u 参数 (git stash -u 或 git stash save -u “注释”) 推荐注: stash@{id}里面的id默认从0开始 git-stash文档 git stash list 查看之前缓存的所有stash1234$ git stash list-------------------------stash@&#123;0&#125;: On masterOrder: masterOrderstash@&#123;1&#125;: On devOrder: devOrder git stash show 查看某一次stash信息 修改了哪些文件git stash show -p ‘stash@{0}’ 查看某一次stash信息 查看修改文件里修改的内容1234$ git stash show stash@&#123;0&#125;-------------------------gulpfile.js | 1 +1 file changed, 1 insertion(+) git stash apply 取出暂存区的stash 但不在stash list中删除 git stash apply 不指定stash 则默认取出第一条stash暂存 git stash apply stash@{1} 取出指定stash git stash drop 删除暂存区的stash git stash drop 不指定stash 则默认删除第一条stash暂存 git stash drop stash@{1} 删除指定stash git stash pop 取出并删除暂存区的stash git stash pop 不指定stash 则默认取出并删除第一条stash暂存 git stash pop stash@{1} 取出并删除指定stash git stash clear 清空stash列表中所有的stash如果你使用的是vscode中windows的powershell命令行,则需要注意操作某个指定的stash时, &#39;stash@{1}&#39; 需要加上引号,否则会有如下问题,使用git bash命令行或者cmder等命令行工具可以不用加123git stash apply stash@&#123;1&#125;----------------------unknown option: -encodedCommand stash drop 误删恢复1231. git fsck --lost -found :查看最近移除的文件2. git show '误删编号'：查看删除文件内容3. git stash apply '误删编号'： 本地合并误删的文件内容 参考：git stash drop 误删恢复 git tag 标签项目的版本管理中,每当一个release版本发布时,需要做一个记录,以便以后需要的时候重新打包这个版本,这时候就用到tag这个功能. 添加标签 git tag -a v1.1.0 -m &quot;Release version&quot; -a v1.1.0 标签名称 -m 后面时注释 查看所有标签 git tag --list 提交标签到远程服务器 123git push origin --tags // 提交所有tag至服务器端git push origin v1.1.0 // 提交某个tag至服务器端// 注：git push origin master操作不会推送标签到服务器端。 切换到某个标签 git checkout [tagname]切换到某个tag时， 不处于任何分支，处于有利状态，也未版本回退，请不要再次tag上修改，修改bug可以基于此tag创建分支并提交 查看某个标签信息 git show v1.1.0 删除标签 git tag -d v1.1.0 删除远程服务器标签 git push origin :refs/tag/v1.1.0 git 撤销更改 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。git checkout -- &lt;filename&gt; 或 git checkout -- . (所有修改文件) 将工作区中的文件的修改撤销，只撤销还没有add到暂存区的文件，不会撤销暂存区的文件，只放弃了修改的文件，新增和删除的不会被放弃 本地新增或删除了一堆文件(并没有git add到暂存区)，想放弃修改git clean -f &lt;filename&gt; 移除本地新增，修改或删除的未add的文件 git回退 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。git reset [HEAD] &lt;filename&gt; 或 git reset [HEAD] . 或者 git 高版本可用 git restore --staged &lt;filename&gt; 本地通过git add &amp; git commit之后，但还未git push，想要撤销此次commitgit reset commit_id 或 git reset --hard commit_id 撤销git push到远程的代码 (谨慎操作)首先在本地仓库使用git reset –hard [commit_id]将本地仓库重置为需要撤销的版本,然后使用git push origin -f 进行提交，这样可以强制远程仓库与本地仓库一致 撤销commit注释（修改commit注释） 最近一次提交git commit --amend -m &#39;备注信息&#39; 即可覆盖上次信息合并为一次提交 参考资料git各种情况的版本回退Git撤销修改Git中文网-GitLab中文网 - Git安装、git使用、git下载、git中文非常不错的git-tips三年 Git 使用心得 &amp; 常见问题整理]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2Fgit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Git是一种版本控制器，git可以帮我们管理我们的代码保证代码不丢失，记录历史只要代码提交到git上就永久不会丢失,可以随时穿越，团队协作，强大的分支管理功能。 安装 windows git下载地址 mac如果安装过xcode自带的git,homebrew是mac的包管理器 mac的命令行工具 http://ohmyz.sh/ http://www.iterm2.com git --version 查看版本号 git 图形化工具 SourceTree 或 Git GUI 初始化仓库 git init 初始化git仓库 git clone &lt;git-repo&gt; 克隆已被git管理项目 git配置 项目仓库配置文件：项目/.git/config 只对本项目仓库生效 git config --local user.name tew git config --local user.email xxx@163.co git config --local -l 当前项目仓库的git配置 全局配置文件：~/.gitconfig或用户/.gitconfig 全局生效，当前登录用户级别 git config --global user.name tew 配置用户名 git config --global user.email xxx@163.com 配置用户邮箱 git config --global core.autocrlf false 禁用换行符自动转换 取消windows下拉取项目将lf转为crlf git config --list 或 git config -l 查看git系统配置 git config --global -l 查看git全局配置 git config --global --unset user.name 删除全局配置 系统级配置文件：git安装路径下的/etc/gitconfig文件 git config --system -l 系统级的git配置 配置信息的优先级：local&gt;global&gt;system。对于所有用户都通用的配置放在system中，对于每个独立用户的配置项放在global中，对于某个仓库特殊的配置放在local中 git的三种区域 工作区 即开发者的工作目录 暂存区 修改已被记录,但尚未录入版本库的区域 版本库 存储变化日志及版本信息 git-open 在浏览器中打开git项目对应的仓库地址npm i -g git-open在任何一个git目录，输入git open 就可以在你的浏览器中打开git项目对应的仓库地址, 支持GitHub, GitLab 常用命令 git add . 将所有工作区文件添加到暂存区 git add file1 file2 ... 将多个文件添加到暂存区 多个文件用空格隔开 git add -u 只把修改过的文件加入暂存区，不增加新增的 git status 查看工作区状态 git show &lt;commitId&gt; 查看某次commit所做的更改 git commit -m &lt;message&gt; 提交暂存区文件到版本库 git commit -am &lt;message&gt; 提交暂存区已修改文件到版本库 无法提交为跟踪文件（未执行git add操作） git commit -amend 修改提交的文件内容或提交信息 git pull 远程仓库拉取项目最新代码到工作区 git push 将提交推送至远程仓库 版本回退 将版本库从当前版本回退到指定版本 git reset --hard &lt;commitId&gt; 回退本分支到某次提交，重置工作区与暂存区 git reset --hard HEAD^ 回退到前1个版本 git reset --hard HEAD^^ 回退到前2个版本 git reset --hard HEAD~n 回退到前n个版本 git reset --hard 版本号 回退到指定版本git reset它可以被用来移除提交快照，尽管它通常被用来撤销暂存区和工作区的修改。不管是哪种情况，它应该只被用于本地修改——你永远不应该重设和其他开发者共享的快照。当你用 reset 回滚到了某个版本后，那么在下一次 git 提交时，之前该版本后面的版本会被作为垃圾删掉。如果要修改远程共享提交快照请使用git revert git分支 git branch 查看本地分支 git branch -r 查看所有远程分支 git branch -a 查看所有分支 git branch devTest 创建分支 git checkout devTest 切换分支 git merge devTest 合并分支 git branch -d devTest 删除分支 git branch -D devTest 强制删除分支 git branch -m devTest test更改分支名称 git checkout -b devFlow 创建devFlow分支并立即切换到devFlow分支上 git cherry-pick [commit] 选择一个commit，合并进当前分支 git rebase &lt;branch&gt; 衍合指定分支到当前分支 git revert &lt;commit&gt; 撤销指定的提交注：git checkout 文件名或路径` 将暂存区内容还原到工作区(撤销更改) git项目关联的三种方式 本地新建好 Git 项目，然后关联远程仓库` git init 初始化一个Git仓库 git add . 将文件添加到暂存区 git commit -m &quot;提交&quot; 提交暂存区文件 git remote add origin &lt;git-repo-url&gt; 关联远程仓库 git push -u origin master 推送到远程仓库 已建好远程仓库 然后clone到本地git clone &lt;git-repo-url&gt; 将已使用git管理但未关联远程的项目 和指定的远程仓库关联git remote add origin git@github.com:ittew/tetsts.gitgit push -u origin master 远程仓库 git remote add &#39;别名&#39; &#39;远程仓库地址&#39; 添加远程仓库并起别名 git remote 查看远程仓库的详细信息 git remote-v 查看远程仓库的地址 git remote remove &#39;别名&#39; 删除远程仓库的别名 git remote rename &#39;旧名称&#39; &#39;新名称&#39; 更改远程仓库别名 git remote set-url origin &lt;newurl&gt; 设置或修改远程仓库的地址 git配置公钥登录 避免每次都要输入用户名/密码 创建公钥ssh key ssh-keygen -t rsa –C &#39;xxx@163.com&#39; 一路按回车即可 邮箱为git账号绑定的邮箱 在用户目录下找到.ssh目录下id_rsa.pup(公钥)文件 C:\Users\Administrator\.ssh\id_rsa.pup 用编辑器打开id_rsa.pup文件复制全部内容 在gitlab、github或码云上的个人中心添加新的SSH公钥 将复制的内容粘贴进去 测试验证是否配置成功 ssh -T git@github.com 看到以下内容及成功Hi ittew! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 最重要的一步 git remote -v 查看你当前的远程 remote url 不用https协议，改用git 协议（即SSH）git remote set-url origin &lt;sshUrl&gt; 或 将项目目录.git的config文件修改里面的url为git@github.com:xxx/xxx.git 再次查看 git remote -v 出现以下内容即修改成功123456// 修改前 git remote -vorigin https://github.com/ittew/mpvue-book.git (fetch)origin https://github.com/ittew/mpvue-book.git (push)// 修改后 git remote -vorigin git@github.com:ittew/hexo.git (fetch)origin git@github.com:ittew/hexo.git (push) git免密登录的三种方式 配置SSH免密登录 (git配置公钥登录) 在URL中实现 123原来的地址：https://github.com/xxx.git修改的地址：https://用户名:密码@github.com/xxx.gitgit remote add origin master https://用户名:密码@github.com/xxx.git 添加git管理凭证git config --global credential.helper store 输入完git账号密码后执行会保存凭证不用再输入账号和密码参考资料：Git凭证存储 vscode 设置 PowerShell 显示当前分支、更新提示和提交状态VSCode终端默认使用PowerShell，启动powershell，分别执行下面3个命令（提示都输入Yes） 设置权限Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Confirm 使用PowerShellGet安装PowerShellGet\Install-Module posh-git -Scope CurrentUser 全局导入posh-gitAdd-PoshGitToProfile -AllHosts git日志 git log 显示提交日志 git log --pretty=oneline 格式化日志格式 git log --graph 图形化日志记录 git reflog 可以查看所有分支的所有操作记录 git shortlog -sn 统计每个作者的提交个数 git shortlog -sn --no-merges 统计每个作者的提交个数，不包含merge commit git shortlog 统计每个作者的提交情况 git忽略文件`.gitignore 忽略文件，让git不在管理当前项目下的某些文件1234567项目根目录新建 .gitignore 文件.idea 忽略单个文件dist/ 忽略文件夹node_modules/ 忽略文件夹*.h 忽略以 .h 结尾的文件!con.h 不忽略 con.h 文件*.h[s|d] 忽略以 .hs或.hd 结尾文件 更多参考：不同开发语言的gitignore设置 其他 git remote prune origin 远程已经删除的分支，在本地执行git branch -a显示还存在，执行以下命令可以清除 git中操作多个文件使用空格将其隔开即可 如 git add file1 file2 ... git rm filename 删除暂存区和工作区的文件 git rm --cached filename 只删除暂存区的文件，不会删除工作区的文件 git修改密码或输错密码后需重新输入密码并保存密码 git config core.ignorecase false 设置大小写敏感123456// 修改git密码后 执行 gitpull 报错 Authentication failed for 'xxx.git'// 1. 直接修改windows凭据中的git账号密码git config --system --unset credential.helper // 2. 不用默认保存的git秘钥// 执行git pull等相关命令重新输入用户名和密码// 若后续操作每次都需要输入用户名和密码 则执行保存用户名和密码的操作git config --global credential.helper manager //保存用户名和密码 参考资料Git-关于版本控制Git 常用命令图为了前端的深度-git的命令行Git教程–廖雪峰]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包]]></title>
    <url>%2FFiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Fiddler 是世界上最强大最好用的Web调试工具，可以称得上是”神器” 。其用途非常广泛，能记录所有客户端和服务器的HTTP和HTTPS 请求，允许你监视、设置断点，甚至至修改输入输出数据。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.NET语言进行扩展。无论对开发人员或者测试人员来说，Fiddler都是非常有用的工具。 Fiddler下载和安装Fiddler下载地址: Fiddler Fiddler 基本界面 主菜单栏–&gt; Fiddler基础功能 工具栏—&gt; 提供了很多常见的命令 Web Sessions列表(会话列表)—&gt;显示捕捉到的请求的详细信息 功能面板—&gt;包含很多常用的功能比如(Inspectors,AutoResponder等) QuickExec—&gt;命令行工具, 可以输入简单的命令例如cls清空 Fiddler 抓包设置 找到你的网络连接或者wiff，打开HTTP代理， 输入Fiddler所在机器的IP地址(比如:192.168.1.104) 以及Fiddler的端口号8888, 设置代理 安装Fiddler证书这一步是为了让Fiddler能捕获HTTPS请求。如果你只需要截获HTTP请求，可以忽略这一步。假如我安装了Fiddler的机器的IP地址是:192.168.1.104打开手机浏览器访问 http://192.168.1.104:8888， 点&quot;FiddlerRoot certificate&quot; 然后安装证书 默认情况下， Fiddler不会捕获HTTPS会话，需要进行设置,启动Fiddler，在菜单栏中单击Tools-&gt;Fiddler Options-&gt;HTPPS，选中DecryptH PS traffic，在弹出的２个对话框中单击＂Yes＂.同时选中“Igno server certificate errors”来忽略一些证书错误 如图 Fiddler 设置断点修改请求报文Fiddler不但能抓包，还能改包。想要修改HTTP报文，就需要先下断点拦截住HTTP请求报文或者 HTTP响应报文，修改后再放行。Fiddler既能修改HTTP请求报文，也能修改HTTP响应报文。AutoResponder是Fiddler比较重要且比较强大的功能之一。可用于拦截某一请求，并重定向到本地的资源，或者使用Fiddler的内置响应。可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的文件或者得到的是Fiddler的内置响应。 设置断点 修改请求，然后放行 Fiddler 设置断点修改响应体Fiddler修改HTTP响应体，就需要先下断点拦截住HTTP请求，修改后再放行。设置断点 修改响应，然后放行 Fiddler 在线调试线上文件在工作中经常需要去调试 HTML、css、或者JavaScript文件。Fiddler中的Auto Responder功能可以把要调试的文件保存到本地进行调试，这大大减少了在线调试的困难，提高了效率。你只需要修改本地文件，然后刷新浏览器，这样你就能看到修改后的效果了。而不用每次修改代码之后，重新部署到正式服务器上。 注意事项 在Fiddler抓包的过程中，我们经常看到HTTP响应是乱码，单击“Response body is encoded. Click to decode.&quot;可以解压HTTP响应 Fiddler忽略HTTP的握手验证请求 Tunnel to请求, 选在菜单中的 Rules--&gt;Hide CONNESTS 参考资料Fiddler 简介使用Fiddler 做抓包分析Fiddler 命令行和 HTTP 断点调试Fiddler 教程 Vorlon 远程调试 全局安装 npm i -g vorlon 启动服务 vorlon 调试页面引入 &lt;script src=&quot;http://本地ip地址:1337/vorlon.js&quot;&gt;&lt;/script&gt; 手机设置代理 ip地址为电脑的局域网ip地址, 默认端口:8888 浏览器打开调试：http://本地ip地址:1337 weinre真机调试Weinre(WebInspector Remote)是一款基于Web Inspector(Webkit)的远程调试工具，借助于网络，可以在PC上直接调试运行在移动设备上的远程页面 全局安装 npm install –g weinre 启动 weinre --httpPort 8090 --boundHost -all- 123456// 8080端口使用情况较多，所以我选择了指定8090端口。httpPort: 设置Wninre使用的端口号，默认是8080boundHost: [hostname | Ip | -all-]: 默认是 'localhost'.debug [true | false] :这个选项与–verbose类似， 会输出更多的信息。默认为false。readTimeout [seconds]:Server发送信息到Target/Client的超时时间， 默认为5s。deathTimeout [seconds]:默认为3倍的readTimeout,如果页面超过这个时间都没有任何响应,那么就会断开连接. 在浏览器中输入localhost:8090 打开 WeinreDe bug 客户端 在我们要调试的页面中，增加一个脚本。&lt;script src=&quot;http://localhost:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;记住将localhost换成你的IP地址. 在手机端访问要调试的网页,就可以点击Elements进行调试, 修改样式时，会在手机端即时生效，并且也可以查看控制台信息。 Charles实现本地数据mock模拟 安装 windows 版charles 官网下载地址 项目中引入VConsole&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vConsole/3.0.0/vconsole.min.js&quot;&gt;&lt;/script&gt; 项目中引入eruda12&lt;script src="https://cdn.bootcdn.net/ajax/libs/eruda/2.3.3/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt;eruda.init();&lt;/script&gt; eruda和vconsole内置于项目，打印移动端日志，查看网络请求以及查看 Cookie 和 Storage]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础(四)--(BOM,DOM)]]></title>
    <url>%2Fjavascript%E5%9F%BA%E7%A1%80(4)%2F</url>
    <content type="text"><![CDATA[DOM（Document Object Model）（文档对象模型） 定义了用于访问文档的标准, 允许程序和脚本动态访问和更新文档的内容、结构和样式。BOM（borwser Object Model）（浏览器对象模型） 使用对象描述了浏览器的各个部分的内容。DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口。 BOM(Browser Object Model) 浏览器对象模型window对象 窗口本身 BOM模型中的顶层对象123456789101112// window尺寸兼容获取方法 (不包括工具栏和滚动条)var w=window.innnerWidth(标准浏览器)||document.body.clientWidth(IE5678)||document.documentElement.clientWidthwindow.open() // 在新窗口打开空白页面// window.open(url, target, setting, boolean)// 参数1：要加载的URL 参数2：窗口目标 参数:3：新目标窗口的一些设置 参数4：是否取代浏览器历史记录window.open("http://www.baidu.com") // 在新窗口打开指定网页(默认为新窗口打开)window.open("http://www.baidu.com",'_self') // 在自身窗口打开指定页面window.open("http://www.baidu.com",'name','width=320,height=480') // 在自身窗口打开指定页面window.close() // 关闭窗口 基本不用window.moveTo() // 使窗口移动到制定位置window.resizeTo() // 使窗口尺寸改变指定大小 Navigator对象①window.navigator.userAgent 获取操作系统的版本,浏览器版本/类型的信息②window.navigator.appName 返回浏览器的名称③window.navigator.cookieEnabled 返回指明浏览器中是否启用cookie的布尔值④window.navigator.paltform 获取用户所使用的操作系统 History对象①window.history.length 返回浏览器历史列表中的url数量②window.history.back() 加载 history 列表中的前一个 URL③window.history.forward() 加载 history 列表中的下一个 URL④window.history.go(-num) 加载 history 列表中的某个具体页面 location对象①window.location 返回当前文档的URL②window.location.href=&quot;http://www.baidu.com&quot; 跳转页面②window.location.assign(&#39;http://www.baidu.com&#39;) 跳转页面③window.loaction.reload() 刷新当前页面④window.loaction.search 返回地址栏中?后面的参数⑤window.location.hash 返回地址栏中的hash值 screen对象①window.screen.width 返回显示器的宽度②window.screen.height 返回显示器的高度③window.screen.availHeight/availWidth 有效宽度或高度去除任务栏 document对象包含了页面中的可见内容,由html标签对象节点构成对象树树根就是document1.可视区尺寸document.documentElement.clientWidthdocument.documentElement.clientHeight2.滚动距离document.documentElement.scrollTop||docuemnt.body.scrollTop3.文档高度document.documentElement.offsetHeightdocument.body.offsetHeight (IE) DOM (Document Object Model) 文档对象模型 整个页面结构DOM对象属性1.document.cookie 设置或返回与当前文档有关的所有cookie2.document.title 当前文档的标题3.document.URL 当前文档(页面)的完整URL(地址栏显示的URL)4.document.domain 获取域名5.document.referrer 连接到当前页面的那个页面的URL6.document.documentElement 获取html对象7.document.body 获取body对象8.document.body.innerHTML 获取body内容123456ex:var t = document.title // 获取titleconsole.log(t) //字符串的练习document.title = '字符串' // 设置titleconsole.log(document.title) //字符串var u = document.URLconsole.log(u) //file:///C:/Users/Administrator/Desktop/1.html 获取DOM对象的方法 document.getElementById(&#39;test1&#39;) 按ID找 返回值是单个对象 多个相同ID时只返回第一个 document.getElementsByTagName(&#39;p&#39;)[0] 必须加方括号下标明确那一个对象document.getElementsByTagName(&#39;p&#39;)[1].style.background=&quot;green&quot;按标签找 返回值是对象的集合(数组) 即使只找到一个也包装成对象的集合document.getElementsByTagName()动态方法 可以动态获取元素,获取动态的NodeLists,改变dom结构会影响Nodelists document.querySelectorAll() 返回所有匹配到的元素NodeList集合，没匹配到返回空的NodeList静态方法 获取静态的Nodelist,改变相关的node不会改变静态的nodelist,这个对象必须在获取的时候被创建出来在动态NodeList里return的是一个指针，而静态的NodeList返回时当前的node所有信息。 document.querySelector(CSS选择符) 返回匹配到的第一个元素，没匹配到返回null document.getElementsByName(&#39;username&#39;)[0]对于表单元素 可以用name来找返回值是对象的集合(数组)注:获取表单中输入的数据 document.表单名.表单元素名.value document.getElementsByClassName(&#39;test2&#39;)[0] //IE9以下不兼容按类名查找 对象的集合(数组) 12345678910111213141516171819202122232425/*&lt;body&gt; &lt;h1&gt;找对象&lt;/h1&gt; &lt;div id="test1"&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/div&gt; &lt;div class="test2"&gt;class test2&lt;/div&gt; &lt;input type="text" name="username" value="bob" /&gt;&lt;/body&gt;*///获取class 兼容ie9以下var body = document.getElementsByTagName('body')var con = getByClass(body[0],'con')console.log(con[0].className)function getByClass(oParent,cla)&#123; var arr = [] var ele = oParent.getElementsByTagName('*') var re = new RegExp('\\b'+cla+'\\b') //独立部分 for(var i=0;i&lt;ele.length;i++)&#123; if(re.test(ele[i].className))&#123; arr.push(ele[i]) &#125; &#125; return arr&#125; 操作对象的属性123456789101112131415161718&lt;img src="" alt="" title="" style="width:200px;height:200px;" /&gt;img对象的属性 img.src img.alt img.title img.style普通属性的读取 对象.标签属性普通属性的改值 对象.标签属性 = "值"获得元素的自定义属性 getAttribute('alt')设置元素的自定义属性 setAttribute('abc','hao')移除元素的自定义属性 removeAttribute('alt')attributes 属性值集合getAttribute() 获取节点行间属性的值 setAttribute() 设置行间属性节点的值自定义属性的设置和获取obj.attr = "值"obj.index = i; //索引值匹配 匹配对应关系js中允许把 "." 换成 "['']"obj.style.width = "100px" // .后面的值无法修改obj.style[attr] = value // []后面的值可以随便写 设置样式对象.style.width = &#39;100px&#39;对象.style.cssText = &#39;width:100px;height:100px&#39; 只会修改行内的样式 后写的覆盖前面的 获取样式1234567891011121314151617181920// 行间样式的获取 CSS属性的访问oBox.style.width // 只能获取行间样式// 操作class要用className obj.className// 如果修改元素的float属性obj.style.styleFloat = "left"; (IE)obj.style.cssFloat = "left"; (非IE)// 如果css属性带有横线则把横线去掉后的字母大写 obj.style.marginLeft// 非行间样式的获取 (得到的是计算后最终的样式)1.getComputedStyle(oBox,null(伪元素)).width//标准浏览器兼容,IE8以下不兼容2.oBox.currentStyle.width //IE6,7,8和opera兼容,其他不兼容// 兼容写法(不能直接获取复合样式,不要获取未设置的样式)console.log(getStyle(oBox,'width'));function getStyle(obj,attr)&#123; return obj.currentStyle?obj.currentStyle[attr]:getComputedStyle(obj)[attr];&#125;注: 属性操作注意事项 a. 所有的相对路径都别拿来做判断 b. 颜色值不要拿来做判断 背景图片路径也不能做判断 c. innerHTML值别拿来做判断 d. 所有的图片路径不能做判断 但是可以用getAttribute('src') DOM节点相关操作 节点信息 12345678910111213a.nodeName // 节点名称 obj.nodeName 元素节点和属性节点:标签或属性名称 文本节点: 永远都是#text 文档节点: 永远都是#documentb.nodeType // 节点类型(返回数值) obj.nodeType NodeType:节点类型12种(常见有 元素节点 文本节点 属性节点 注释节点) 元素节点:返回1 属性节点:返回2 文本节点:返回3 文字,空格或换行都属于文本节点 注释节点:返回8 文档节点:返回9c.nodeValue //获取节点的值 只有属性节点,注释节点和文本节点才有值,元素节点是没有值 返回null(节点值用innerText) 查找节点 123456789101112131415a.子节点 obj.childNodes // 获取所有子节点 在IE6 7 8只会找到元素节点 而其他浏览器所有节点都会找到 obj.children // 只会找到元素节点 不存在兼容问题 推荐使用b.父节点 //obj.parentNode 找元素的父节点c.兄弟节点 obj.nextElementSibling //下一个兄弟节点 obj.previousElementSibling //上一个兄弟节点 obj.nextSiblings // 取得下一个紧邻的兄弟元素 obj.previousSiblings // 取得上一个紧邻的兄弟元素d. 第一个或最后的节点 obj.firstElementChild obj.lastElementChild注:nextSibling属性与nextElementSibling属性的差别：nextSibling返回指定元素节点后下一个兄弟节点(包括文本节点、注释节点即回车、换行、空格、文本)nextElementSibling属性只返回元素节点之后的兄弟元素节点(不包括文本节点、注释节点) 节点相关操作 1234567891011121314151617181920212223242526272829303132A. 创建节点 document.createElement('标签')B. 添加节点 parentNode.appendChild('元素节点') // 往父节点后面添加一个子节点 parentNode.insertBefore(新节点,子节点或null) // 在指定子节点前面插入一个节点 parentNode.insertAfter(新节点,子节点) //在指定子节点后面插入一个节点C. 删除节点 obj.parentNode.removeChild(obj) 先找到对象 再找到其父元素 在删除该对象D. 替换节点 parentNode.replaceChild(用来替换节点,被替换节点) 参数必须C. 克隆节点 obj.cloneNode(boolean) 默认为false 但不会clone事件 true: 克隆元素及其包含的子孙节点 false: 克隆元素但不包含的子孙节点创建及添加元素节点var div1=document.createElement('div');var odiv=document.getElementById("one");odiv.appendChild(div1);创建及添加属性节点var newAttr= document.createAttribute("id");var odiv=document.getElementById("one");newAttr.value="newDiv1";odiv.setAttributeNode(newAttr)创建及添加文本节点var div1=document.createElement('div');var odiv=document.getElementById("one");var txt=document.createTextNode("文本内容");div1.appendChild(txt);odiv.appendChild(div1); innerHTML与innerText 123456789obj.innerHTML="&lt;li&gt;春&lt;/li&gt;&lt;li&gt;夏&lt;/li&gt;&lt;li&gt;秋&lt;/li&gt;"; //改变标签里的内容/*&lt;div id="test"&gt;&lt;span&gt;test1&lt;/span&gt;test2&lt;/div&gt;*/test.innerHTML: 包括Html标签和文本内容 // &lt;span&gt;test1&lt;/span&gt;test2test.innerText: 去除Html标签只含文本内容 // test1 test2test.outerHTML: 除了包含innerHTML的全部内容外, 还包含对象标签本身。//&lt;div id="test"&gt;&lt;span&gt;test1&lt;/span&gt;test2&lt;/div&gt;注:innerHTML是符合W3C标准的属性,而innerText不适用于firefox浏览器,// 在火狐中可以使用 test.TextContent 或 test.innerHTML.replace(/&lt;.+?&gt;/gim,'') 动态添加脚本文件 12345678910function loadScript (url, cb) &#123; var script = document.createElement('script') script.type = 'text/javascript' script.onload = function () &#123; cb &amp;&amp; cb() &#125; script.src = url document.body.appendChild(script)&#125;loadScript('test.js') 动态添加样式文件 123456789101112function loadStyle (url, cb) &#123; var link = document.createElement('link') link.rel = 'stylesheet' link.type = 'text/css' link.onload = function () &#123; cb &amp;&amp; cb() &#125; link.href = url var head = document.head || document.getElementsByTagName('head')[0] head.appendChild(link)&#125;loadStyle('common.css') JS 表格和表单的操作 表单的操作1.selectedIndex 可设置或返回下拉列表中被选择选项的索引号,若多选则返回第一个被选择的索引号obj.options[obj.selectIndex].value 获取选中下拉列表选项的值2.focus()获取焦点 select()选中3.复选框和单选按钮的onclick事件可以通过checked判断是否被选中下拉列表一般用onchange事件遍历所有项通过selected判断是否选中注. IE6,IE7,IE8 不支持input类型修改,会报错4.document.forms 获取页面中所有的表单 表格的操作 1234567891011121314tab.tHead //获取表格头部theadtab.tFoot //获取表格底部tfoottab.tBodies //获取表格主体tbody可以有多个// tr和td对象的访问tab.rows //获取表格中的行数trtab.rows[0].cells //获取某一行的列数//通过数组方式更新指定单元格中的数据tab.rows[1].cells[2].innerHTML="as";//tr和td对象的创建tab.insertRow() //为表格新增行row.insertCell() //为行新增列(参数-1)表示新增在最后面//tr和td对象的删除tab.deleteRow() //删除行tab.rows[0].deleteCell() //删除列 DOM扩展 document.activeElement HTML5新增辅助管理DOM焦点的功能 123456789// document.activeElement // 会始终引用DOM中当前获得了焦点的元素// 获得焦点的方式：页面加载、用户输入(Tab)、调用focus()// 文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用 加载期间值为nullconsole.log(document.activeElement) // &lt;body&gt;...&lt;/body&gt; 加载完成默认是bodyvar btn = document.getElementById('btn')btn.focus()console.log(document.activeElement === btn) // true// doucment.hasFocus() // 确认文档是否获得了焦点console.log(doucment.hasFocus) // 文档是否获取了焦点 可判断用户是否正在与页面交互 classList HTML5新增的操作类名的方式 1234obj.classList.add('demo') // add 添加指定的类名 如果已存在就不在添加obj.classList.contains('demo') // contains 是否包含给定类名 存在返回true 否则返回falseobj.classList.remove('demo') // remove 删除给定的类名obj.classList.toggle('demo') // toggle 如果已存在给定类名则删除它，如果不存在给定的值则添加给定类名 data-xxx HTML5新增自定义数据属性 123// 在标签上添加 data-开头自定义属性 可以通过 元素.dataset.属性获取// &lt;div id="mydiv" data-appid = '123' data-name='tew'&gt;console.log(mydiv.dataset.appid + '-' + mydiv.dataset.name) // 123-tew ele.scrollIntoView() 123// 滚动浏览器窗口或某个容器元素，使调用元素或获得焦点元素出现在视口中// scrollIntoView(true)或scrollIntoView() // 滚动之后会让调用元素顶部与视口顶部尽可能平齐// scrollIntoView(false) // 滚动之后会让调用元素尽可能全部出现在视口中 调用元素底部与视口顶部平齐 ele.scrollIntoViewIfNeeded() 1234// 将不在视口可见区域的元素滚动到视口课件区域，如果已在视口可见区域则不滚动// ele.scrollIntoViewIfNeeded() 同 ele.scrollIntoViewIfNeeded(true)// 元素将在其所在滚动区的可视区域中居中对齐// ele.scrollIntoViewIfNeeded(false) // 元素将与可视区域最近的边缘对齐 contentDocument 框架内容文档对象 1234// &lt;iframe id='myIframe'&gt;var iframe = document.getElementById('myIframe')var iframeDoc = iframe.conetenDocument || iframe.contentWindow.document// iframe.contentWindow.document 兼容IE8 try-catch 错误处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 把有可能抛出错误的代码都放在try语句块中，而把那些用于错误处理的代码放在catch语句块中try &#123; // 可能会导致错误的代码 try 中的任何代码发生错误就会立即退出执行，然后接着执行catch块&#125; catch (error) &#123; // 在错误发生时的处理&#125; finally &#123; // 无论try或catch执行 finally语句都会执行&#125;// 无论执行try或catch finally 都会被执行try &#123; console.log(a)&#125; catch (err) &#123; console.log(err) // ReferenceError: a is not defined&#125; finally &#123; console.log('finally') // finally&#125;try &#123; var a = 1 console.log(a) // 1&#125; catch (err) &#123; console.log(err)&#125; finally &#123; console.log('finally') // finally&#125;// 只要代码中包含了finally子句，无论try还是catch语句块中的return语句都将被忽略// 在try还是catch语句块中包含return语句 finally需谨慎使用function test () &#123; try &#123; return 2 &#125; catch () &#123; return 1 &#125; finally &#123; return 0 &#125;&#125;console.log(test()) // 0``#### 其他* 可视区的宽/高1.`document.documentElement.clientWidth` 可视区域的宽2.`document.documentElement.clientHeight` 可视区域的高* 元素的宽/高1.`offsetWidth/offsetHeight`: 获取元素的宽度或高度=`width/height+padding+border`2.`clientWidth/clientHeight`: 获取元素的宽度或高度=`width/height+padding````js/*css#one&#123; height:100px; width:100px; background:red; margin:20px 30px; padding:20px 30px; border:10px solid black;&#125;*/console.log(one.offsetWidth); //180=100+30+30+10+10console.log(one.clientWidth); //160=100+30+30 scrollTop 滚动高度 被隐藏在内容区域上方的像素值兼容写法 var scrollTop = document.body.scroolTop || document.documentElement.scrollTop offsetParent 最近有定位属性的祖先节点 如果祖先没有定位则你认为body offsetLeft/offsetTop 外边框到有定位父级的内边框的距离 obj.getBoundingClientRect() 获取元素的信息(返回对象)包括 height width bottom top right left 获取的值会随滚动条变化 window.onerro 捕获即时运行错误 任何没有通过try-catch处理的错误都会触发 performance.getEntries() 获取所有加载成功的资源列表 document.images 获取页面中所有的images]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础(三)--(内置对象,事件)]]></title>
    <url>%2Fjavascript%E5%9F%BA%E7%A1%80(3)%2F</url>
    <content type="text"><![CDATA[Date对象123456789101112131415161718192021222324252627282930//返回当前的日期和时间var d = mew Date() //Sat Jun 24 2017 10:34:00 GMT+0800 (中国标准时间)d.getFullYear() //返回四位数的年份d.getMonth() //返回月份(0--11)实际d.getMonth()+1d.getDate() //返回一个月中的某一天(1--31)d.getDay() //返回一周中的第几天(0--6)d.getHours() //返回小时(0--23)d.getMinutes() //返回分钟(0--59)d.getSeconds() //返回秒数(0--59)d.getMilliseconds() //返回毫秒d.getTime() //返回1970.1.1 0:0:0到现在的毫秒数// Date对象参数 无参数默认返回当前系统时间// 数字形式new Date(2017,4,1,9,48,12)// 字符串形式new Date("June 10,2013,12:12:12")new Date('2017-9-8 12:34:56') // ios 不兼容new Date('2017/9/8 12:34:56')//时间戳new Date(1495835060500)//时间转换公式var t = Math.floor((endTime-now)/1000)// 天: Math.floor(t/86000)// 时: Math.floor(t%86400/3600)// 分: Math.floor(t%86400%3600/60)// 秒: t%60// 获取当前时间戳new Date().getTime() // 1511418074000Date.now() // 1511428145000+new Date() // 1511428145000 Math对象 Math.ceil() 大于或小于该数的最小整数(向上取整) Math.floor() 小于或等于该数的最大整数(向下取整) Math.round() 四舍五入 Math.min(m,n) 取最小的 Math.max(m,n) 取最大的 Math.sqrt(m) m的开方 Math.pow(m,n) m的n次方 Math.toFixed(n) 保留小数点后几位 Math.random() 返回0-1的随机数 Math.abs() 取绝对值取n到m的之间的随机数 Math.round(Math.random()*(m-n)+n) String对象字符串的长度 str.length(只关注字符的个数,不关心是汉字还是其他字符) 不可写字符串中单个字符可以使用[]获取 str[1]字符串比较大小时 比较第一个字符的ASCII码js中字符串截取只关注字符的个数,不关心是汉字还是其他字符 substr(start,length) 从指定位置截取指定长度的子字符串(包括起始位置)①:如果start为负数 则start=str.length+start②:如果length为负数或0 则返回一个空字符串③:如果没指定length 则返回start后面的所有字符 12345var str = "我有一个梦想"console.log(str.substr(2,2)) //一个console.log(str.substr(2,0)) //空字符串console.log(str.substr(2)) //一个梦想console.log(str.substr(-2,4)) //梦想 substring(start,end) 从指定位置截取到结束位置end-1的字符串①:如果start或end为负数或NaN,它被看做0②:如果start和end相等 则返回一个空字符串③:如果没指定end 则返回start后面的所有字符④:参数反转,交换位置,总使用最小的作为开始,大的作为结束,大于字符串长度,视为字符串长度 12345var str="我有一个梦想"console.log(str.substring(2,5)) //一个梦console.log(str.substring(2)) //一个梦想console.log(str.substring(4,3)) //个console.log(str.substring(-1,5)) //我有一个梦 slice(start,end) 从指定位置截取到结束位置end-1的字符串 不包含结束位置end①参数不反转 不交换位置②负数从后面倒着往前数&#39;a1b3c&#39;.slice(1, 3) //=&gt; 1b str.charAt(n) 返回某位置的字符,如果n为负数或大于str.length则返回空 1234var str1 = 'wamp'console.log(str.charAt(1)) //aconsole.log(str.charAt(5)) //空字符串console.log(str.charAt(-1)) //空字符串 str.charCodeAt(n只能是数字) 返回某个位置的字符的ASCII编码 1var str1 = 'wamp' str.charAt(1)) //97 String.fromCharCode(16800) 返回ASCII码对应的字符 可写多个 1(String.fromCharCode(11111,12345)) //口艹` str.indexOf() 左–&gt;右 返回某个字符的第一次出现位置 找不到返回-1str.indexOf(&#39;cd&#39;,n) 从第几位开始找某个字符 若n为负数 当成0 12345678910111213var str = 'wampacda'console.log(str.indexOf('a')) // 1console.log(str.indexOf('b')) // -1console.log(str.indexOf('a',3)) // 4console.log(str.indexOf('a',-2)) // 1// 找出某字符出现的所有位置var str = 'wampaccdabakakakakkak'for(var i=0;i&lt;str.length)&#123; var a = str.indexOf('a',i) if(a == -1)break console.log(a) i=a+1&#125; str.lastIndexOf() 右–&gt;左 返回某个字符的最后一次出现位置 找不到返回-1 12var str = 'wampacda'console.log(str.lastIndexOf('a')) //8 str.split() 拆分字符串为数组 第二个参数表示长度 12345var str = 'www.tanzhouedu.com'console.log(str.split('')) //w,w,w,.,t,a,n,z,h,o,u,e,d,u,.,c,o,mconsole.log(str.split('.')) //www,tanzhouedu,comconsole.log(str.split('b')) //www.tanzhouedu.comconsole.log(str.split('.',2))//www,tanzhouedu str.toUpperCase() 把字符串全部转化为大写 12var str = 'www.tanzhouedu.com'console.log(str.toUpperCase())//WWW.TANZHOUEDU.COM str.toLowerCase() 把字符串全部转化为小写 12var str = 'Www.TanzhouEdu.coM'console.log(str.toUpperCase())//www.tanzhouedu.com str.match(/\d+/g) 正则匹配 str.replace(/abc/,&quot;aaa&quot;) 查找并替换 数组对象 数组是多个变量的集合 数组中的每一个值叫做一个元素，每一个元素在数组中的位置，以数字表示，称为索引。 声明方式①var arr = [&#39;a&#39;,2,&#39;abc&#39;,function a(){},{}]②var arr1 = new Array(a,b,c,d)③var arr = new Array(5) 创建初始值为undefined长度为5的数组 12345// 注:二维数组的声明及访问// 当使用new Array(n)时,如果n为数字则代表数组长度, 为字符串则表示数组的内容var arr=[[1,2,3],["数字","数字"],["a","b"]]console.log(arr[2][1]) //b// 获取二位数组的长度arr[i].length 数组元素的访问 12var arr = ['a',2,'abc',function a()&#123;&#125;,&#123;&#125;]console.log(arr[3]) //function a()&#123;&#125; 数组的长度arr.length 可写(可以更改)当定义数组的索引值超过数组长度,自动扩展数组长度,当获取数组中不存在索引时将返回undefined 12345678910var arr = ['a',2,'abc',function a()&#123;&#125;,&#123;&#125;]console.log(arr.length) //5var arr1 = [1,2,3,4]// 缩减数组arr1.length = 2console.log(arr1) // [1, 2]// 快速清空数组 arr.length = 0 或 arr = []arr1.length = 0console.log(arr1) //[]// 注:数组的元素字母和汉字都要用引号引起来 arr.push() 从后面给数组添加元素 返回数组长度 123var arr = ['a',2,'abc',function a()&#123;&#125;,&#123;&#125;]console.log(arr.push('你好')) //6console.log(arr) //['a',2,'abc',function a()&#123;&#125;,&#123;&#125;,'你好'] arr.unshift() 从前面给数组添加元素 返回数组长度(IE 6,7无返回值) 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.unshift('你好')) //5console.log(arr) //['你好','a',2,'abc',function a()&#123;&#125;,&#123;&#125;] arr.pop() 删除数组最后一个元素 返回数组最后一个元素 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.pop()) //function a()&#123;&#125;console.log(arr) //['a',2,'abc'] arr.shift() 删除数组第一个元素 返回数组第一个元素 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.shift())console.log(arr) //[2,'abc',function a()&#123;&#125;] arr.splice() 向/从数组中添加/删除元素，然后返回被删除的元素①arr.splice(start) 从第几个开始删除后面的 返回删除的所有元素 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.splice(2)) //abc,function a()&#123;&#125;console.log(arr) //[a,2] ②arr.splice(start,n) 从第几个开始删除几个 返回删除的元素若start为负从结尾开始,n为0,不删除 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.splice(2,1)) //abcconsole.log(arr) //[a,2,function a()&#123;&#125;] ③arr.splice(start,n,m)从start开始的几个,替换为m 123var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.splice(1,2,'你好')) //2,abcconsole.log(arr) //[a,你好,function a()&#123;&#125;] ④arr.splice(start,0,m)从第几个开始添加m 12345678910111213var arr = ['a',2,'abc',function a()&#123;&#125;]console.log(arr.splice(1,0,'你好')) //空console.log(arr) // ["a", "你好", 2, "abc", ƒ]//数组去重var arr = [1,2,3,2,1,4,2]for(var i=0;i&lt;arr.length;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; arr.splice(j--,1) &#125; &#125;&#125;console.log(arr) // 1,2,3,4 arr.sort() 把数组内的元素按字符编码或大小升序排列(原数组改变) 1234567891011121314151617// sort方法内部默认是调用每个数组项的toString(),然后按字符串比较，通常会自定义比较函数var arr = ['a',2,'abc',function a()&#123;&#125;,1]console.log(arr.sort()) //[1,2,'a','abc',function a()&#123;&#125;]console.log(arr) //[1,2,'a','abc',function a()&#123;&#125;]var arr1 = [1, '10', '5', 4]arr1.sort() // [1, '10', 4, '5'] 默认按字符串编码排序arr1.sort((a, b) =&gt; a - b) // [1, 4, '5', '10']// 改变排序规则 arr.sort(function(a,b)&#123; return b-a&#125;) 倒序var arr = [1,6,55,4,8]console.log(arr.sort(function(a,b)&#123; return b-a //只是改变顺序不改变数据&#125;)) //55,8,6,4,1// 随机排序打乱数组var arr = [55,8,6,4,1]console.log(arr.sort(function(a,b)&#123; return Math.random()-0.5 //只是改变顺序不改变数据&#125;)) //55,8,6,4,1 arr.reverse() 把数组的顺序颠倒(原数组改变) 123var arr = ['a',2,'abc',function a()&#123;&#125;,1]console.log(arr.reverse()) //[1,function a()&#123;&#125;,'abc',2,'a']console.log(arr) //[1,function a()&#123;&#125;,'abc',2,'a'] arr1.concat(arr2) 数组合并 将数组打散然后拼接在一起 返回拼接后的新数组 (原数组不改变) 123456789var arr1 = ['a','b','c']var arr2 = [1,2]console.log(arr1.concat(arr2,[arr3])) //['a','b','c',1,2]console.log(arr1) //['a','b','c']console.log(arr2) //[1,2]// 将数组打散然后拼接在一起[].concat(1,2,3); // [1,2,3][].concat([1, 2], 4); // [1, 2, 4][].concat([1, 2], [3, 4]); // [1, 2, 3, 4] arr.join() 将数组转化为字符串 返回整个数组元素的字符串(原数组不改变) 123456var arr1 = ['a','b','c']console.log(arr1.join()) //'a,b,c'console.log(arr1) //['a','b','c']var arr = ['a','b','c']console.log(arr1.join('&lt;')) //'a&lt;b&lt;c'console.log(arr1) //['a','b','c'] arr.toString()或arr.valueOf() 将数组的每一个元素转化为以逗号分割的字符串 123var arr = [1,4,2,'a'].toString() // "1,4,2,a"var arr = [1,4,[2,'a',[5, '多']]].toString() // "1,4,2,a,5,多"arr.toLocaleString()：//将对象转换成字符串 arr.slice() 可从已有的数组中返回指定的元素 返回一个新的数组(包含start不包含end) 12var arr = ['a',1,'b',3,'c']console.log(arr.slice(1,3)) // [1,'b'] arr.map() 方法按照原始数组元素顺序依次处理元素。映射应该有返回值注意： map() 不会对空数组进行检测。 map() 不会改变原始数组。 123456var data=[1,3,4]var Squares=data.map(function(val,index,arr)&#123;console.log(arr[index]==val) // ==&gt; truereturn val*val&#125;)console.log(Squares) // 1,9,16 arr.forEach() 从头到尾遍历数组，为每一个元素调用指定的函数 12var data = [1,2,3,4]data.forEach(function(v,i,a)&#123; a[i] = v + 1 &#125;) // [2,3,4,5] arr.filter() 过滤数组元素 返回新数组 12data = [1,5,8]data.filter(function(v)&#123; return v&gt;5 &#125;) // [8] arr.every() 对数组中的所有元素调用判定函数都返回true，结果才返回true 123data = [1,5,8]data.every(function()&#123; return x&lt;10 &#125;) // truedata.every(function()&#123; return x&lt;7 &#125;) // false arr.some() 对数组中的所有元素调用判定函数只要有一个返回true，结果返回true 123data = [1,5,8]data.some(function()&#123; return x&lt;7 &#125;) // truedata.some(function()&#123; return x&lt;1 &#125;) // false arr.reduce() 和 arr.reduceRight()用指定的函数将数组元素进行组合第一个参数是执行操作的函数，第二个参数（可选）传递给函数的初始值 1234567891011121314151617181920// arr.reduce((sum, item) =&gt; &#123;&#125;,num)/* 1. 当没有第二个参数初始值num时第一次循环 sum默认为数组的第0个 item为数组的第1个 第二次以后 sum = sum + item */var arr = [1, 2, 3, 4]arr.reduce((sum, item) =&gt; &#123; console.log(sum, item)&#125;)// 1 2 undefined 3 undefined 4let res = arr.reduce((sum, item) =&gt; &#123; console.log(sum, item) // 第一次 1 2 第二次 3 3 第三次 6 4 return sum + item&#125;)console.log(res) // 10/* 2. 当有第二个参数 初始值num时第一次循环 sum就是初始值num item为数组的第0个 第二次以后 sum = sum + item*/let res = arr.reduce((sum, item) =&gt; &#123; console.log(sum, item) // 第一次 5 1 第二次 6 2 第三次 8 3 第四次 11 4 return sum + item&#125;, 5)console.log(res) // 15 arr.indexOf()和arr.lastIndexOf()返回找到的第一个元素的索引，找不到返回-1 1234data = [1,5,8,1,5]data.indexOf(1) // 0data.lastIndex(1) // 3data.indexOf(6) // -1 Array.isArray(arr) 判断对象是否是数组 事件（event） 事件:浏览者在浏览网页时触发某些动作所作出的相应反应 常见事件onclick 鼠标单击事件 当鼠标单击选定元素时所触发的事件ondblclick 鼠标双击事件 当鼠标双击选定元素时所触发的事件onmousedown 鼠标按下事件 当按下鼠标时所触发的事件onmouseup 鼠标释放事件 当按下鼠标被释放时所触发的事件onmousemove 鼠标移动事件 当鼠标指针在选定元素上移动时触发的事件onmouseover 鼠标经过事件 当鼠标经过选定元素时触发的事件onmouseout 鼠标离开事件 当鼠标指针离开选定元素时触发的事件onkeydown 按下键盘按键事件 当用户按下键盘上任意键时触发的事件onkeypress 按下并释放按键事件 当用户按下键盘按键并任意释放按键时触发的事件onkeyup 释放键盘按键事件 当按下键盘按键后释放按键时触发的事件onerror 页面出错事件 当页面在加载文本或图片时，发生错误所触发的事件onload 页面加载完事件 当页面完成图片文本等内容的加载后触发的事件onunload 离开页面事件 当浏览者结束访问网页而离开网页时触发的事件onresize 窗口改变事件 当浏览器改变页面窗口大小或框架大小被调整时触发的事件onscroll 滚动条滚动事件 当滚动条滚动时触发的事件onblur 失去焦点事件 当选定元素停止作为用户交互的焦点时触发的事件onchange 元素发生改变事件 当选定元素的数据或文字发生改变并失去焦点时触发的事件onfocus 获得焦点事件 当元素获得焦点时触发的事件onreset 表单重置事件 当表单中元素被重置时触发的事件onsubmit 表单提交事件 当表单中的元素被提交时所触发的事件 12345678910111213注: onmouseover,onscroll和onresize都是以时间间隔计算的注: onkeydown 比 onkeypress 早 onkeypress 只响应 字母 数字 符号等 功能键不会响应 在form中写上onsubmit="return fun()" 才能拦截提交的效果 window/img/body.onLoad 加载事件 不是所有的元素都能够获得焦点或有onkeydown事件,能够响应用户操作的元素才有 DOMContentLoaded文档加载形成完整的DOM树之前完成形成 不包含图片资源、js文件、css文件等其他资源 onload包含图片资源onchange不同元素的表现形式: text: 当输入内容改变,并且失去焦点时触发 radio: 被选中的时候才会触发 checkbox: 选中和取消选中都会触发 select: 选中不同的选项时触发 file: 选择文件之后被触发 事件对象 在触发DOM的事件时，产生一个包含所有与事件有关的事件对象event事件在发生的瞬间,发生位置,时间,鼠标按键,触发的节点等信息被打包成一个对象,自动传递给事件函数的第一个参数(event) 1234567891011121314151617181920// 在IE中event对象是window对象的一个全局属性// 键盘键值 ev.keyCode(IE)或ev.which// 鼠标按钮 ev.button //0 鼠标左键 1鼠标中键 2鼠标右键 (firefox)// 事件对象的兼容写法oDiv.onclick = function(ev)&#123; ev = ev || window.event ev.clientX //鼠标对于浏览器窗口可视区域的X坐标(窗口坐标)不包括工具栏和滚动条 ev.clientY //鼠标对于浏览器窗口可视区域的Y坐标(窗口坐标)不包括工具栏和滚动条 ev.screenX //鼠标相对于用户显示器屏幕左上角的X坐标 屏幕坐标位置 ev.screenY //鼠标相对于用户显示器屏幕左上角的Y坐标 屏幕坐标位置 ev.pageX //鼠标相对于文档的X坐标 页面坐标位置 ev.pageY //鼠标相对于文档的Y坐标 页面坐标位置 // 阻止默认行为 或者 return false ev ? ev.preventDefault() : window.event.returnValue = false // 事件目标和事件源 ev.target 标准浏览器事件源 ev.srcElement ie事件源 var target = ev.target || ev.srcElement // 阻止冒泡 ev.stopPropagation() || ev.cancelBubble = true&#125;// 事件目标和事件源 事件冒泡 事件开始由触发事件的元素然后逐渐向上传播到较为不具体的节点(document)当父元素和子元素都加入onclick事件时,触发子元素onclick事件后父元素的onclick事件同样会被触发,造成事件的多层并发(事件由内向外传递)阻止冒泡事件 在当前要阻止冒泡的事件函数中使用ev.cancelBubble = true 或 ev.stopPropagation() 事件捕获 事件开始由较为不具体的节点(document)更早接收到，触发事件的元素最后接收到事件当父元素和子元素都加入onclick事件时,触发子元素onclick事件后父元素的onclick事件同样会被触发,造成事件的多层并发(事件由外向内传递) 事件三个阶段1 捕获(从外向内寻找触发事件的元素)2 目标(找到触发事件的元素)3 冒泡(事件从内向外冒泡) 事件绑定 给元素绑定额外事件 123456789101112131415161718192021222324252627282930// 标准浏览器obj.addEventListener(事件名&lt;去掉on&gt;,事件函数,是否捕获)ev: obj.addEventListener('click',fn2,false) false 冒泡 一个出去的事件触发了你,你就去执行fn2这个函数 true 捕获 一个进去的事件触发了你,你就去执行fn2这个函数特点:1. 有事件捕获 2. 事件名称没有on 3. 事件函数执行的顺序是正序 4. this指向触发该函数的事件的对象// IE8以下支持obj.attachEvent(事件名 ,事件函数)ev: obj.attachEvent('onclick',fn2)特点:1. 没有事件捕获 2. 事件名称有on 3. 事件函数执行的顺序 IE8以下 倒序 IE9及以上 正序 4. this指向window// 兼容写法function bindevent(obj,evName,evFn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(evName,evFn,false) &#125;else&#123; obj.attachEvent('on'+evName,funtion()&#123; evFn.call(obj) &#125;) &#125;&#125;// 给一个元素的同一个事件绑定多个不同的函数,直接使用onclick则会覆盖前面的事件// 而使用addEventListener或attachEvent可以绑定多个事件document.bindevent('onclick',fn1)document.bindevent('onclick',fn2) 事件解绑 解除元素的绑定事件 1234567891011121314151617// 普通事件的取消document.onclick = null 取消普通事件// 其他浏览器obj.removeEventListener(事件名&lt;去掉on&gt;,事件函数,是否捕获)ev: obj.removeEventListener('click',fn2,false)// IE8以下不支持obj.detachEvent(事件名 ,事件函数)ev: obj.detachEvent('onclick',fn2)function off(obj,evName,evFn)&#123; if(obj.removeEventListener)&#123; obj.removeEventListener(evName,evFn,false) &#125;else&#123; obj.attachEvent('on'+evName,funtion()&#123; evFn.call(obj) &#125;) &#125;&#125; 事件委托事件委托利用事件冒泡的原理，只在父级指定一个处理事件程序，而不必给每个可单击的元素添加事件处理程序 123456789101112/*&lt;ul id="list"&gt; &lt;li id="apple"&gt;apple&lt;/li&gt; &lt;li id="pear"&gt;pear&lt;/li&gt; &lt;li id="peach"&gt;peach&lt;/li&gt;&lt;/ul&gt;*/list.onclick = function (ev) &#123; var ev = event || ev var target = ev.target || ev.scrElement console.log(target.innerText)&#125; 事件方法obj.onfocus() 给指定元素设置焦点obj.onblur() 取消指定元素的焦点obj.onselect() 选择指定元素里面的文本内容 其他oncontextmenu 右键菜单事件ex:禁止右键 document.oncontextmenu = function(){ return false }contentEditable=true 可以使元素div可编辑onchange 事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发；onpropertychange 事件却是实时触发，任何属性改变都会触发的，即每增加或删除一个字符就会触发，通过js改变也会触发该事件(IE专有)oninput 事件是IE之外大多数浏览器支持,只在value改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过js改变value时，却不会触发；beforeunload 页面卸载前触发]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础(二)--(函数,作用域)]]></title>
    <url>%2Fjavascript%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[函数在javascript中无处不在，函数得功能：提高软件的开发效率，提高软件的可维护性，提高软件的重用性，控制程序设计的复杂性。函数重用封装的思路：尽量保证HTML代码结构一致,可以通过父级选取子元素，把核心主程序实现,用函数包起来，把每组不同的值找出来,通过传参实现. JS 函数 函数是一段完成指定任务的已命名代码块 自定义函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function function_name($arg1,$arg2)&#123; fun_body return arg_n&#125;function_name() // 函数的调用可以在函数前也可以在函数后面1.函数名要有意义,函数名不区分大小写,不能重复定义，和保留字相同的名称不能使用2.被传入的参数称为实参,而函数用于接收的参数称为形参(相当于var arg1 = n),参数可有可无, 可以有多个","用逗号分隔 不定参 arguments 实参的集合 参数个数不固定时function fn()&#123; console.log(arguments.length)//不定参 console.log(arguments[1])&#125;function fn(a)&#123; //形参 console.log(a)&#125;fn(5) //实参// js函数参数设置默认值function simue ()&#123; var a = arguments[0] ? arguments[0] : 1; var b = arguments[1] ? arguments[1] : 2; return a+b;&#125;console.log(simue()) //输出3console.log(simue(10)) //输出12console.log(simue(10,20)) //输出303.函数分为执行过程 和 结果// 函数返回值return后面紧跟要返回的一个值 不会直接输出 可以终止函数后面不执行// 如果函数内不return结果 则返回值默认为undefinedex:function a()&#123; var a = 1;&#125;console.log((a) //函数体 function a()&#123; var a = 1 &#125;console.log((a()) //undefinedex:function fn()&#123; var a = function()&#123; console.log(2) //执行过程 &#125; return a&#125;fn() //没有任何显示console.log(fn()) //函数体 function()&#123;alert(2);&#125;fn()() //2ex:function fn()&#123; var a = function()&#123; console.log(2) &#125; return a()&#125;fn() //2 a()函数执行弹出2console.log(fn()) //2 undefinedfn()() //报错 fn()(即undefined) is not a function4.变量函数：如果将一个函数名称给一个变量在变量后加上()就会调用对应的函数function add()&#123;&#125; var a=add a() 函数声明12345678910function fn()&#123; console.log(1)&#125;console.log(fn) //弹出函数体 function fn()&#123;alert(1);&#125;console.log(fn()) //弹出 1 (主动执行函数)// 函数执行方式a fn()b document.onclick=fnc setInterval('fn()',3000)d setIntertval(fn,3000) 函数表达式(函数自执行)(立即执行函数)12345678910111213a var fn = function()&#123; alert(2);&#125;b !function()&#123;&#125;c (function()&#123;&#125;)()d -function()&#123;&#125;e +function()&#123;&#125;f ~function()&#123;&#125;注:函数表达式 可以直接在末尾加()执行 function()&#123;alert(2)&#125;()// 函数表达式不属于函数声明 b=function()&#123;&#125; 是一个赋值过程是一个函数赋给b变量var a = function b()&#123; console.log(2)&#125;a() //2b() // b is not defined ie8以下弹出 2 闭包作用域只能由内向外寻找得到变量,而不能从外向内得到变量闭包：指有权访问另一个函数作用域中的变量的函数闭包解决的问题(1) 在函数外面可以读取到函数内部的变量(2) 让这些变量始终保存在内存中闭包的基本形式(1) 在外部函数内创建函数(2) 将外部函数的返回值设置为新创建的函数(3) 在外部函数就可以接收到返回值(4) 使用这个函数就可以在外部访问到内部函数的数据特点: 如果内部函数引用了外部函数的参数或者变量,外部函数的参数不会被回收作用: 变量需要长期存在与内存中(创建私有变量) 避免全局变量的污染垃圾回收机制闭包下的变量和参数是不会被回收的，而是一直存在内存当中。而普通局部变量和参数是会使用完以后被垃圾回收机制回收回去，不会存留在内存当中。12345678910111213141516171819202122232425ex: function fn()&#123; var a = 3; console.log(a);&#125;fn() //等fn执行完以后 a会被回收// 闭包运用,存索引,let声明 获取索引值ex: for(let i=0;i&lt;oLi.length;i++)&#123; oLi[i].onclick = funciton()&#123; console.log(i) &#125;&#125;ex: for(var i=0;i&lt;oLi.length;i++)&#123; oLi[i].index = i; oLi[i].onclick = funciton()&#123; console.log(this.index) &#125;&#125;ex: for (var i=0;i&lt;oLi.length;i++)&#123; !function(i)&#123; oLi[i].onclick = function()&#123; console.log(i) &#125; &#125;(i)&#125; 堆栈内存 堆内存： 存储引用数据类型（对象，函数） 栈内存： 提供JS代码执行的环境和存储基本数据类型值 堆内存释放：让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用堆内存，浏览器在空闲时就会把它释放掉） 栈内存释放：普通局部变量和参数使用完以后被垃圾回收机制回收回去，不会存留在内存当中。 eval函数 eval函数用于计算某个字符串得到结果或执行其中的javascript代码 eval只有一个参数 如果传入的参数不是字符串，他直接返回这个参数12ex: eval("2"+"3") //5 eval("alert('hello')") //hello 递归一个过程或函数直接或间接调用自己本身,成为递归过程或递归函数递归的特点1.递归就是在过程或函数里调用自身2.在使用递归从过程中必须有明确的递归结束条件 成为递归出口3.递归算法解题运行效率较低4.递归次数过多容易造成栈溢出 入栈出栈的过程12345678// 斐波那契数列第n项function fib(n)&#123; if(n&lt;=2)&#123; return 1 &#125; return fib(n-1) + fib(n-2)&#125;console.log(fib(5)) callee关键字在函数内部使用，代表当前函数的引用(名字)。作用：降低代码的耦合度。耦合度：一处代码的修改会导致其他代码也要发生改变(耦合度高),在项目里边要开发低耦合度的代码(一处代码修改尽量少地引起其他代码的变化)。12345678910111213141516171819// 未使用callee关键字function jiecheng(n)&#123; if(n == 1) return 1 return n*jiecheng(n-1)&#125;console.log(jiecheng(5)) // 120var jc = jiecheng // 对象赋值 引用传递jiecheng = null // 销毁jiecheng函数对象jc(5) // jiecheng is not a function// 使用callee降低代码的耦合度function jiecheng(n)&#123; if(n == 1) return 1 // 调用本函数（或者f1()）代表当前运行的函数 return n * arguments.callee(n-1)&#125;console.log(jiecheng(5)) // 120var jc = jiecheng // 对象赋值 引用传递jiecheng = null // 销毁jiecheng函数对象console.log(jc(5)) // 120 JS 代码执行顺序(变量提升或预解析) 定义(预解析) 在当前作用域下, 会把带var和function a{}进行提前声明或者定义先去找 var function a(){} 形参数(相当于var)私有变量将var声明的变量名和function函数提升到作用域的最上方var a //声明变量不赋值,变量在正式运行之前,值为undefinedfunction a(){} //函数块,函数在正式运行之前,都是整个函数块参数(相当于var) 如果是函数内则先分析参数 对形参赋值形成私有变量 特殊 当函数名和变量名相同时,只提升函数,忽略变量(JS预解析),函数优先级更高 函数表达式只会提升变量名,不会提升后面的函数(只对等号左边进行变量提升) 在条件判断语句中不管判断语句是否成立，都会发生变量提升，但不会提升函数整体, 只提升函数名称(即声明未定义),提前使用会报错 函数执行形成私有作用域，形参是私有变量，在私有作用域中，先进行形参赋值形成私有变量，在变量提升 块级作用域: 判断体 循环体等大括号都是块级作用域(只对let/const/function起作用, 对var不起作用)1234567891011121314151617181920212223242526272829303132333435// 示例一console.log(a) // undefinedif (false) &#123; var a = 1;&#125;// 示例二console.log(a) // undefinedif (true) &#123; var a = 1;&#125;// 示例三console.log(typeof f) // undefinedf() // f is not a functionif(false)&#123; function f()&#123; console.log(111) &#125;&#125;// 示例四console.log(typeof f) // undefinedf() // f is not a functionif(true)&#123; function f()&#123; console.log(111) &#125;&#125;// 示例五console.log(typeof f) // undefinedif(true)&#123; function f()&#123; console.log(111) &#125;&#125;f() // 111// 示例六console.log(typeof f) // undefinedif(false)&#123; function f()&#123;&#125;&#125;f() // f is not a function// 执行 (逐行解析代码)表达式: = + - * / ++ – ! 参数等 表达式会修改预解析的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 示例一console.log(a) //5 输出function a()&#123;console.log(40)&#125;var a = 10 //1 定义var a 6 赋值 a = 10console.log(a) //7 输出10function a()&#123; //2 定义function a()&#123;&#125; console.log(20)&#125;console.log(a) //8 输出10var a = 30; //3 定义var a但无效 9赋值 a = 30console.log(a) //10 输出30function a()&#123; //4 定义function a()&#123;&#125;覆盖前面 console.log(40)&#125;console.log(a) //11 输出30// 示例二a() //5 执行 function a()&#123;console.log(2)&#125; 输出2var a = function()&#123; //1 定义 var a 6 执行 将匿名函数赋值给a console.log(1)&#125;a() //7 执行 function()&#123;console.log(1)&#125;() 输出1function a()&#123; //2 定义 function a()&#123;&#125; console.log(2)&#125;a() //8 执行 function()&#123;console.log(1)&#125;() 输出1var a = function b()&#123; //3 定义 var a console.log(3) //4 定义 var function b()&#123;&#125;&#125; //9 执行 将函数b赋值给aa() //10 执行 a()相当于b() 输出3// 示例三var a = 1 //1 var a; 3 a = 1;function fn(a)&#123; //2 定义function fn(a)&#123;...&#125; 5 function fn( var a)&#123;....&#125; console.log(a) //6 a = undefiend 函数局部作用域内a a = 2 //7 a = 2 局部a&#125;fn() //4 fn()console.log(a) //8 a = 1 全局// 示例四var a = 1 //1 var a; 3 a = 1;function fn(a)&#123; //2 fn = function fn(a)&#123;...&#125; 5 fn( var a)&#123;....&#125; 6 fn(a = 1)&#123;....&#125; console.log(a) //7 a = 1 函数局部作用域内a a = 2 //8 a = 2 局部a&#125;fn(a) //4 fn()console.log(a) //9 a = 1 全局 JS 作用域与作用域链(es5)作用域就是变量的作用范围 if for没有块级作用域 只有函数能开辟作用域静态作用域：变量或函数作用域与定义时的作用域有关，跟在哪执行时的作用域无关动态作用域：this跟在哪定义时的无关，跟在哪执行有关，只有在执行阶段才能决定变量的作用域在JavaScript中，如果函数的调用者不存在，那么它的调用者将会是全局window对象（或其他环境中的全局变量) 所有的全局变量或对象都是在window对象上定义的， 所有的全局变量和对象都属于window对象1.全局作用域 在代码任何地方都能访问到的对象拥有全局作用域a.最外层函数和在最外层函数外面定义的变量拥有全局作用域(可以在任何地方被改变)b.所有未定义直接赋值的变量自动声明为拥有全局作用域c.所有window对象的内置属性都拥有全局作用域2.局部作用域(函数作用域) 只有在函数内部可以访问到,在局部作用域(函数)外无法访问局部作用域内的对象(函数或变量),所有未定义直接赋值的变量可以作为window的属性,不存在返回undefined,未定义也未赋值的变量寻找不到则直接报错xxx is not defined函数的形参本身就是一个局部变量 相当于function b(var a){}3.作用域链 (函数)域先从自己的作用域找数据变量,找不到再去上级作用域,直到script还没找到则报错script是最大的域,有多个script,从上往下依次执行 函数可作为小的作用域 域内先定义后执行1234567891011121314151617181920// 作用域链var a = 0 //1 定义 var a 3 执行 赋值a=0function fn()&#123; //2 定义 function fn()&#123;...&#125; console.log(a) //7 执行 console.log(a) //undefined var a = 1 //6 定义 var a 8 赋值 a=1 console.log(a) //9 执行 console.log(a) //1&#125;console.log(a) //4 执行 console.log(a) //0fn() //5 执行 fn()console.log(a) //10 执行 console.log(a) //0// 函数作用域: 定义过程中的作用域 而不是调用时的作用域var age = 80function fn1()&#123; console.log(age)&#125;function fn2()&#123; var age = 40 fn1()&#125;fn2() // 80 fn1()定义时作用域 其他 a href=”javascript:;”或a href=”javascript:void(0)” 点A标签的时候,让当前页不跳转。 在同一个网页中,放任意个数的&lt;script&gt;由上往下执行 一般放在&lt;/body&gt;结束之前。原因:先呈现页面,加载DOM树结构,后加载脚本,提高用户体验 基于网站优化 js中允许把 “.” 换成 “[‘’]” !-[-1,] 判断IE IE独有api isIE = document.documentMode]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基础(一)--(数据类型,运算符,语句等)]]></title>
    <url>%2Fjavascript%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[JS 包含三部分 核心ECMASCRIPT DOM BOM JS 注释 单行注释 // 被注释的这一行,它不会被执行 多行注释 /* 注释多行 */注 \n 在js文本中(弹框等)的换行,JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性 JS 三种弹框 alert(“弹出框”) confirm(“提示信息”) 返回值为true或false prompt(“提示信息”,”默认值”) 点击确定返回输入的字符串 JS 输出 document.write() document.writeln()输出之后会加空格,如果在文档已完成加载后执行 document.write，整个HTML页面将被覆盖 consloe.log() 控制台输出信息 console.time(1) code console.timeEnd(1) 用来标记循环耗时 console.table(obj) 将json对象按表格输出 JS 变量 以字母 下划线 $开头 不能由数字开头 不能使用关键字 对大小写敏感(age和AGE是不同的变量)当给变量分配文本值时,应该用双引号或单引号包围这个值。当给变量赋的值是数值时,不要使用引号.如果用引号该值会被作为文本来处理 声明多个变量用逗号隔开(var a,b,c) 声明变量的时候没有给它赋值。只是声明，没有管它，没有给它赋值。var name;alert(name); //会弹出undefined;变量存放在栈里 键盘上的字符,数字,特殊符号放在常量池 对象放在堆里面 局部变量会在函数运行以后被删除 全部变量会在页面关闭后被删除 JS 数据类型 (es6之前) 基本数据类型一 number 数值型 infinity 无穷大数字 10/0 infinity二 string 字符串 必须用引号引起来三 bool 布尔型 true和false 布尔值直接使用 千万不要加上引号四 function 函数五 undefined 未定义 复合数据类型六 object 对象 null 对象{} 数组[] 注意问题 123456null 没有这个对象或无值(空) 通过给一个变量赋 null 值来清除变量的内容undefined 有声明而未赋值的变量null==undefined; //trueisNaN()判断是否是NaN(判断之前先用Number()转换)NaN 不是一个数字 但是它是number数字型NaN 和 NaN 自己不相等 是布尔值false 显式类型转换 1234567891011121314151617181920212223242526272829一 Number() 转换成数值型ex:var a = '110' var b = Number(a) console.log(b) // 110 console.log(typeof b) //numberex:var a = '110px' var b = Number(a) console.log(b) //NaN 不是一个数字 console.log(typeof b) // numberNumber("")--&gt;0 Number(null)--&gt;0 Number([])--&gt;0注:空字符串 空数组和null 进行Number()转换时 返回0 对象 函数 undefiend 使用Number()时 都为NaN 当数组有且只一个元素,而这个元素是数值时 Number()转换成该数值 数组不是一个元素时不管是什么Number()转换都是NaN二 parseInt() 强制取整 parseFloat() 转换成小数 parseInt(b,10) //第二个参数表示进制 对字符串或数组的第一个字符进行判断,不是数字字符将停止转换 除了加号/空格/减号(负数)外的任何非数字都将得到NaN)ex:var a = '100px'; var b = parseInt(a); console.log(b); //100 console.log(typeof b);//number 当数组第一个元素是数字parseInt()或parseFloat()将数组第一个元素转换成数字ex:console.log(Number(['a'])) //NaN console.log(Number([2,'2',2])) //NaN console.log(Number(['2'])) //2 console.log(parseInt(["2",3,4])) //2 console.log(parseInt(['a',2])) //NaN三 转换为布尔值 Boolean(变量) 或 !!变量 隐式类型转换① +(拼接) //100 + &#39;1&#39; =&gt; &#39;1001&#39; 变字符串② - * / % ++ -- // &#39;100&#39;-2 =&gt; 98 变数字③ &gt; &lt; // (var a=&#39;10&#39;)&lt;(var b=4) 转换成布尔值 会用number转换④ 字符串比较大小时 比较第一个字符的ASCII码⑤ !取反 把右边的数据类型转换成布尔值 JS 运算符 算术运算符 + - * / % ++ --++ -- 自增或自减 不支持布尔型 对于字符串自增或自减属于升序或降序a++或a-- 先用(赋值)再加 结果不变 ++a或–a 先加再用(赋值) 结果加1或减1 赋值运算符 = += -= *= /= %=把右边的值赋给左边的变量或常量 比较运算符 &lt; &gt; &lt;= &gt;= == != === !==比较运算符的结果都是一个布尔型恒等于===值和类型都相同 非恒等于!==数值不相等或类型不相同==和!=在比较之前首先让双方的值做隐士类型转换在简单基本比较运算符中 值和引用都要一样 逻辑运算符and或&amp;&amp; 逻辑与 当两边都为true时，才返回true，否则返回falseor或|| 逻辑或 只要有一个为true时，返回true，都为假时才返回falsexor 逻辑异或 当两个操作数一个为真一个为假时，才返回true！ 逻辑非 单一操作数为true，则返回false 位运算符对二进制位从低位到高位对齐后进行计算&amp; 按位与 | 按位或 ^ 按位异或 ~ 按位取反 &lt;&lt; 向左移位 &gt;&gt; 向右移位注: 按位运算不会出现短路 三元运算符(条件运算符)表达式1？表达式2：表达式3如果表达式1为真则执行表达式2，表达式1为假则执行表达式3 1234567891011121314151617181920212223242526一. 在取模%运算符中 正负号取决于被除数的正负ex: var a = 5,b = -2 console.log(a%b) //1ex: var a = -5,b = -2; console.log(a%b) //-1在js中拼接用"+" 从左往右碰到第一个非数值之后就理解为字符串拼接在JS中任何类型的值都可以转换成逻辑布尔值假 ""(空字符串) null undefined false NaN 0为假,其他都为真真 函数 对象 非空字符串 非0的数字 数组 true都为真注:在js中逻辑运算符(短路) 返回的是最早能判断表达式结果的那个值二. 对于&amp;&amp; 如果第一个值是false 则整个表达式都是false 并返回第一个值。如果第一个值是true 则直接返回最后一个值不管真假三. 对于|| 如果第一个值是false 则看后面的条件是否为真,找到真值就将其返回如果到最后也没找到真值，则返回最后一个值。如果第一个值是真就直接返回第一个ex var a = falsevar b = 6var c = truevar d = a || b &amp;&amp; cconsole.log(d) //trueex var a = falsevar b = 6var c = nullvar d = a &amp;&amp; b || cconsole.log(d) //null四. void取消返回值 delete删除对象的属性或数组中的元素删除数组元素时，并没有改变数组的长度，只是留下了一个undefined的值 12345ex: delete obj.a delete obj["a"] delete array[0]var arr = [1, 2]delete arr[1] //trueconsole.log(arr) //[empty, 2]arr.length //2 逗号表达式一般形式是：表达式1，表达式2，表达式3……表达式n逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。 看下面几个例子： 12345x = 8 * 2, x * 4 /*整个表达式的值为64，x的值为16*/(x = 8 * 2, x * 4), x * 2 /*整个表达式的值为128，x的值为16*/x = (z = 5, 5 * 2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/x = z = 5, 5 * 2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/// 逗号表达式用的地方不太多，一般情况是在给循环变量赋初值时才用得到 in运算符in运算符它的左操作符是一个字符串或可以转化为字符串，右操作符是一个对象。如果右侧的对象拥有一个 名为左操作数值的属性名，那么表达式返回true 12345678ex:var point = &#123; x:1, y:1 &#125;"x" in point // true"z" in point // false 对象不存在z属性"toString" in point // true 对象继承了toString方法var data = [ 7,8,9 ]"0" in data // true 数组包含"0"属性1 in data // true 数字转换为字符串3 in data // false 没有索引为3的元素 typeof运算符(es6之前)返回表示操作数类型的字符串 typeof(xx) typeof xx 1234567typeof(undefined) // "undefined"typeof(null) // "object"typeof(1.2) // "number"typeof(NaN) // "number"typeof('字符串') // "string"typeof(function fn()&#123;&#125;) // "function"typeof(&#123;&#125;) // "object" JS 语句 条件控制语句 123456789101112131415161718192021222324252627282930313233343536373839// if语句if (expr(真或假)) &#123; statement&#125;// 只有一条语句时，大括号可以省略if(expr) statement// if...else语句if (expr) &#123; statement&#125; else &#123; statement&#125;// if...elseif语句if (expr1) &#123; statement1&#125; else if (expr2) &#123; statement2&#125; else &#123; statement3&#125;// switch...case语句switch(变量)&#123; case 值1: statement1 break case 值2: statement2 break case 值3: statement3 break default: statement&#125;a. switch(变量) 变量的类型只能是数字或字符串b. case中值的判断必须是 === 类型和数值都得相等c. switch case 适合单个值匹配 elseif 适合判断范围时使用d. break是退出switch使用的,如果需要同时匹配多个值可以使用多个case而不加breake. default无论放在开始还是结束,不会影响程序执行,先执行case 在执行 default 放在末尾可以不加break 放在开头必须加break 循环控制语句 用于遍历对象或数组 1234567891011121314151617181920// while循环语句// 表达式为true时 才执行循环体while(expr)&#123; statement;&#125;// for语句for(expr1;expr2;expr3)&#123; statement;&#125;// expr1变量的初始赋值,expr2为循环条件,expr3为变量递增或递减// 用于已知循环次数多条件循环操作// do...while循环语句// 先执行循环体,在判断表达式,成立再执行循环体do &#123; statement&#125; while(expr)// for...in 循环语句 遍历对象所以可枚举的属性（enumerable）for(var key in json)&#123; console.log(key+'--&gt;'+json[key]);&#125; 跳转控制语句 常用于跳出for循环或foreach循环break语句 break n 指定要跳出几层循环 结束整个循环结构continue语句 continue n 指定要跳出几层循环 只能终止本次循环 继续下一层循环 JS中的保留字123break catch case continue do default delete debugger else falsefunction for finally instanceof in if new null return switchthis typeof true throw try var void with while JS运算符优先级1234567891011121314151617// 优先级 由高到底//运算符 //描述. [] () 字段访问、数组下标、函数调用以及表达式分组++ -- - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建* / % 乘法、除法、取模+ - + 加法、减法、字符串连接&lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位&lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof== != === !== 等于、不等于、严格相等、非严格相等&amp; 按位与^ 按位异或| 按位或&amp;&amp; 逻辑与|| 逻辑或?: 条件= oP= 赋值、运算赋值, 多重求值 JS 定时器1234567891011121314151617// 设置定时器 (目前最小时间14毫秒)1.setInterval //每隔多少秒执行一次 不清除会一直执行下去ex: setInterval(function()&#123; console.log('定时器例子')&#125;, 3000)2.setTimeout //隔多少秒后执行(只执行一次)ex: setTimeout(function()&#123; console.log('定时器例子')&#125;, 3000)// 清除定时器 最好在使用定时器的时候先清除上一次的定时器clearInterval(t) / clearTimeout(t)ex:var num = 0;var t = setInterval(function()&#123; num++ console.log('123') if(num == 2)&#123; clearInterval(t) &#125;&#125;,3000)//问题: 在点击事件中执行多次停不下来 在每次开启时,先清除定时器3.定时器有n个参数 setTimeout(function(num)&#123; console.log(num)&#125;, 1000, 123) //123 JS 小知识 定时器有多个参数, 返回值timer是整数数字 1234var timer = setTimeout(function(num)&#123; console.log(num) // 123&#125;, 1000, 123)console.log(timer) // 61834 利用\进行多行字符串的拼接 123obj.innerHTML='&lt;div&gt;这行&lt;/div&gt;\ &lt;span&gt;文字&lt;/span&gt;\ &lt;p&gt;标签&lt;/p&gt;' console.log(&#39;%c&#39;+带样式得输出,&#39;font-size:50px;color:red&#39;) 可以输出样式,图片等 typeof写法 typeof arr等价于typeof(arr) 还有instanceof和in 嵌套for循环跳出循环 123456789for(var i = 0; i &lt; 5; i++)&#123; a:for(var i = 0; i &lt; 5; i++)&#123; for(var j = 0;j &lt; 1; j++)&#123; for(var j = 0; j &lt; 1; j++)&#123; if(i == 3)&#123; if(i == 3)&#123; break; break a &#125; &#125; console.log(i) console.log(i) //0 1 2 4 //0 1 2 &#125; &#125;&#125; &#125; call(obj) 改变this指向 不写参数 默认指向window obj.getBoundingClientRect() 获取元素上下左右宽高6个值 元素尺寸：对应jQuery中的$(xx).outerWidth()和$(xx).outerHeight()方法，包括padding和border，也就是元素的border-box的尺寸。在原生DOMAPI中对应的是offsetWidth和offsetHeight,所以,有时候也称为元素偏移尺寸。 元素内部尺寸：对应jQuery中的$(xx).innerWidth()和$(xx).innerHeight()方法，表示元素的内部区域尺寸，包括padding但不包括border，也就是元素的padding-box尺寸。在原生的DOM API中对应clientWidth和clientHeight，所以，有时候也称为元素可视尺寸。 元素外部尺寸：对应jQuery中的$(xx).outerWidth(true)和$(xx).outerHeight(true)方法， 表示元素的外部尺寸，不仅包括padding和border，还包括margin，也就是元素的margin-box尺寸。没有相对应的原生的DOMAPI JSON json 是存储和传输数据的格式用于服务器端向网页传递数据 json 英文全称JavaScript Object Notation json 格式仅仅是一个文本,文本可以被任何编程语言读取及作为数据格式传递 json语法规则 123456789101112a.数据为键/值对 "firstName":"John" // 属性名最好加上双引号b.并列数据由逗号分隔 "firstName":"John", "lastName":"Doe"c.大括号保存对象 &#123;"firstName":"John", "lastName":"Doe"&#125;d.方括号保存数组 "employees":[&#123;"firstName":"John", "lastName":"Doe"&#125;]var arr=&#123;"employees":[ &#123;"firstName":"John", "lastName":"Doe"&#125;, &#123;"firstName":"Anna", "lastName":"Smith"&#125;, &#123;"firstName":"Peter", "lastName":"Jones"&#125;]&#125;// JSON取值arr.employees[0].firstName //Johnarr["employees"][0].firstName //John Json遍历for in(不能使用for循环),json是没有长度的,json.length会得到undefined 123456789var json1 =&#123; 'url':['img/1.jpg','img/2.jpg','img/3.jpg','img/4.jpg'], 'text':['这是第一张图片','这是第二张图片','这是第三张图片','这是第四张图片']&#125;for(var attr in json1)&#123; for(var i=0;i&lt;json1[attr].length;i++)&#123; console.log(json1[attr][i]) &#125;&#125; json字符串转换为javascript对象 12345678910// 创建javascript字符串字符传为JSON格式的数据var txt='&#123;"employees":['+ '&#123;"firstName":"John", "lastName":"Doe"&#125;,'+ '&#123;"firstName":"John", "lastName":"Doe"&#125;,'+ '&#123;"firstName":"John", "lastName":"Doe"&#125;]&#125;';// 使用JSON.parse() 将json字符串转换为javascript对象var obj = JSON.parse(txt)// 获取值并输出console.log(obj.employees[1].firstName+"--"+obj.employees[1].lastName)console.log(obj["employees"][2].firstName+"--"+obj["employees"][2].lastName)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[为了适应各种移动端设备，完美呈现现应有的布局效果,各个移动端设备，分辨率大小不一致，网页想铺满整个屏幕，并在各种分辨下等比缩放。常见适配方案如: 固定高度宽度自适应、固定宽度，viewport等比缩放、Rem适配、像素比适配、vw适配、媒体查询等。 单位 px像素 px是固定单位,不会随着视口大的大小而变化 em 相对于当前元素字体大小,当前元素未设置字体大小则继承父级字体大小 默认 1em=16px em作为font-size使用时,相对于父元素字体大小 em作为宽高等使用时 相对于自身字体大小 例如默认 font-size:2em;width:2em; // width为64px rem 相对于根元素(html)字体大小的单位,会随着根元素字体大小的变化而变化,默认1rem为16px vw 和 vh 相对于屏幕(可视窗口宽度) 宽度100vw和高度100vh vmin是指vw和vh中最小的那个,vmax是vw和vh中最大的那个 百分比 动态单位,以当前元素的父元素作为参考进行计算 适配方案 固定高度，宽度自适应（百分比，flex布局）或者响应式高度固定(单位可以是px 百分比 auto) 常用flex布局或百分比宽度 固定宽度，viewport等比缩放设计图的宽度就是网页显示的宽度,动态改变视口的缩放比例,页面宽度写死 12345678910111213// 弊端: 统一宽度之后 无法做响应式,富文本编辑器上传的内容也会被缩放var width = window.screen.width, fixedW = 640, scale = width / fixedW, meta = document.createElement('meta'), mateAttr= &#123; 'name': 'viewport', 'content': 'width=' + fixedW + ',initial-scale=' + scale + ',minimum-scale=' + scale +',maximum-scale=' scale + ',user-scalable=no' &#125;for (var key in metaAttr) &#123; meta[key] = metaAttr[key]&#125;document.head.appendChild(meta) Rem做宽度自适应,窗口为设备宽度根据屏幕的分辨率,动态设置html的文字大小，达到等比缩放的功能 123456789101112131415161718192021222324252627(function(win)&#123; var docEle = win.document.documentElement; var timer = null; var resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; function changeRem()&#123; //获取矩形的宽高上下左右距离 var width = docEle.getBoundingClientRect().width; if(width &gt; 640)&#123; //兼容ipad就去掉 width = 640; &#125; var fontS = width/10; //把设备宽度10等分 docEle.style.fontSize = fontS+'px'; //设置根元素字体大小 &#125; changeRem(); //页面尺寸发生改变的时候在执行changeRem win.addEventListener(resizeEvt,function()&#123; clearTimeout(timer); timer = setTimeout(changeRem,30); &#125;,false); //页面加载的时候,如果是调用缓存的话再执行changeRem win.addEventListener('pageshow',function(e)&#123; if(e.persisted)&#123; //缓存 clearTimeout(timer); timer = setTimeout(changeRem,30); &#125; &#125;,false);&#125;)(window) 像素比适配(rem做宽度,viewport缩放)物理像素(设备像素)--手机屏幕分辨率 独立像素(css像素)--屏幕宽度像素比 =物理像素 / 独立像素 window.devicePixelRatio 12345678910111213141516171819202122232425262728293031var dpr = window.devicePixelRatio;var scale = 1;//检测设备，设置相应的像素比if (!dpr &amp;&amp; !scale) &#123; var isAndroid = window.navigator.appVersion.match(/android/gi); var isIPhone = window.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = window.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; //meta 缩放比例&#125;//动态生成metavar metaEl = document.createElement('meta');metaEl.setAttribute('name', 'viewport');metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');if (document.documentElement.firstElementChild) &#123; document.documentElement.firstElementChild.appendChild(metaEl);&#125; else &#123; var wrap = document.createElement('div'); wrap.appendChild(metaEl); document.write(wrap.innerHTML);&#125; 直接给html设置font-size:13.33333vw 需要给body设置初始字体大小 1234// body&#123; font-size:12px &#125;// 直接使用rem不需要js计算, 只需要在750设计图上得到的尺寸px直接除以100就可以得到rem的值// 假设1rem=50px 则 100vw = 7.5rem = 375px 可以得出 1rem = 13.33333vw// 例如 在设计图中元素宽高为 50px 则可以直接写成 0.5rem 移动端横竖屏切换 window.orientation 竖屏为0 横屏为90或-90 123456789101112131415function set_html_fontsize() &#123; var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0); var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); var width = w &gt; h ? h : w; width = w &gt; 720 ? 720 : w document.getElementsByTagName("html")[0].style.cssText = 'font-size: ' + ~~(width*100000/36)/10000+"px;";&#125;// 监听横竖屏切换window.orientationchange = function()&#123; set_html_fontsize()&#125;;window.onresize = function()&#123; set_html_fontsize()&#125;;set_html_fontsize(); 媒体查询 max-device-width和max-width的区别 123456/* 1、max-device-width是设备整个显示区域的宽度，例如，真实的设备屏幕宽度。2、max-width是目标显示区域的宽度，例如，浏览器宽度。3、如果使用max-device-width，那么在PC浏览器上浏览网页时，缩小或放大浏览器时是不执行CSS的，因为“PC设备”没有变化。但如果使用max-width，缩小或放大浏览器时是执行CSS的，因为“显示区域”即浏览器大小发生了变化。4、如果使用max-device-width，那么当手机由竖变横时，CSS是不执行的，因为“手机宽度”并没有变化。如果使用max-width，那么当手机由竖变横时，CSS是执行的，因为“显示区域”发生了变化。5、通常，面向“移动设备”用户使用max-device-width；面向“PC设备”用户使用max-width。*/ link标签&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (max-width:767px)&quot; href=&quot;phone.css&quot; /&gt;如果屏幕宽度小于767像素(max-width:767px)就加载phone.css文件&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (min-width:768px)&quot; href=&quot;phone.css&quot; /&gt;如果屏幕宽度大于768像素(min-width:768px)就加载pc.css文件 css @media 媒体查询(不同屏幕大小使用不同的样式)1234567891011121314151617181920212223.d1&#123; width:200px; height:600px; background:#000;&#125;/* 超小屏幕 手机&gt; */@media (max-width:768px)&#123; .d1&#123; background:skyblue; &#125;&#125;/* 小屏幕 平板 */@media (min-width:768px) and (max-width:992px)&#123; .d1&#123; background:#999; &#125;&#125;/* 中等屏幕 桌面显示器 */@media (min-width:992px) and (max-width:1200px)&#123; .d1&#123; background:blue; &#125;&#125;/* 大屏幕 大桌面显示器&gt; */@media (min-width:1200px)&#123; .d1&#123; background:pink; &#125;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular1学习]]></title>
    <url>%2Fangular1%2F</url>
    <content type="text"><![CDATA[Angularjs是一个javascript框架,通过&lt;script&gt;标签添加到HTML页面,通过指令扩展了HTML,通过表达式绑定数据到HTML主要是通过ng-directives扩展.AngularJS使得开发现代的单页面应用程序(Single Page Applications)更加容易.Angular更适合复杂的大型项目,通常是企业级的项目. 定义模块作用域通过angular.module(&#39;app&#39;,[])来声明模块 ,第一个参数应用app的名称,第二个参数依赖集合(即使没有也要传入空数组),返回的是一个angular模块对象 控制器controllerangular变量是要定义在一个作用域里面的,controller是专门用来定义作用域的,一个控制器就是一个作用域定义angular.module(&#39;app&#39;,[]).controller(&#39;&#39;,fn)在angular中有一项技术叫参数注入,想使用什么东西就注入什么东西,在angular中的局部作用域叫做$scope,要使用作用域就要将它注入进来,$rootScope是全局作用域 定义变量初始化变量ng-init=&#39;age=1;class=3&#39;,多个变量之间用;隔开ng-model:双向绑定,定义变量名.把元素值(输入框的值)绑定到应用程序变量中ng-bind:绑定变量名,获取该变量的数据,避免渲染页面看到插值符号,把应用程序数据(变量)绑定到HTML视图ng-app:定义angularJS的使用范围定义一个AngularJS应用程序ng-cloak:解决闪烁 显示隐藏ng-show 用来显示元素ng-hide 用来隐藏元素angular中ng-show是通过class设置的,通过!important来提高权重 插值表达式angular,vue插值表达式的语法是一样的,在插值符号中使用,不同之处,angular可以在ng-bind指令中使用插值表达式1234&#123;&#123;表达式&#125;&#125; 将数据绑定HTML与ng-bind相同ng-model是用于表单元素的，支持双向绑定。对普通元素无效；ng-bind用于普通元素，不能用于表单元素，应用程序单向地渲染数据到元素；当ng-bind和&#123;&#123;&#125;&#125;同时使用时，ng-bind绑定的值覆盖该元素的内容。 过滤器angular中在定义过滤器语法 变量|过滤器:参数1:参数2json 将对象转化成json对象 date 将日期格式化currency 将数字转换成一个价格的形式 currency:货币标识符: 保留位数字符串过滤器 uppercase转大写 lowercase转小写 limitTo截取number 将数字转换成科学计数法 千分符,参数表示保留几位小数,会根据最后一位四舍五入orderBy 对集合进行排序 参数1表示排序的字段,是数字按大小排序,是字符串按字符串编码排序.参数2表示升序或倒序,默认是false正序,true倒序. 自定义过滤器通过filter()方法自定义过滤器,多个过滤器用|隔开,前一个过滤器的输出作为后一个过滤器的输入,第一个参数表示过滤器的名称,第二个参数表示工厂函数验证指令1.必填项验证 repuired --&gt; ng-required=&#39;true&#39;2.最大长度与最小长度 maxlength--&gt;ng-maxlength minlength--&gt;ng-minlength3.正则验证 pattern–&gt;ng-pattern=&#39;/\d{11}/&#39;当为表单元素form添加name属性的时候,会根据name在作用域中创建变量子表单元素的name属性会添加到form元素对应的变量内,每个变量都有四个属性$dirty 表示是否输入过 true 输入过$pristine 表示是否输入过 true 没有输入过$invalid 表示是否是不合法 true 不合法$valid 表示是否合法 true 合法表单相关指令ng-disabled 表单是否可以使用ng-checked 是否被选中ng-readonly 是否只读ng-change 事件 在内容发生改变时触发 依赖于ng-model指令ng-submit 表单提交事件 要绑定给form元素 由submit类型元素触发 其他常用指令AngularJS指令是扩展的HTML属性带有前缀ng-***,AngularJS通过指令来扩展HTMLng-href 动态的渲染a标签的href属性值,避免在渲染a标签的时候,href不存在打开错误的页面,在没有添加ng-href之前是不会由a链接的特性的ng-src 动态创建src属性 提高用户体验 否则会请求一张错误的图片地址1注意: ng-href与ng-src指令 都是一个指令,属性值是字符串,要使用插值符号&#123;&#123;&#125;&#125; ng-class 指令 动态绑定类值可以是字符串,变量,对象(属性值是一个布尔值true表示保留这个类，flase表示删除这个类)ng-style 指令 动态创建样式变量–&gt;变量的值是对象 属性名称是css样式名称 属性值是css样式值对象–&gt;属性名称是css样式名称 属性值是css样式值ng-if 模板判断指令 值为true显示 值为false 隐藏angular中ng-if指令控制的元素显示位置是通过注释确定,当我们为一个元素添加一个ng-if指令的时候,会创建一个相应的注释ng-switch 多分支控制模板创建根据case创建了一个ng-switch-when指令,根据default创建了一个ng-switch-default指令,ng-switch通过on属性来添加一个判断的条件ng-repeat 用来循环创建模板的 ng-repeat=&#39;item in items&#39;提供了6个临时变量$index: 索引值从0开始 $first: 是否是第一次循环 $last: 是否是最后一次循环$middle: 除了第一次和最后一次 $odd: 奇数次循环 $even: 偶数次循环后5个指令值都是布尔值ng-include 异步加载模板指令,可以通过异步请求加载一个模板,他的值是js环境,可以使用变量,如果这个指令绑定给具有控制器的元素使用,此时作为控制器内的模板,该控制器中定义的数据可以在该模板中使用 自定义指令第一步 在html中使用这个指令(指令名以-分隔 如my-directive)第二步 在js中通过directive方法来定义自定义指令第一个参数是指令名称 必须是驼峰命名第二个参数是一个函数,指令工厂函数,没有参数,作用域是全局作用域返回值是描述指令的对象template: 自定义指令的模板内容 ,会渲染到自定义指令中templateUrl: 引入外部模板文件replace: 是否替换原来的容器元素(默认false)在angular中一共有四种自定义指令的形式 ECMAE 表示自定义标签元素类型(Element) 如&lt;my-title&gt;&lt;/my-title&gt;(默认)C 表示类类型(Class) 如&lt;div class=&#39;ng-hide&#39;&gt;&lt;/div&gt;(必须设置)M 表示注释类型(comment) 如&lt;!-- directive:my-title --&gt;(必须设置)A 表示属性类型(Attribute) 如&lt;div ng-if=&#39;isShow&#39;&gt;&lt;/div&gt;(默认)不是默认的必须用restrict:&#39;CM&#39;设置 ,四种类型都是大写的,可以组合使用 自定义指令的作用域自定义指令的作用域是通过控制器来定义的,控制器不是定义在元素上,而是定义在返回的对象上叫controller作用域$scope 表示作用域$elemnet 表示获取的自定义指令容器元素的jqlite对象$attrs 自定义指令容器元素属性的服务,驼峰式命名法 属性名称映射关系对象作用域关系自定义指令的作用域是通过scope属性来约束的,可以通过这个属性来定义自定指令的作用域与父作用域的关系对于一个自定义指令,他的内容有两种一种是在指令元素内的另外一种是在指令外的,通过template或者templateUrl来设置的scope 有三个值 默认是falsetrue 子,父作用域是隔离的,两个作用域不会相互覆盖是独立的false 子,父作用域在同一个作用域,子作用域定义变量会覆盖父作用域的变量{} 子,父作用域是隔离的, 但子作用域的数据是父作用域的数据(模板使用)这三个属性可以定义子作用域与父作用域的分离,子作用域是指自定义指令的作用域,父作用域是指外部控制器的作用域scope:true或{}是解决子作用域与父作用域分离的自定义指令修饰符@修饰符是解决在作用域分离的时候,子作用域使用父作用域中数据的问题第一步 在指令容器元素中绑定数据(插值语法)第二步 在scope对象中定义该属性,属性值要使用@修饰符属性名称是子作用域中使用的变量,属性值是绑定的自定义指令元素上的属性名称这种绑定的作用域数据是单向的只能由父作用域传递给子作用域,此时父作用域域子作用域是独立的,子作用域中的数据会被父作用域覆盖=修饰符 是解决在作用域分离的时候,子作用域使用父作用域中数据的问题第一步 在指令容器元素中绑定数据(不能插值语法)第二步 在scope对象中定义该属性,属性值要使用=修饰符属性名称是子作用域中使用的变量,属性值是绑定的自定义指令元素上的属性名称这种绑定的作用域数据是双向绑定的,父作用域的修改会影响到子作用域,子作用域的修改会影响父作用域,此时父作用域域子作用域是独立的,子作用域中的数据会被父作用域覆盖 link方法 指令的编译方法到目前为止,指令只能使用一些数据,渲染模板,替换元素,如果需要指令具备一定的功能,我们需要将指令的实现的业务逻辑定义在link方法中. complie 编译方法link 是编译的一个子过程 compile 是编译的全过程属性值也是函数,函数的返回值就是link方法,compile是从指令获取到指令编译完成全部过程有两个参数,第一个参数表示指令容器元素,第二个参数表示attrs属性对象,作用域是指令描述对象,返回值是link方法]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会使用svn]]></title>
    <url>%2F%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8svn%2F</url>
    <content type="text"><![CDATA[svn全称Subversion，是代码版本管理软件，管理着随时间改变的数据。这些数据放置在一个中央资料档案库 (repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。 许多人会把版本控制系統想像成某种 “时光机器”。 SVN的作用 可以很好地协调一个团队共同开发同一个项目,多人开发同一个项目不会出现代码覆盖情况。 针对一个文件可以创建许多不同版本，并且可以随时查看不同版本的内容。 公司领导可以通过svn查看每个人的工作情况 SVN下载下载地址 SVN服务器端安装注: 双击setup-subversion-1.6.5.msi然后一路next即可 SVN客户端安装注: 双击安装客户端软件(安装完毕重启电脑)：(根据自己操作系统位数64/32做选择安装)客户端安装完毕，鼠标右键有对应的标志(可能需要重启生效)，即代表安装成功 从SVN服务器检出代码在工作目录点击右键,在右键菜单中选择 SVN Checkout点击“OK”按钮后，在弹出的对话框中输入用户名和密码，验证成功后，开始从远程服务器下载到本地工作目录中点击“确定”按钮后，即可获取完成，出现如下下载界面, 下载完成点击OK之后,服务器上所有内容都会下载到本地文件夹下 SVN图标集含义 SVN更新文件更新本地代码与SVN服务器上最新的版本一致，只要在需要更新的文件夹上点击右键或者在文件下空白处点击右键，选择”SVN Update” (获取指定版本中的内容，点击右键执行SVN菜单中的“Update to reversion“)，就可以了。 SVN提交更新(SVN Commit)本地文件修改后，若是需要更新到服务器上，则需要提交（Commit）最新的更新。Commit的作用是将本地最新修改的文件同步到SVN服务端，供其他人来参考或者使用，当然使用之前，要先Update一下，来确保是最新的,在修改文件上击右键，出现菜单，选择“SVN Commit…”，如下：然后填写关于本次更新的日志（log message），这是必填项，否则commit会失败点击ok之后,若没有出现错误则表明刚刚的修改已成功提交 SVN新增文件鼠标选中本地增加的新文件,右键选择“Tortoise SVN”的“Add”项，如下图所示,然后在文件夹右键选择“SVN Commit…”，将新文件上传到svn服务器上（若只上传单个文件，只需点中单个文件上传即可）。新目录内部的文件不能直接提交，必须是先提交目录本身，然后该目录的文件才可以单独进行(add/)commit提交动作。 SVN删除文件删除文件后，在当前文件夹右键选择“SVN Commit…”项进行提交，提交方式同增加文件的提交方式，提交之后才能将新文件从配置库中删除。 撤销更改（Revert）在修改了某些文件后（文件未上传到配置库），需要返回到修改前的状态，则选中文件夹右键选择“Tortoise SVN”的“Revert...”项进行撤销，本地硬盘上的文件将恢复到修改前的内容，修改的内容将被删除。 查看历史文件（Show log）Show log顾名思义是显示日志的作用，主要是显示该文件或者该目录被执行的操作，是被谁修改了，以及修改的时间和日期。鼠标选中文件夹右键选择“Tortoise SVN”的“Show log”项，系统弹出此路径下的所有文件版本信息。 SVN版本回退空白区域右键---&gt;TotoriseSVN----&gt;更新至版本(Update to revision)----&gt;根据日志回退---&gt;显示日志选择要回退到的版本 SVN冲突解决 SVN冲突: 多个程序员对同一文件,同一处代码进行修改,在他们提交的时候会产生冲突 如上图，test_conflict.py文件发生了冲突，并且多出了几个文件，其中.mine是我本地修改了还没提交的版本，.r2文件是上一个版本的文件，.r1是上上个版本的文件。Edit confilicts：修改冲突，可以对冲突的行进行内容选择，后面我们详细说。Mark as resolved：直接标记为已解决，这样会删除.mine、.r1、.r2这些文件，但这只是标记，如果你直接标记为解决，实际上文件还是冲突的，只是状态修复了。Resolve conflict using &#39;theirs&#39;：使用他的提交覆盖我的修改来解决冲突。如果你的修改不需要提交，你可以方便的选择这个。Resolve conflict using &#39;mine&#39;：使用我本地的版本覆盖他的来解决冲突。如果对方提交的代码没什么用，你可以直接使用这个来解决。 SVN 锁机制 对于某些重要的文件不允许别人修改可以对其添加锁，防止其他人修改提交 可以避免多人同时修改某文件产生冲突，添加锁后提交，修改完成提交并解锁 添加锁 svn lock xxx.html 或 选中文件后在右键菜单中选择Get lock 解锁 svn unlock xxx.html 或 选中文件后在右键菜单中选择Realease lock 参考链接SVN使用方法，简易图解图解SVNSVN简易文档]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo其他常用配置]]></title>
    <url>%2Fhexo%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在hexo的使用过程当中,经常会发现或者需要修改一些hexo的配置,以便于更好的使用hexo快速发布文章或者增加更多好用实用的功能,特记录一些在使用过程中添加或修改的功能. 实现实时预览编辑 在最近用hexo写文章的时候,每次修改之后,在hexo s启动后,不能在浏览器实时刷新过来,每次都得手动刷新进行预览,很不方便. 在网上找到如下方案 首先在项目目录下安装 hexo-browsersync 插件 1npm install hexo-browsersync --save 然后运行 hexo s 看到如下内容说明启动成功 12345678910// 其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了.$ hexo s[BS] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.191.1:3001 --------------------------------------INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 注: 但是不知道是不是版本的问题一直没有成功, 后来打开http://localhost:3001,在页面中引入了一个js文件,重启之后便成功了12修改的文件路径 \hexo\themes\next\layout\_scripts\vendors.swig在头部添加js &lt;script src='http://localhost:3000/browser-sync/browser-sync-client.js?v=2.24.6'&gt;&lt;/script&gt; 避免hexo中对 {{}} 的解析1234// hexo中使用&#123;&#123;&#125;&#125;或&#123;％％&#125;包装的内容默认会被解析 在代码块中不会被解析// 只要将单行代码中的大括号包含在raw标签中就可以避免被解析// 语法`&#123;% raw %&#125;&#123;&#123;&#125;&#125;&#123;% endraw %&#125;`实现模型中的数据渲染// 渲染后 ---&gt; 语法&#123;&#123;&#125;&#125;实现模型中的数据渲染 hexo的next主题分页设置 显示更多的分页数量打开 ./themes/next/layout/_partials/pagination.swig 文件，修改 mid_size 字段： 1234567891011&#123;% if page.prev or page.next %&#125; &lt;nav class="pagination"&gt; &#123;&#123; paginator(&#123; prev_text: '&lt;i class="fa fa-angle-left"&gt;&lt;/i&gt;', next_text: '&lt;i class="fa fa-angle-right"&gt;&lt;/i&gt;', mid_size: 10 &#125;) &#125;&#125; &lt;/nav&gt;&#123;% endif %&#125; 每页显示文章数量 123456// 根目录 _config.yml 文件下# 默认分页显示的数量index_generator: path: '' per_page: 10 order_by: -date]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式]]></title>
    <url>%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[js正则表达式，js中的象形文字。正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，可用于文本搜索和文本替换。 JS 正则表达式(RegExp对象) 正则定义 正则只是针对字符串 默认区分大小写1.patt=new Regexp(&#39;规则&#39;,&#39;g&#39;) 规则必须是字符串 如有\或特殊字符需用\转义2.patt=/\d{6-10}/g 简写 不要写引号 需要传参的时候必须用new 正则的六个方法1./\d+/.test(字符串) 检索字符串中的指定值 返回true或false2./\d+/.exec(字符串) 检索字符串中的指定值 返回值是被找到的值 没有返回null3.str.replace(/\d+/,&quot;hello&quot;或callback) 查找并替换 匹配成功返回替换后的字符串4.str.match(/\d+/) 正则去匹配字符串 匹配成功返回匹配成功的数组 不成功返回null5.str.search(/\d+/) 正则去匹配字符串 匹配成功返回位置,失败返回-16.str.split(/-/) 用于使用字符串或正则表达式分隔字符串正则默认都是匹配成功就结束了,不会继续匹配,只匹配一次 要全部匹配则要加修饰符g(全局匹配)， 1234567891011121314151617181920212223242526// new RegExp("e") 声明正则var str = "The best things is sleeping"var patt1 = new RegExp("e")console.log(patt1.test(str)) //trueconsole.log(patt1.exec(str)) //["e", index: 2, input: "The best...", groups: undefined]var patt = /e/console.log(str.search(patt)) //2console.log(str.match(patt)) //["e", index: 2, input: "The best...", groups: undefined]console.log(str.replace(patt, 'E')) //ThE best things is sleeping// 使用 /\d&#123;2&#125;/ 声明正则var str = '我日西安水电费贱贵大傻逼阿达'var patt = /我日|贱|大傻逼/gvar result = str.replace(patt,function(s)&#123; var res = '' for(var i=0;i&lt;s.length;i++)&#123; res += '*' &#125; return res&#125;)console.log(result) //**西安水电费*贵***阿达// 去掉前后空格var re1 = /^\s+|\s$/gconsole.log(' as da '.replace(re1, '')) //as da// 使用split分日期隔字符串let dateStr = '2020-09-08 16:18:22'dateStr.split(/-|:|\s/) // ['2020', '09', '08', '16', '18', '22'] 修饰符i 不区分大小写字母的匹配g 执行全局匹配m 执行多行匹配 放在/后面 /e/gi 表达式[abc] 用于查找方括号之间的任意一个(字符类) /[abc]/[^abc] 用于查找任何不在方括号之间的字符 /[^abc]/| 或、左右两侧有一个匹配到就可以 a|b() 匹配子项或分组操作[a-z] 范围 [a-z][\b] 退格直接量注: 匹配子项 把正则的整体叫做(母亲) 然后把左边第一个小括号里面的正则 叫做第一个子项(第一个孩子) 第二个小括号就是 第二个子项str.replace(patt,function(母亲,第一个子项,第二个子项){} 元字符 转义字符. 查找除换行符之外任意字符\w 用于查找字符 字符包括[A-Za-z0-9_] \W 非字符 [^A-Za-z0-9_]\d 用于查找数字 0-9 \D 非数字\s 用于查找空白(空格 tab 回车 换行) \S 非空白\b 独立的部分(单词边界)(起始 结束 空格) \B 非独立的部分(非单词边界)\1或\2.. 重复的第一个子项,第二个子项 量词(频率匹配) 匹配不确定的次数 大括号{} 量词+ 一次或多次* 任意次? 零次或一次{n} 必须是n次{n,} 至少n次{n,m} 最少n次,最多m次$ 匹配以某字符结尾^ 匹配以某字符开始 格式化字符串：正则表达式中的每个()，都是一个子表达式,每个子表达式都会自动获得一个从1开始的编号替换时，可用$n，指代本次匹配中第n个子表达式的对应内容 123456var date = '20190108180155'var reg = /(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)/date.replace(reg, '$1年$2月$3日 $4:$5:$6') // "2019年01月08日 18:01:55"date.replace(reg, '$1-$2-$3 $4:$5:$6') // "2019-01-08 18:01:55"// 隐藏手机号中间4位'18855558888'.replace(/(\d&#123;3&#125;)\d*(\d&#123;4&#125;)/g, '$1****$2') // 188****8888 捕获分组和后向引用当一个模式的全部或者部分内容由一对括号分组时，它就对内容进行捕获并临时存储与内存中。可以通过后向引用重用捕获的内容。\1或者$1 这里\1或$1引用的是第一个捕获的分组，而\2或$2引用的是第二个捕获的分组，以此类推。 \1 \2 \3……\9 \10 —匹配模式中的后向引用 $1 $2 $3……$9 $10 —替换模式中的组的引用 捕获分组和非捕获分组() 表示捕获分组, ()会把每个分组里的匹配的值保存起来, 使用$n(n是一个数字, 表示第n个捕获组的内容)(?:) 表示非捕获分组, 和捕获分组唯一的区别在于, 非捕获分组匹配的值不会保存起来 前向声明(前瞻)或反前向声明(负前瞻) 12345678/(\w)\1+/g; //(\w) 变成子项 \1和前面子项相同 +多个//exp1(?=exp2) 前向声明 查找exp2前面的exp1//exp1(?!exp2) 反前向声明 查找后面不是exp2的exp1var str = 'abasad';var re = /a(?=s)/g; // 查找 s 前面的 avar re1 = /a(?!s)/g; // 查找后面不是 s 的 aconsole.log(str.replace(re,'*')); //ab*sad 将 s 前面的 a 替换成 *console.log(str.replace(re1,'*')); //*bas*d 将 a 后面不是 s 的 a 替换成 * 后顾或负后顾 1234567// (?&lt;=exp2)exp1 查找exp2后面的exp1// (?&lt;!exp2)exp1 查找前面不是exp2的exp1var str = 'abasad';var re = /(?&lt;=s)a/g; // 查找 s 后面的 avar re1 = /(?&lt;!s)a/g; // 查找前面不是 s 的 aconsole.log(str.replace(re,'*')); // abas*d 将 s 后面的 a 替换成 *console.log(str.replace(re1,'*')); // *b*sad 将前面不是 s 的 a 替换成 * 正则表达式 \1 \2 反向引用之类的问题 1234567// \0 \1 \2 都要和正则表达式集合()一起使用// \1表示重复正则第一个圆括号内匹配到的内容// \2表示重复正则第二个圆括号内匹配到的内容var str = 'abdcbcdadcabce'console.log(str.split('').sort().join('').match(/([a-z])\1*/g)) // ["aaa", "bbb", "cccc", "ddd", "e"]var RegExp1 = /^(123)(456)\1$/ // 123456123var RegExp1 = /^(123)(456)\2$/ // 123456456 其他 使用正则test()第一次是true,第二次是false正则表达式 lastIndex 属性用于规定下次匹配的起始位置。RegExp.exec( ) 和 RegExp.test( ) 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。lastIndex 属性是可读可写的， 需配合修饰符g使用123456789101112131415161718var s1 = "1R1MRLPRL";var reg = /mrlp/ig;console.log(reg.test(s1)) // trueconsole.log(reg.lastIndex) // 7console.log(reg.test(s1)) // false// 方法一 直接去掉 gvar s1 = "1R1MRLPRL"var reg = /mrlp/iconsole.log(reg.test(s1)) // trueconsole.log(reg.lastIndex) // 0console.log(reg.test(s1)) // true// 方法二 当必须使用g时 将lastIndex重置为0var s1 = "1R1MRLPRL"var reg = /mrlp/igconsole.log(reg.test(s1)) // trueconsole.log(reg.lastIndex) // 7reg.lastIndex = 0console.log(reg.test(s1)) // true 贪婪匹配与惰性匹配 默认贪婪匹配贪婪匹配是先看整个字符串是否匹配，如果不匹配，它会去掉字符串的最后一个字符，并再次尝试。如果还不匹配，那么再去掉当前最后一个，直到发现匹配或不剩任何字符 1234var str = 'aaa&lt;div style="font-color:red;"&gt;123456&lt;/div&gt;bbb'str.match(/&lt;.+&gt;/); // &lt;div style="font-color:red;"&gt;123456&lt;/div&gt;var str2 = 'abcdabceba'str.match(/.+b/) // abcdabceb ?惰性匹配 尽可能少的匹配惰性匹配是从左侧第一个字符开始向右匹配, 先看第一个字符是不是一个匹配, 如果不匹配就加入下一个字符再尝式匹配, 直到发现匹配 1234var str = 'aaa&lt;div style="font-color:red;"&gt;123456&lt;/div&gt;bbb'str.match(/&lt;.+?&gt;/) // &lt;div style="font-color:red;"&gt;var str2 = 'abcdabceba'str.match(/.+?b/) // ab]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用操作]]></title>
    <url>%2Fnpm%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[npm 是Node.js的包管理工具（package manager）,npm 由三个独立的部分组成: 网站(开发者查找包,设置参数以及管理npm的主要途径) 注册表(保存每个包（package）的信息) 命令行工具(通过命令行或终端运行。开发者通过 CLI 与 npm 打交道)。 npm install 安装包 或 npm i 包名npm install jquery或 npm install jquery@2.2.4 安装指定版本 本地项目包npm i &lt;包&gt;安装在当前项目目录（node_modules）下，根据模块访问规则，当前项目以及子项目可访问。一般用于安装项目独立使用的包。 全局包npm i -g &lt;包&gt;安装在 npm 指定的全局目录下，通过全局模块访问机制可以在全局范围内访问。一般用于安装工具性质的包。 一次性安装多个模块 npm i gulp-pug gulp-debug gulp-sassnpm ls 查看已经安装的依赖包 npm update 更新包注： jquery@2.2.4 执行 npm update之后,只会更新jquery@2.x.x以后的小版本，不会直接更新到3.x.x版本, 如需下载3.x版本重新安装需要的版本即可 更新单个全局包 npm update &lt;name&gt; -g 更新项目生产环境依赖包 npm update &lt;name&gt; -save 更新项目开发环境依赖包 npm update &lt;name&gt; -save-dev 更新依赖包 检测依赖包 npm i npm-check-updates -g 查看哪些依赖包需要更新 ncu 更新package.json文件中的依赖包为最新版本 安装最新的依赖包 npm i npm outdate 查看安装包有没有版本更新 npm run 查看 package.json中有哪些 npm script命令npm uninstall &lt;包名&gt; 或 npm uni &lt;包名&gt; 卸载包npm uninstall rimraf -g 或 npm uni rimraf -g 查看包信息 npm view vue 或 npm v vue 查看安装包所有信息 123npm v vuevue@2.6.14 | MIT | deps: none | versions: 360beta: 3.2.0-beta.8 csp: 1.0.28-csp latest: 2.6.14 next: 3.2.21 npm v vue version 查看包最新版本 12npm v vue version2.6.14 npm view &lt;packagename&gt; versions 或 npm view &lt;packagename&gt; versions --json 查看指定包的所有版本 1234567891011121314npm view rimraf versions[ '1.0.0', '1.0.1', '1.0.2', '1.0.4', '1.0.5', '1.0.6', '1.0.7', '1.0.8', '1.0.9', '2.0.0', '2.0.1', '2.0.2', '2.0.3', '2.1.0', '2.1.1', '2.1.2', '2.1.3', '2.1.4', '2.2.0', '2.2.1', '2.2.2', '2.2.3', '2.2.4', '2.2.5', '2.2.6', '2.2.8', '2.3.0', '2.3.1', '2.3.2', '2.3.3', '2.3.4', '2.4.0', '2.4.1', '2.4.2', '2.4.3', '2.4.4', '2.4.5', '2.5.0', '2.5.1', '2.5.2', '2.5.3', '2.5.4', '2.6.0', '2.6.1', '2.6.2', '2.6.3', '2.7.0', '2.7.1', '3.0.0', '3.0.1', '3.0.2'] npm root -g 查看全局包的安装路径npm init 快速创建 package.json 需要手动选择配置npm init –yes或-y 直接跳过参数问答环节，快速生成package.jsonnpm config list 查看npm基础配置npm config get prefix 获取全局安装的默认目录npm config set key value 设置npm镜像和node-sass npm config set registry https://registry.npm.taobao.org npm config set SASS_BINARY_SITE https://npm.taobao.org/mirrors/node-sass/ npm i -g与 npm i -S 或 npm i -D 区别 npm i xxx -g 全局安装 npm i xxx -S 是 npm i xxx --save的简写 安装的插件会在package.json文件中写入到dependencies对象里面去,dependencies需要发布到生产环境.(生产依赖/项目依赖包) 开发时使用，上线还需要 npm i xxx -D 是 npm i xxx --save-dev的简写 安装的插件会在package.json文件中写入到devDependencies对象里面去,devDependencies里面的插件只用于开发环境不用于生产环境.(开发依赖) 开发时需要，线上不需要 发布自己的模块包 package.json文件 项目（模块、包）说明配置文件，该文件描述了当前包的信息，只有拥有package.json文件的项目才可以被发布自动创建package.json npm init / npm init --yes 1234567package.jsonname：包名称，必填version：版本，必填，格式 x.x.xmain : 包的入口主文件scripts：自定义脚本，通过 npm run 脚本名称即可执行脚本定义的命令dependencies：生产环境下需要使用的依赖包devDependencies：只做开发环境（测试环境）下使用的依赖包 注册 npmjs.org 账号 登录 npm adduser / npm login 要切回到npm源 发布 npm publish 查看发布的npm包 快速删除node_modules依赖或文件 npm i rimraf -g 全局安装 rimraf 模块 rimraf node_modules cmd中 set 可以查看所有的环境变量npm script 串行 或者 并行{&quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown&quot;}这也是让多个 npm script 串行的典型用例，实现方式也比较简单，只需要用 &amp;&amp; 符号把多条 npm script 按先后顺序串起来即可{&quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; wait&quot;}需要把子命令的运行从串行改成并行，实现方式更简单，把连接多条命令的 &amp;&amp; 符号替换成 &amp; 即可。{&quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown&quot;} 或 {&quot;test&quot;: &quot;npm-run-all lint:*&quot;}我们可以使用 npm-run-all 实现更轻量和简洁的多命令运行。需要安装 npm i npm-run-all -D 使用–ignore-scripts解决npm/yarn安装依赖失败问题12345678npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! plantomjs-prebuilt@2.1.14 install: `node ./build.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the plantomjs-prebuilt@2.1.14 install script.// 可以加上参数 --ignore-scripts 再进行安装npm i plantomjs-prebuilt@2.1.14 --ignore-scripts]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON数据格式]]></title>
    <url>%2FJSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[json 英文全称 JavaScript Object Notation,json 是存储和传输数据的格式用于服务器端向网页传递数据,json格式仅仅是一个文本,文本可以被任何编程语言读取及作为数据格式传递. JSON语法规则 映射用冒号(‘:’) &quot;firstName&quot;: &quot;John&quot; 并列数据之间由逗号(‘,’)分隔 &quot;firstName&quot;: &quot;John&quot;,&quot;lastName&quot;: &quot;Doe&quot; 映射的集合(对象)用大括号 {&quot;firstName&quot;: &quot;John&quot;,&quot;lastName&quot;: &quot;Doe&quot;} 并列数据集合(数组)用方括号(‘[]’) &quot;employees&quot;:[{&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;}] 12345var arr=&#123;"employees":[ &#123;"firstName":"John", "lastName":"Doe"&#125;, &#123;"firstName":"Anna", "lastName":"Smith"&#125;, &#123;"firstName":"Peter", "lastName":"Jones"&#125;]&#125; 注: 并列的数据之间要用逗号隔开,最后一个”名/值”之后不能加逗号,英文,中文要用双引号括起来 不能使用单引号,也不能没有 JSON的优点 数据格式比较简单，易于读写，格式都是压缩的，占用带宽小 支持多种语言，包括C,C#,C++,JAVA,Javascript，Perl，python，PHP等服务器端的语言，便于服务器端的解析 传输速度特别快 常见的四种数据格式 XML 标准的通用标记语言 JSON 存储和传输数据的格式 Serialize 将变量序列化，返回有变量类型和结构的字符串 Array() 基本数据类型 不能用于数据的传输和交替 JSON和Serialize的区别 相同点 都是把其他数据类型转换成一个可以传输的字符串 都是结构性数据 资源类型都不可以转换为JSON或Serialize 不同点 Serialize 序列化后的数据格式 保存数据原有类型 JSON 数据格式比Serialize序列化之后的数据更简单 适用场景 JSON 适合数据量大，不要求保留原有数据类型下使用 Serialize 适合存储带有加密方式的数据，防止数据被中途截取 在PHP中常用的JSON函数 Json_encode() 将数组，对象转换成JSON格式 (对象只能转换公有属性),只能接收utf8编码格式,其他格式则返回false或null Json_decode() 将JSON字符串转换成对象 Json_decode($obj,true) 将JSON字符串转换成数组 在JS中常用的JSON函数 $.getJSON() 获得JSON数据 eval() 解析json格式字符串为json对象 不安全eval() 函数的参数是一个字符串，作用是直接执行其中的JavaScript代码。在低版本的浏览器不得不使用这种方式eval() 的参数，在字符串两旁加了括号，这是必须的，否则会报错。使其变成表达式 JSON.parse() 解析json格式字符串为json对象 (IE8以下不兼容)(对象)可以有第二个参数，是一个函数。此函数有两个参数：name 和 value，分别代表名称和值 JSON.stringify() 将对象(json对象或数组)转换成json字符串可以有三个参数 第三个表示格式化输出JSON.stringify(myObject,null,4)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo Next代码块复制]]></title>
    <url>%2Fhexo%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在NexT主题的v6.3版本里已经加入了代码复制这个功能，所以如果你刚开始使用NexT，直接升级主题，并在主题配置文件中打开代码复制的开关就好了,如果版本低于6.3你可以参考以下方式自行添加. 下载clipboard.min.js下载地址 clipboard.min.js保存文件到如下目录 .\themes\next\source\js\src 使用方法在 .\themes\next\source\js\src 目录下新建 clipboard-use.js,文件内容如下: 12345678910111213141516171819202122/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight").wrap($('&lt;div class="highlight-wrap"&gt;&lt;/div&gt;')); $('.highlight-wrap').prepend(copyHtml); var clipboard = new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); // 成功提示 clipboard.on('success', function(e) &#123; toastPlug('复制成功!', 2000) &#125;); &#125; initCopyCode();&#125;(window, document); 设置复制按钮样式在 .\themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536/*代码块复制按钮*/.highlight-wrap&#123; position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; outline: none; color: #333; -webkit-transition: opacity .5s ease-in-out; -o-transition: opacity .5s ease-in-out; transition: opacity .5s ease-in-out; padding: 2px 6px; position: absolute; right: 7px; top: 7px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight-wrap:hover .btn-copy&#123; opacity: 1;&#125; 引入文件在 .\themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（）之前添加）：123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 注: 一开始找的添加复制按钮代码,有一点小bug,如果代码块部分内容超出有横向滑动,复制按钮copy就会跟着移动,而不能固定在右上角,此时只需要将复制按钮和highlight部分外层包裹一个元素设置position:relative即可 参考链接打造个性超赞博客 Hexo+NexT+GitHub Pages 的超深度优化轻松入门 HexoHexo博客中加入代码块复制功能]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发常见问题]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在前端日常开发中,经常会遇到各种各样的兼容性问题,或者各种各样的奇葩问题,无论是css,html还是js都会有一些小的问题所在,特记录下平常可能遇到的问题和一些解决方法. p标签解析问题 当一个元素指定多个 class 时，class 的优先级与指定顺序无关，而是和 class 的定义顺序有关。后声明的优先级高。123456&lt;style&gt;.red &#123; color: red &#125;.blue &#123; color: blue &#125;&lt;/style&gt;&lt;div class="red blue"&gt;这是什么颜色&lt;/div&gt; // blue&lt;div class="blue red"&gt;这是什么颜色&lt;/div&gt; // blue 隐藏元素的方法异同 Display：non e；隐藏盒子，并且不占位置 Overflow：hidden；隐藏超出部分 Visibility：hidden；隐藏盒子，占位置 Opacity：0；隐藏盒子，占位置 Position-left/top：-999em；隐藏盒子，测试不占位置 BFC(Block formatting context) 块级格式化上下文 哪些元素或属性会生成BFC 123451. 根元素 html2. float属性不为none 浮动框3. position为absolute或fixed4. display为inline-block, table-cell, table-caption, flex, inline-flex 非块框的块容器5. overflow不为visible的块框 BFC 作用 解决清除浮动问题 BFC包含浮动元素,BFC会根据子元素的情况自动适应高度 解决margin 合并问题 BFC可以阻止元素被浮动元素覆盖(文字环绕) 屏蔽右键菜单 &lt;body oncontextmenu=&quot;return false&quot; ondragstart=&quot;return false&quot; onselectstart=&quot;return false&quot;&gt;&lt;/body&gt; 常用正则整理12345678910var reg = &#123; chinese : /^[\u4e00-\u9fa5]&#123;1,6&#125;$/g, trim : /^\s+|\s$/g, email : /\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;/g, url: /[a-zA-Z]+:\/\/[^\s]*/g, qq : /[1-9][0-9]&#123;4,9&#125;/g, postcode: /[1-9]\d&#123;5&#125;/g, card : /[1-9]\d&#123;14&#125;|[1-9]\d&#123;17&#125;|[1-9]\d&#123;16&#125;x/g, tel : /^1[3456789]\d&#123;9&#125;$/g&#125; calc使用问题123456789在使用calc(100% - 20px + 5px*2)).elm &#123; width: calc(expression);&#125;// 使用“+”、“-”、“*” 和 “/”四则运算；//可以使用百分比、px、em、rem等单位；可以混合使用各种单位进行计算；表达式中有“+”和“-”时，其前后必须要有空格，如"widht: calc(12%+5em)"这种没有空格的写法是错误的；表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。 a标签点击事件与href中代码执行顺序问题12345678&lt;ul onclick="javascript:console.log('ul-click')"&gt; &lt;li onclick="javascript:console.log('li-click')"&gt; &lt;a id="test" href="javascript:console.log('a-href')"&gt;a点击事件&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;test.onclick = function()&#123; console.log('a-click') &#125;//a-click li-click ul-click a-href//先执行a标签的onclick事件,然后冒泡执行父级的click事件，在执行自身的href里的js代码 some() 不会对空数组进行检测，不会改变原始数组。对于空数组上的任何条件，此方法返回false。 every() 不会对空数组进行检测，不会改变原始数组。对于空数组上的任何条件，此方法返回true。 switch case 的条件判断是全等于即=== test.toFixed(2) 返回值类型的是字符串 test必须是数字类型 不能是字符串 ios不支持2018-09-09这类时间格式 字体颜色渐变 ios 存在标签兼容问题 android正常 移动端 border-radius 小于6像素 设置正园时 变形问题 采用transform:scale(0.5)进行缩放 缩放会占位 采用margin负值调整即可 禁用的input框在ios和android下表现不一致 1234567input:disabled, input[disabled]&#123; background-color : #fff; //修改默认灰色样式 color: #666; -webkit-text-fill-color:#666; //字体颜色安卓与IOS适配 -webkit-opacity:1; // 不透明级别安卓与IOS适配 opacity:1; // ios默认的不透明级别为0.3&#125; URL 全称是 Uniform Resource Locator ，中文译名为“统一资源定位符”，用于完整地描述 Internet 上某一处资源的地址。一般称之为 URL 地址，或者 Web 地址，俗称“网址” URI 全称是 Uniform Resource Identifier ，中文译名为“统一资源标识符”，用来唯一地标识一个资源。而URL是一种具体的URI，我们可以简单地 URI和URL 看作同一个东西 var val = tel.replace(/[^\d]/g, &#39;&#39;) //只能输入数字 scrollTop在有些机型获取不是整数的问题 数值为小数 解决CSS position:fixed 抖动问题, fixed元素设置 -webkit-transform: translateZ(0); QQ 分享问题 不是QQ好友 分享有问题 页面上的图片没有找到 使用类似404图片 12345678&lt;script type="text/javascript"&gt;function nofind()&#123; var img=event.srcElement; img.src="images/logoError.png"; img.onerror = null; // 控制不要一直跳动&#125;&lt;/script&gt;&lt;img src="images/logo.png" onerror="nofind()" /&gt; 美化表单元素 禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰select::-ms-expand { display:none; } 禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰input[type=radio]::-ms-check,input[type=checkbox]::-ms-check { display:none; } 禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear { display:none; } 内容多左对齐, 内容少居中对齐 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 方法一 利用 inline-block 重新创造一个新的盒模型环境 */ div&#123; background: red;text-align: center; &#125; p&#123; display:inline-block;text-align: left; &#125; /* 方法二 table */ div&#123; background: red; &#125; p &#123; margin: 0 auto;display: table; &#125; /* 方法三 fit-content */ div&#123; background: red; &#125; p &#123; margin: 0 auto;width:fit-content;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;内容多左对齐, 内容少居中对齐内容多左对齐, 内容少居中对齐内容多左对齐, 内容少居中对齐内容多左对齐, 内容少对齐内容多左对齐, 内容少对齐内容多左对齐, 内容少对齐内容多左对齐, 内容少居中对齐内容多左对齐, 内容少居中对齐内容多左对齐, 内容少居中对齐&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现多行文本上下居中 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 方法一 */ .method1&#123; height: 100px; width: 200px; font-size: 12px; border: 1px solid #000; line-height: 100px; &#125; .method1 span&#123; display: inline-block; line-height: normal; vertical-align: middle; &#125; /* 方法二 */ .method2&#123; height: 100px; width: 200px; font-size: 12px; border: 1px solid #000; vertical-align: middle; display: table-cell; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法一 利用 inline-block 重新创造一个新的盒模型环境 --&gt; &lt;div class="method1"&gt; &lt;span&gt;多行文本居中多行文本居中多行文本居中多行文本居中多多行&lt;/span&gt; &lt;/div&gt; &lt;!-- 方法二 采用 display: table-cell --&gt; &lt;div class="method2"&gt; 多行文本居中多行文本居中多行文本居中多行文本居中多多行 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Doctype含义? Doctype声明不属于HTML标签,它是一条指令,告诉浏览器编写页面所使用的的HTML或XHTML版本 img的alt与title有何异同？ strong与em的异同？ alt(alt text):为图片加载失败无法正常显示时用来指定替换文字 title(tool tip):为元素提供额外说明信息,鼠标移入时显示 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点 行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？ 块级元素(block)特性：总是独占一行 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制 内联元素(inline)特性：和相邻的内联元素在同一行 宽度(width)、高度(height)、上下内边距和上下外边距无效 行内块(inline-block): 拥有内在尺寸，可设置高宽，但不会自动换行 如&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt; rgba()和opacity的透明效果有什么不同？ opacity作用于元素，以及元素内的所有内容的透明度， rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！） display:none与visibility:hidden的区别是什么？ display: 隐藏对应的元素但不保留该元素原来的空间。 visibility: 隐藏对应的元素但保留元素原来的空间。 哪些css属性可以继承？ 可继承：font系列 line-height text-align text-indent color list-style cursor visibility等 不可继承：border padding margin width height link和@import的区别是?A. Link属于HTML标签,而@import是css提供的B. 页面被加载时,link会同时被加载,而@import会等到引用的它的css文件加载完再加载C. Import只在IE以上才能识别,而link是html标签,无兼容性问题D. Link方式样式的权重高于@import 什么是CSS Hack?123456789101112131415// 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack.test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */&#125;// 3、选择符Hack* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */ CSS样式的优先级? !important &gt; 内联样式 &gt; id &gt; class &gt; 标签 重排与重绘 重绘: 当在页面上修改了一些不需要改变定位的样式的时候(比如background-color),浏览器只会将新的样式重新绘制给元素 重排: 当页面上的改变影响了文档内容,结构或者元素定位时,就会发生重排(或称重新布局).重排通常由以下改变触发:1)Dom操作(元素增,删,改或者改变元素顺序)2)内容的改变,包括Form表单中文字的变化3)计算或改变css属性4)增加或删除一个样式表5)浏览器窗口的操作(改变大小,滚动窗口) 常见浏览器的内核 IE: trident内核 Firefox：gecko内核 Safari:webkit内核 Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核 Chrome:Blink(基于webkit，Google与Opera Software共同开发) 对前端工程师这个职位你是怎么样理解的?a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好b. 参与项目，快速高质量完成实现效果图，精确到1px；c. 与团队成员，UI设计，产品经理的沟通；d. 做好的页面结构，页面重构和用户体验；e. 处理hack，兼容、写出优美的代码格式；f. 针对服务器的优化、拥抱最新前端技术。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向详解]]></title>
    <url>%2Fthis%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（在非严格模式情况下）, 如果函数的调用者不存在，那么它的调用者将会是全局window对象 1. 全局环境中1console.log(this) // window 2. 事件处理函数DOM 事件处理函数1234567box.onclick = function () &#123; // 事件处理函数中的this指向触发该事件的元素 console.log(this); // div (function()&#123; // 函数自调用 this指向window console.log(this) // window &#125;)()&#125; 内联事件处理函数1234&lt;!--当代码被内联处理函数调用时，它的this指向所在的DOM元素(即div) --&gt;&lt;div id="box" onclick="console.log(this)"&gt;div&lt;/div&gt;&lt;!--当代码被包括在函数内部或自执行函数内时指向window --&gt;&lt;div id="box" onclick="(function()&#123; console.log( this ) &#125;) ()"&gt;div&lt;/div&gt; 3. 函数内部 函数直接执行 非严格模式下 this默认指向全局对象window12345function test () &#123; console.log(this)&#125;test() // windowwindow.test() // window 严格模式下 this为undefined123456function test () &#123; "use strict" // 开启严格模式 console.log(this)&#125;test() // undefiendwindow.test() // window 自执行函数(自调用函数表达式)，this默认指向window 123456789101112131415161718!function()&#123; console.log(this + ' !') //window !&#125;();(function()&#123; console.log(this + ' ()') //window ()&#125;)();-function()&#123; console.log(this + ' -') //window -&#125;();+function()&#123; console.log(this + ' +') //window +&#125;();~function()&#123; console.log(this + ' ~') //window ~&#125;();(function()&#123; console.log(this + ' ()') //window ()&#125;()); call bind apply 改变函数体内部this指向apply call 都会使该函数立即执行，bind不会立即执行，而是返回一个新函数 call 函数.call(obj,arg1,arg2) 会直接调用该函数且第一个参数就是函数执行时的this,后面的参数可有多个 12345function test (m, n) &#123; console.log(this, m, n);&#125;test(2, 3) // window 2 3test.call(&#123;name: 'bob'&#125;, 2, 3) // &#123;name: 'bob'&#125; 2 3 apply 函数.apply(obj,[arg1,arg2]) 会直接调用该函数且第一个参数是函数执行的this,后面是一个数组,执行时会将数组变成参数列表 1234function test (m, n) &#123; console.log(this, m, n);&#125;test.apply(&#123;name: 'bob'&#125;, [2, 3]) // &#123;name: 'bob'&#125; 2 3 借助call apply 去使用Math 或 Array 的方法案例 123console.log(Math.max.apply(null, [2, 9, 5])); // 9//console.log(document.getElementsByTagName("*").slice()); // 报错，不能直接使用sliceconsole.log(Array.prototype.slice.call(document.getElementsByTagName("*"))) // 正确用法 对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样 bind 函数.bind(obj) 创建一个新函数，并不会立即调用，但只能绑定一次 1234567function test () &#123; console.log(this)&#125;var fn = test.bind(&#123;name: 'bob'&#125;)fn() // &#123;name: 'bob'&#125;var fun = fn.bind(&#123;name: 'tom'&#125;)fun() // &#123;name: 'bob'&#125; 箭头函数 =&gt; 与定义时环境上下文中this一致 ，不能用bind,call,apply修改其内部指向，没有arguments对象 1234var fn = () =&gt; &#123; console.log(this); //此时定义时上下文中的this即window&#125;fn() // window 1234567891011box.onclick = function () &#123; //setTimeout setInterval 延时函数内部函数的this指向window setTimeout(function()&#123; console.log(this) // window //this.style.backgroundColor = "red"; 报错 &#125;, 2000) setTimeout(() =&gt; &#123; console.log(this) // div this.style.backgroundColor = "red"; &#125;, 1000)&#125; apply、call、bind比较1234// apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；// apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；// apply 、 call 、bind 三者都可以利用后续参数传参；// bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 4. 对象内部 函数作为对象的方法调用 12345678// 作为对象的方法调用 this指向调用该函数的对象var obj = &#123; a: 1, fn: function ()&#123; console.log(this.a) &#125;&#125;obj.fn() // 1 1234567891011121314var a = 1var obj = &#123; a: 2, // 作为对象方法的箭头函数this指向全局window对象 fn1: () =&gt; &#123; console.log('arrow',this.a) &#125;, // 作为对象方法的普通函数this指向调用它的对象 fn2: function () &#123; console.log('fun',this.a) &#125;&#125;obj.fn1() // arrow 1obj.fn2() // fun 2 多层嵌套的对象 this 就近绑定 1234567891011121314151617var a = 1var obj = &#123; a: 2, b: &#123; a: 3, fn1: function () &#123; console.log(this.a) &#125;, fn2: () =&gt; &#123; console.log(this.a) &#125; &#125;&#125;obj.b.fn1() // 3obj.b.fn2() // 1var temp = obj.b.fn1;temp() // 1 函数直接调用this默认指向window 函数作为返回值使用 12345678910111213141516171819202122var a = 1var obj = &#123; a: 2, fn1: function () &#123; return function () &#123; console.log(this.a) &#125; &#125;, fn2: function () &#123; return () =&gt; &#123; console.log(this.a) &#125; &#125;&#125;obj.fn1()() // 1// obj.fn1() 执行返回 function () &#123; console.log(this.a) &#125;// obj.fn1()() 相当于 (function () &#123; console.log(this.a) &#125;)()// fn() 直接执行 this即windowobj.fn2()() // 2// obj.fn2() 执行返回 function () &#123; console.log(this.a) &#125;// obj.fn2()() 相当于 (() =&gt; &#123; console.log(this.a) &#125;)()// (() =&gt; &#123;&#125;)() this指向上下文中的this即obj 函数或方法被赋值于变量时 this指向这个变量的拥有者 1234567891011var tew = '111'var it = &#123; tew: '222', getTew() &#123; console.log(this.tew) &#125;&#125;it.getTew() // 222fn1 = it.getTewconsole.log(fn1) // getTew() &#123; console.log(this.tew) &#125;fn1() // 111 5. 构造函数中12345678910function Person () &#123; console.log(this) // this指向实例化出来的对象 this.name = "bob"&#125;Person() // windowvar p = new Person(); // Person &#123;name: "tew"&#125;console.log(p) // Person &#123;name: "bob"&#125;p.name = 'tew'console.log(p) // Person &#123;name: "tew"&#125;console.log(p.name) // tew 6. 原型链中12345678910111213141516// 原型链中的this指向调用它的对象// 构造函数function Person (name) &#123; this.name = name // this指向调用该函数的对象&#125;// 原型扩展绑定 showName方法Person.prototype.showName = function () &#123; console.log(this.name)&#125;// 实例化对象var p = new Person('bob')// 实例化对象的__proto__ 指向其构造函数的prototypeconsole.log(p.__proto__ === Person.prototype); // trueconsole.log(p.__proto__); // showName() &#123;&#125;console.log(Person.prototype); // showName() &#123;&#125;p.showName() // bob]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js调试命令]]></title>
    <url>%2FJs%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Console对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的。Console 对象可以在任何全局对象中访问，如 Window。它被浏览器定义为 Window.Console，也可被简单的 Console 调用。最常用的方法就是 console.log() 就是在控制台输出内容。console 对象还有除了 log 之外的其他方法。注意：因为 Console 对象提供对浏览器控制台的接入 ，所以在不同浏览器中的支持以及表现方法可能不太一样，但是调试内容只有开发者会看，所以保证在开发环境用这些方法就可以。 分类输出 不同类别信息的输出。 1234console.log('文字信息')console.info('提示信息')console.warn('警告信息')console.error('错误信息') 表格输出 使用 console.table()可以将传入的对象，或数组以表格形式输出。适合排列整齐的元素。还可以只获取指定字段的数据. 123456789var Obj = &#123; Obj1: &#123; a: 'aaa', b: 'bbb', c: 'ccc'&#125;, Obj2: &#123; a: 'aaa', b: 'bbb', c: 'ccc'&#125;, Obj3: &#123; a: 'aaa', b: 'bbb', c: 'ccc'&#125;, Obj4: &#123; a: 'aaa', b: 'bbb', c: 'ccc'&#125;&#125;console.table(Obj)var Arr = [['aa', 'bb', 'cc'], ['dd', 'ee', 'ff'], ['gg', 'hh', 'ii']]console.table(Arr) 查看对象 使用 Console.dir()显示一个对象的所有属性和方法。 在 Chrome 中 Console.dir()和 Console.log()效果相同。 12345678var CodeDeer = &#123; name: '张三', blog: 'www.google.com'&#125;console.log('console.dir(CodeDeer)')console.dir(CodeDeer)console.log('console.log(CodeDeer)')console.log(CodeDeer) 计次输出 使用 Console.count()输出内容和被调用的次数。 123for (var i = 0; i &lt; 3; i++) &#123; console.count('运行次数：')&#125; 计时功能 使用 Console.time()和 Console.timeEnd()包裹需要计时的代码片段，输出运行这段代码消耗的时间。 Console.time(&#39;登录用时&#39;)中的参数作为计时器的标识，具有唯一性。 Console.timeEnd(&#39;登录用时&#39;)中的参数来结束此标识的计时器，并以毫秒为单位返回运行时间。 最多同时运行 10000 个计时器。 1234// console.time(参数标识) 必须和 console.timeEnd(参数) 一致console.time('Chrome中循环1000次的时间')for (var i = 0; i &lt; 1000; i++) &#123;&#125;console.timeEnd('Chrome中循环1000次的时间') Console.log() 最后再来介绍一下强大的 Console.log()，这个方法有很多的用法（其他输出方法的用法，如error()等，可以参照log()使用）。提示输出 可以再输出的对象、变量前加上提示信息，增加辨识度。 12var ans = 12345console.log('这是临时变量ans的值：', ans) debugger 调试 js 代码时 可以在需要调试的地方打断点，然后在浏览器中打开在运行到这一段的代码时会在打断点的地方停止，在 Chrome 中可以按 F10 继续下一步，然后在 开发者工具–&gt;Sources 中可以看到具体内容，也可以用 鼠标 放到某个 变量上 看具体值。使用debugger检查页面hover后出现的弹窗，鼠标移入后在console控制台输入debugger然后回车,页面就卡住了就可以愉快的进行检查元素了1234567891011121314151617let nums1 = [4, 9, 5]let nums2 = [9, 4, 9, 8, 4]const solution2 = (arr1, arr2) =&gt; &#123; let result = [] for (let item of arr1) &#123; debugger if (arr2.includes(item)) &#123; debugger result.push(item) &#125; &#125; return [...new Set(result)]&#125;console.log('solution2', solution2(nums1, nums2))]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass入门]]></title>
    <url>%2Fsass%2F</url>
    <content type="text"><![CDATA[Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。它允许你使用变量、嵌套规则、mixins、导入等众多功能，并且完全兼容 CSS 语法。Sass 有助于保持大型样式表结构良好，同时也让你能够快速开始小型项目，特别是在搭配Compass样式库一同使用时。 sass安装sass安装请参考sass官网进行操作 sass安装 sass注释 // 以//开始的注释,不会被编译到生成的css文件中 /**/ 以/**/包裹的注释会被编译到生成的css文件中 sass变量 sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样），如果值后面加上!default则表示默认值 普通变量 定义之后可以在全局范围内使用 1234$fontSize: 12px;body&#123; font-size: $fontSize &#125;// 编译后body&#123; font-size: 12px; &#125; 特殊变量 变量作为属性名或选择器或url中等必须要以#{$varibles}形式使用 12345678$borderDirection:top !default;.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;// 编译后.border-top &#123; border-top: 1px solid #ccc;&#125; sass嵌套 所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性。在选择器嵌套中，可以使用&amp;表示父元素选择器 12345678910111213141516171819202122232425#top_nav&#123; background-color:#333; li&#123; float:left; &#125; a&#123; display: block; color: #fff; &amp;:hover&#123; color:#ddd; &#125; &#125;&#125;// 编译后#top_nav &#123; background-color: #333;&#125;#top_nav li &#123; float: left;&#125;#top_nav a &#123; display: block; color: #fff;&#125;#top_nav a:hover &#123; color: #ddd;&#125; @at-root sass3.3.0中新增的功能，用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。` 12345678910111213.parent-2 &#123; color:#f00; @at-root .child &#123; width:200px; &#125;&#125;// 编译后.parent-2 &#123; color: #f00;&#125;.child &#123; width: 200px;&#125; sass 混合mixin sass中使用@mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的@mixin通过@include来调用。 12345678910111213141516171819@mixin opacity($opacity:50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125;.opacity&#123; @include opacity; //参数使用默认值&#125;.opacity-80&#123; @include opacity(80); //传递参数&#125;// 编译后.opacity &#123; opacity: 0.5; filter: alpha(opacity=50);&#125;.opacity-80 &#123; opacity: 0.8; filter: alpha(opacity=80);&#125; sass 继承 sass中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词@extend，后面紧跟需要继承的选择器。 1234567891011121314.open&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; @extend .open; border-width: 2px;&#125;// 编译后.open, .speaker &#123; border: 4px solid #ff9aa9;&#125;.speaker &#123; border-width: 2px;&#125; Sass 运算 sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。 注 : +号还可以做运算，还可做字符串连接, 需要给运算的外面添加一个小括号()才能执行除法运算12345678910$width: 200px;.box &#123; width: ($width / 2); height: $width + 200px;&#125;// 编译后.box &#123; width: 100px; height: 400px;&#125; Sass 循环 @for循环 指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者 @for $var from &lt;start&gt; to &lt;end&gt; 使用to时包含&lt;start&gt;的值但不包含&lt;end&gt;的值.&lt;start&gt;和&lt;end&gt;必须是整数 1234567891011121314151617181920212223242526272829.clauses-title &#123; @for $i from 1 through 7 &#123; &amp;.billEntries0#&#123;$i&#125; &#123; background-image: url('../assets/billEntries0#&#123;$i&#125;.png') &#125; &#125;&#125;// 编译后.clauses-title.billEntries01 &#123; background-image: url(../img/billEntries01.png)&#125;.clauses-title.billEntries02 &#123; background-image: url(../img/billEntries02.png)&#125;.clauses-title.billEntries03 &#123; background-image: url(../img/billEntries03.png)&#125;.clauses-title.billEntries04 &#123; background-image: url(../img/billEntries04.png)&#125;.clauses-title.billEntries05 &#123; background-image: url(../img/billEntries05.png)&#125;.clauses-title.billEntries06 &#123; background-image: url(../img/billEntries06.png)&#125;.clauses-title.billEntries07 &#123; background-image: url(../img/billEntries07.png)&#125; @each循环 指令的格式是 $var in &lt;list&gt;, $var可以是任何变量名，比如 $length而 &lt;list&gt;是一连串的值，也可以是值列表 1234567891011121314151617181920212223242526272829303132333435363738394041$primary: #409EFF;$success: #67C23A;$warning: #E6A23C;$danger: #F56C6C;$info: #909399;.lea-button &#123; @each $type,$color in (primary:$primary, success:$success, info:$info, warning:$warning,danger:$danger) &#123; &amp;-#&#123;$type&#125;&#123; background:#&#123;$color&#125;; border:1px solid #&#123;$color&#125;; color:#fff; &#125; &#125;&#125;// 编译后.lea-button-primary &#123; background: #409EFF; border: 1px solid #409EFF; color: #fff;&#125;.lea-button-success &#123; background: #67C23A; border: 1px solid #67C23A; color: #fff;&#125;.lea-button-info &#123; background: #909399; border: 1px solid #909399; color: #fff;&#125;.lea-button-warning &#123; background: #E6A23C; border: 1px solid #E6A23C; color: #fff;&#125;.lea-button-danger &#123; background: #F56C6C; border: 1px solid #F56C6C; color: #fff;&#125; Sass 条件判断12345678910111213141516171819202122232425262728@mixin triangle($dir, $width, $color) &#123; width: 0; height: 0; border-style: solid; border-color: transparent; border-width: $width; @if($dir==UP)&#123; border-bottom-color: $color; &#125; @else if($dir==DOWN)&#123; border-top-color: $color; &#125; @else if($dir==LEFT)&#123; border-right-color: $color; &#125; @else if($dir==RIGHT)&#123; border-left-color: $color; &#125;&#125;.test&#123; @include triangle(LEFT, 10px, #999);&#125;// 编译后.test &#123; width: 0; height: 0; border-style: solid; border-color: transparent; border-width: 10px; border-right-color: #999;&#125; 更多sass使用方式,可以参考以下链接 学习链接Sass 中文网 或 Sass 中文网]]></content>
      <categories>
        <category>CSS预处理器</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less入门]]></title>
    <url>%2Fless%2F</url>
    <content type="text"><![CDATA[Less是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为 CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。 lesscss可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。 less简介常用的css预处理语言：Sass/Scss Less Stylusless中文网 编译环境或者在浏览器端使用 安装node.js(必须) 使用开发工具visual studio code 安装插件 1:easy less 2:easy sass 3:view in browser 使用koala(国人开发的全平台的LESS编译工具) 在浏览器中使用(需要注意的是link标签一定要在less.js之前引入，并且link标签的rel属性要设置为stylesheet/less) 123&lt;!-- 浏览器端使用 --&gt;&lt;link rel="stylesheet/less" type="text/css" href="styles.less" /&gt;&lt;script src="less.js" type="text/javascript"&gt;&lt;/script&gt; 使用规则less注释 // 以//开始的注释,不会被编译到生成的css文件中 /**/ 以/**/包裹的注释会被编译到生成的css文件中 ~值 避免编译 123#main&#123; width: ~'calc(300px - 30px)' &#125;// 编译后#main&#123; width: calc(300px - 30px) &#125; less变量(variables) 普通变量以@开头 定义: @base: #333 使用: .box{color: @base} 作为选择器或属性名或URL 需要加(@{变量}) 12345678@images: "/flow/images";@selector: box;@width: width;@&#123;selector&#125; &#123; color: #444; @&#123;width&#125;:900px; background: url("@&#123;images&#125;/white-sand.png");&#125; 混合(mixins) 普通的混合(混合会输出到样式中) 123456789101112131415.bordered&#123; border-top:dotted 1px black;&#125;#menu a&#123; color:#111; .bordered;&#125;// 编译结果.bordered &#123; border-top: dotted 1px black;&#125;#menu a &#123; color: #111; border-top: dotted 1px black;&#125; 不带输出的混合(后面加上()混合不会输出到样式中) 123456789101112.bordered()&#123; border-top:dotted 1px black;&#125;#menu a&#123; color:#111; .bordered;&#125;// 编译后#menu a &#123; color: #111; border-top: dotted 1px black;&#125; 带参数的混合,可以有默认值 1234567891011121314151617181920212223/* 多个参数推荐使用分号分隔，参数顺序可以调换但必须加加名称来引用, 有默认值时可以不用传值 */.mixin(@color: black; @margin: 10px; @padding: 20px) &#123; color: @color; margin: @margin; padding: @padding;&#125;.class1 &#123; .mixin(@margin: 20px; @color: #33acfe);&#125;.class2 &#123; .mixin(#efca44; @padding: 40px);&#125;// 编译后.class1 &#123; color: #33acfe; margin: 20px; padding: 20px;&#125;.class2 &#123; color: #efca44; margin: 10px; padding: 40px;&#125; !important在mixin调用之后使用关键字将其继承的所有属性标记为!important 123456789101112.foo (@bg: #f5f5f5, @color: #900) &#123; background: @bg; color: @color;&#125;.important &#123; .foo() !important;&#125;// 编译后.important &#123; background: #f5f5f5 !important; color: #900 !important;&#125; 嵌套规则嵌套规则模仿了html的结构，使得css代码更加清晰明了 &amp;表示当前选择器的所有父选择器 1234567891011121314151617181920212223242526// less写法#header&#123; color:black; .navigation&#123; font-size:12px; &#125; .logo&#123; width:300px; &amp;:hover&#123; color: red &#125; &#125;&#125;// 编译后#header&#123; color:black;&#125;#header .navigation&#123; font-size:12px;&#125;#header .logo&#123; width:300px;&#125;#header .logo:hover&#123; color: red&#125; 运算任何数值，颜色和变量都可以进行运算，less会自动推断数值的单位，所以不必每个值都加上单位，运算符与值之间必须以空格分开 1234567891011121314@width: 450px;div&#123; width: @width + 450; p&#123; width: @width * 2 - 100 &#125;&#125;// 编译后div &#123; width: 900px;&#125;div p &#123; width: 800px;&#125; 合并属性“+”逗号分隔所合并的属性值，“+_”空格分隔所合并的属性值 12345678910111213141516171819202122232425/* + 逗号分隔所合并的属性值 */.mixin() &#123; box-shadow+: inset 0 0 10px #555;&#125;.myclass &#123; .mixin(); box-shadow+: 0 0 20px black;&#125;// 编译后.myclass &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black;&#125;/* +_ 空格分隔所合并的属性值 */.mixin() &#123; transform+_: scale(2);&#125;.myclass &#123; .mixin(); transform+_: rotate(15deg);&#125;// 编译后.myclass &#123; transform: scale(2) rotate(15deg);&#125; 条件判断less中通过when给混合添加限定条件,只有条件满足才会执行混合中的代码,可以使用(&gt; &lt; &gt;= &lt;= =) 逻辑运算符等1234567891011121314151617181920212223242526272829// , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行.size(@width,@height) when(@width=100px) , (@height=100px)&#123; width: @width; height: @height;&#125;// and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行.size2(@width,@height) when(@width=100px) and (@height=100px)&#123; width: @width; height: @height;&#125;.div1&#123; .size(100px, 50px); background: red;&#125;.div2&#123; .size2(100px, 100px); background: red;&#125;// 编译后.div1 &#123; width: 100px; height: 50px; background: red;&#125;.div2 &#123; width: 100px; height: 100px; background: red;&#125; 更多less使用方式,可以参考以下链接 学习链接Less 中文网快速入门 | Less.js 中文文档]]></content>
      <categories>
        <category>CSS预处理器</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 系统环境配置要使用Hexo,需要安装Nodejs以及Git 安装Node.js下载Node.js 安装Git下载Git 安装Hexo12345npm install hexo-cli -ghexo init blognpm installhexo g 或 hexo generatehexo s 或 hexo server hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 部署本地博客 在任意盘下创建自己的博客文件夹（我是d:\blog） 鼠标右键 blog，选择 Git Bash Here。 如果没有安装 Git，就不会有这个选项。 Git Bash 打开之后，所在的位置就是 blog 这个文件夹的位置（/d/blog） 输入 hexo init 将 blog 文件夹初始化成一个博客文件夹 输入 npm install 安装依赖包。 输入 hexo g 生成（generate）待发布网页。 输入 hexo s 将生成的网页放在了本地服务器（server）。 浏览器里输入 http://localhost:4000/ 。 就可以看到刚才的成果了。 发表文章 输入 hexo new “My-First-Post” 或者 在D:\blog\source_posts 路径下，新建 My-First-Post.md 的文件。 因为生成的文章文件基本都在这里. 重新输入 hexo g 重新生成静态文件 输入 hexo s 启动本地服务器 浏览器里输入 http://localhost:4000/查看新建的文章 Github Pages设置GitHub Pages 本用于介绍托管在GitHub的项目,每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 注册 Github 账号，然后在 Github 中创建一个以username.github.io结尾的 Repository，其中username是你名字。 然后就可以在浏览器中通过https://username.github.io 直接访问你的网页了。 部署线上现在我们已经有了本地的Hexo的博客文件和Gitpage，现在只需要将文件部署上去便可以通过网页访问了。其部署的操作也非常简单 1.获取Repository的链接 登录github，进入刚才我们建立Gitpage的Repository 点击Clone or download，复制链接 2. 修改blog的配置文件 打开blog文件夹中的_config.yml（不要用记事本） 找到#Deployment,填入以下内容： 1234deploy: type: git repository: https://github.com/Ryanluoxu/ryanluoxu.github.io.git branch: master 3. 部署 回到git bash 输入npm install hexo-deployer-git –save 输入 hexo d 得到 INFO Deploy done: git 即为部署成功 然后就可以在浏览器中通过https://username.github.io 看部署的效果了。在配置文件里可以修改网站的名字等一些东西，具体可以参考官方文档Hexo配置，主要就是修改Site里面的一些描述。 更多next主题优化功能,可以参考以下链接 参考链接最全Hexo+Next搭建博客教程简明Github Pages与Hexo教程手把手教你使用Hexo + Github Pages搭建个人独立博客在Github上面搭建一个自己域名的Hexo博客hexo的next主题个性化教程：打造炫酷网站Gitpage + Hexo搭建个人博客基于hexo搭建个人免费博客——从零开始打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[label与input关联问题]]></title>
    <url>%2Flabel%E4%B8%8Einput%E5%85%B3%E8%81%94%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点击事件在label标签执行2次,监听的是label和input的上层元素click事件.label和input关联（for显示关联或者input在label下隐式关联）, 点击label的时候，事件冒泡一次，同时会触发关联的input的click事件，导致事件再次冒泡. 解决方式 不用label关联input 如果为了语义化或者用户体验必须使用label标签可以采用如下解决方式: a 阻止默认行为 b 判断事件源对象的标签名为INPUT，如果为LABEL(必须大写)则返回 c 采用时间戳 方法一 阻止默认行为123456789101112&lt;div id="test1"&gt; &lt;label&gt;隐时关联 &lt;input type="radio" name="fruit" &gt; &lt;/label&gt;&lt;/div&gt;&lt;script&gt;test1.onclick = function (ev)&#123; // 方法一 阻止默认行为 ev.preventDefault(); console.log(this.id)&#125;&lt;/script&gt; 方法二 判断事件源对象12345678910111213&lt;div id="test2"&gt; &lt;label for='xian'&gt;显示关联&lt;/label&gt; &lt;input type="radio" name="fruit" id="xian"&gt;&lt;/div&gt;&lt;script&gt;test2.onclick = function (ev)&#123; //方法2 在关联的情况下使用 目标对象的标签名判断 if(ev.target.tagName == 'LABEL')&#123; return; &#125; console.log(this.id);&#125;&lt;/script&gt; 方法三 采用时间戳123456789101112131415&lt;div id="test3"&gt; &lt;label for='xian'&gt;显示关联&lt;/label&gt; &lt;input type="radio" name="fruit" id="xian"&gt;&lt;/div&gt;&lt;script&gt;var temp = 0;test3.onclick = function(ev)&#123; //方法3 采用时间戳 var now = new Date(); if(now - temp &lt; 100)&#123; console.log(this.id) &#125; temp = now;&#125;&lt;/script&gt; 方法四 不关联label和input12345678910&lt;!-- 方法四 将label和input不关联 --&gt;&lt;div id="test4"&gt; &lt;label&gt;不关联&lt;/label&gt; &lt;input type="radio" name="fruit" &gt;&lt;/div&gt;&lt;script&gt;test4.onclick = function(ev)&#123; console.log(this.id)&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3学习]]></title>
    <url>%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3 是 CSS 的升级版本，这套新标准提供了更加丰富且实用的规范，如：盒子模型box-sizing、过渡transition、动画animation、2D或3D变换transform、阴影box-shadow、背景和边框、文字特效text-shadow、多栏布局、弹性布局flex、栅格布局grid、渐变gradient、媒体查询等等. CSS3 选择器 基本选择器* 通用选择器 找到所有的元素&gt; 选择直接子元素 选择到元素的直接后代子元素+ 相邻兄弟选择器 选择到紧随目标后第一个元素~ 普通兄弟选择器 选择到紧随其后的所有兄弟元素 伪元素选择器 ::first-line 匹配文本块的首行 ::first-letter 匹配文本块的首字母 伪类选择器 :before 在元素的内容前面添加内容(行内元素) :after 在元素的内容后面添加内容 结构选择器:nth-child 选择指定索引处的子元素:nth-child(n) 父元素下的第几个子元素(n从一开始):nth-child(odd) 奇数子元素(同nth-child(2n-1)):nth-child(even) 偶数子元素(同nth-child(2n)):nth-child(an+b) 套用公式:nth-last-child(n) 倒数第n个子元素:nth-of-type(n) 父元素下的第n个指定类型的子元素:nth-last-of-type(n) 父元素下的倒数第n个指定内型的子元素:first-child 选择父元素下的第一个子元素:last-child 选择父元素下的最后一个子元素:only-child 选择父元素下唯一的子元素:only-of-type 选择父元素下指定类型的唯一子元素:root 选择文档的根目录,返回html 属性选择器E[attr] 只指定属性名,没确定任何值E[attr=&quot;value&quot;] 指定属性名,并指定其对应的属性值E[attr~=&quot;value&quot;] 指定属性名,属性值是词列表且以空格隔开E[attr ^=&quot;v&quot;] 指定属性名, 属性值以v开头E[attr $=&quot;v&quot;] 指定属性名,属性值以v结束E[attr *=&quot;v&quot;] 指定属性名,属性值中包含了vE[attr |=&quot;v&quot;] 指定属性名,属性值以v-开头或v开头 伪类选择器 UI伪类选择器(表单):enabled 选择启用状态元素:disabled 选择不可用状态元素:checked 选择被选中的input元素（单选按钮或复选框）:default 选择有默认值得元素(button默认值为submit):valid、invalid 根据输入验证选择有效或无效的input元素:in-range、out-of-range 选择指定范围之内或者之外受限的元素:repuired、optional 根据是否允许:required属性选择input元素 动态伪类选择器:link 未访问的链接元素:visited 已访问的链接的元素:hover 鼠标悬停其上的元素:ative 鼠标长按时触发的事件:focus 当前获取焦点的元素 其他伪类选择器:not(选择器) 对括号内选择器的选择取反:lang(目标语言) 基于lang全局属性的元素:target 锚点片段标识符指向的元素:empty 选择内容为空的元素::placeholder 伪元素用于控制表单输入框占位符的外观 默认为灰色::selection 鼠标光标选中元素内容IE9+、Opera、Google Chrome 以及 Safari 中支持 ::selection 选择器。 Firefox 支持替代的 ::-moz-selection。只能向 ::selection 选择器应用少量CSS 属性：color、background、cursor 以及 outline。 CSS3文本属性 单行省略 123white-space:nowrap 控制文本(禁止)不换行text-overflow:ellipsis 当文本溢出时显示省略号overflow:hidden; 溢出隐藏 文本阴影text-shadow:x,y,blur,color 文本阴影x 横向偏移 y 纵向偏移 blur 模糊距离 color 阴影颜色 其他新增文本属性word-wrap:break-word 内容将在边界内换行-webkit-text-fill-color:文字填充颜色 chrome内核支持-webkit-text-stroke:2px 厚度 blue颜色 chrome内核支持 CSS3新增颜色 HSLA模式 hsla(h,s,l,a)H: Hue(色调) 0或360代表红色 60代表黄色 120 代表绿色 180代表青色 240代表蓝色 取值范围0~360S: Saturation(饱和度) 取值为:0.0%-100.0%L: Lightness(亮度) 取值为:0.0%-100.0%A: alpha 透明度 取值为 0~1之间 RGBA模式 rgba(r,g,b,a)r red 红色 0-255g green 绿色 0-255b blue 蓝色 0-255a alpha 透明 0-1 CSS3新增边框属性 border-image 边框背景图片border-image-source:url() 图片的路径border-image-slice:number(边框宽度) 图片的分割方式border-image-width:图片的宽度(width)border-image-outset:3 图片向外扩展的数值border-image-repeat:repeat图片重复 stretch 拉伸方式来填充边框背景图 repeat 平铺方式来填充边框背景图 round 平铺方式来填充边框背景图.图片会根据边框的尺寸动态调整图片的大小直至正好可以铺满整个边框 space 平铺方式来填充边框背景图.图片会根据边框的尺寸动态调整图片之间的间距直至正好可以铺满整个边框 border-radius 边框圆角border-radius：50% 八个值都为50% (半径)border-radius：50% 40% 左上角和右下角为50% 右上角和左下角40%border-radius：50% 40% 30% 左上角50% 右上角和左下角40% 右下角30%border-radius：50% 40% 30% 20% 左上角50% 右上角40% 右下角30% 左下角20% CSS3盒模型弹性盒模型 display:box 或 display:inline-box box-orient: 定义盒模型的布局方向 horizontal 水平显示(默认值) vertical 垂直方向 box-direction: 定义盒子内部元素的排列顺序 normal 正序(默认) reverse 反序 box-ordinal-group:n 设置元素的具体位置 box-pack: 对盒子水平方向富裕的空间进行管理 start 所有子元素在盒子左侧显示，富裕空间在右侧 end 所有子元素在盒子右侧显示，富裕空间在左侧 center 所有子元素居中 justify 富余空间在子元素之间平均分布 box-align: 在垂直方向上对元素的位置进行管理 start 所有子元素在居顶 end 所有子元素在居底 center 所有子元素居中 resize 自由缩放(要配合overflow:auto 一块使用) both 水平垂直都可以缩放 horizontal 只有水平方向可以缩放 vertical 只有垂直方向可以缩放 box-flex 在子元素中定义盒子的弹性空间 仅chorme内核的浏览器有效子元素的宽=父盒子的宽/所有子素的box-flex属性值的和*子元素的box-flex属性值 flex盒模型 display:flex 或 display:index-flex设置给父元素盒子的属性: 控制子元素的显示方式Flex 布局教程：语法篇 flex-direction: 决定子元素显示的方向 默认为row row: 从左向右排列(默认值) row-reverse: 从右往左排列 column: 从上往下排列 column-reverse: 从下往上排列 justify-content 定义子项在水平方向的对齐方式 flex-start: 元素在开始位置 富裕空间占据另一侧(默认) flex-end: 富裕空间在开始位置,元素占据另一侧 center: 元素居中 富裕空间平分左右两侧 space-between: 富裕空间在每个元素之间平均分配 space-around: 富裕空间在每个元素两侧平均分 align-items 定义子项在竖直方向上的如何对齐 flex-start: 元素在开始位置 富裕空间在另一侧 flex-end: 富裕空间在开始位置 元素占据另一侧 center: 元素居中 富裕空间 平分左右两侧(垂直居中) stretch: 未设高度或为auto,将占满容器的高度或宽度(默认) baseline: 项目的第一行文字的基线对齐 flex-wrap: 如果一行排列不下,如何换行 nowrap: 不换行 默认 wrap: 换行显示 wrap-reverse: 反向换行(上下行互换) align-content 定义多行的对齐方式,只有一行不起作用(堆栈伸缩行) 主要用于处理多行之间的富裕空间显示问题 flex-start: 元素在开始位置,富裕空间占据另一侧(默认) flex-end: 富裕空间在开始位置 元素占据另一侧 center: 元素居中 富裕空间 平分两侧 space-between: 富裕空间在元素之间平均分配 space-around: 富裕空间在元素两侧平均分配 stretch: 轴线占满整个交叉轴(默认 设置给子元素相关的属性: 子元素本身的显示方式 order 显示顺序 数字越大显示越靠后, 支持负数 flex-grow 伸缩项的扩充,数值越大扩充的越多 (所有子项宽度和小于父元素有效) flex-shrink 伸缩项的缩小,数值越大缩小的越多 (所有子项宽度和大于父元素有效) flex-basic 伸缩项的宽度, flex-basic设置的宽度优先级高于width flex 伸缩项属性连写 默认 flex: 0 1 auto; auto|none|具体数值占比 align-self 子元素在竖直方向上的对齐方式 flex-start: 元素在开始位置(默认) flex-end: 富裕空间在开始位置 center: 元素居中 富裕空间平分两侧 margin:auto 水平和竖直都居中 盒子阴影 box-shadow:[inset] x y blur [spread] colorinset: 内投影 outset: 外投影(默认) x 阴影水平偏移 y 阴影垂直偏移 blur 模糊半径(灰度) spread 扩展阴影半径(加大面积) 先扩展原有形状,再开始画阴影 color 阴影颜色同一盒子上可以使用多个阴影用逗号隔开 盒模型解析模式 标准盒模型 box-sizing:content-box盒模型宽高 = 2*border + 2*padding + content 怪异盒模型 box-sizing:border-box盒模型宽高 = content-2*border-2*padding CSS3新增背景属性 多重背景 background:url(“&quot; ) 0 0,url(“&quot;) 0 100%,url(“&quot;) 100% 100% background-origin: 背景区域定位 border-box 从border区域开始显示背景 padding-box 从padding区域开始显示背景(默认) content-box 从content区域开始显示背景 background-clip: 背景绘制区域 border-box 从border区域向外裁剪背景(默认) padding-box 从padding区域向外裁剪背景 content-box 从content区域向外裁剪背景 text 背景填充文本(仅webkit支持)文本区域显示背景 background-size: 背景大小 具体指：数值或百分比 cover 覆盖： 图片等比例放大。保证完全覆盖盒子，但不一定能完整显示背景图，会超出 contain 包含: 图片最大化的等比例完整显示在盒子中，但可能不会铺满整个盒子，可能会留白 线性渐变创建背景图像background-image:linear-gradient(起点/角度,开始颜色,结束颜色,位置) 径向渐变创建背景图像background-image:radial-gradient(起点(圆心位置),形状|大小|半径,颜色1,颜色2) CSS3 过渡属性 过渡动画transition:property duration timing-function delaytransition:property 过渡属性的名称 none 没有过渡属性 all 所有属性过渡(默认) property 具体属性名称 transition-duration: 过渡属性花费的时间(秒或毫秒)transition-delay: 过渡效果延迟时间(秒或毫秒)transition-timing-function: 过渡效果速度曲线 linear:规定以相同速度开始至结束的过渡效果(匀速) cubic-bezier(n,n,n,n):在函数中定义自己的值0到1之间的数值 贝塞尔曲线` 过渡完成事件 obj.addEventListener(&#39;webkitTransitionEnd&#39;,function(){}) obj.addEventListener(&#39;transitionend&#39;,function(){}) CSS3 动画属性animation:name duration timing-function delay iteration-count direction animation-name:动画名称 keyframename animation-duration:动画执行时间 秒或毫秒 animation-timing-function:动画速度曲线 animation-delay:动画效果延迟时间 秒或毫秒 animation-iteration-count:动画执行次数n 具体的次数 infinite 无线重复 animation-direction:动画的执行方向normal 正常顺序(默认) alternate 动画轮流反向播放 animation-fill-mode: 动画执行过程效果是否可见none 不做改变(默认值)forwards 当动画完成后,保持最后一个属性值(状态)不会回到原来(在最后一个关键帧中定义)backwards 动画完成回到开始前状态 animation-play-state:动画执行状态(单独写) paused 暂停动画 running 运行动画 @keyframes animationname {keyframes-selector{css-style;}}animationname 定义动画的名称keyframes-selector 动画时长的百分比0-100% from(与0%相同) to(与100%相同) 可以只有tocss-styles 一个或多个合法的CSS样式属性 动画事件动画开始时触发:obj.addEventListener(&quot;webkitAnimationStart&quot;, fn) obj.addEventListener(&quot;animationstart&quot;, fn)动画执行过程中触发：obj.addEventListener(&quot;webkitAnimationIteration&quot;,fn) obj.addEventListener(&quot;animationiteration&quot;, fn)动画结束是触发：obj.addEventListener(&#39;webkitAnimationEnd&#39;,fn) obj.addEventListener(&#39;animationend&#39;,fn)逐帧动画 animation-timing-function :steps(1) 去除过渡的效果（补间) 区间之间的只有一个画面 CSS3 2D变换内联元素是无法应用transform变换的，且不支持所有变换特性，transform属性会提升层级 tansform:rorate(360deg) 旋转函数(deg) transform:skew(45deg,45deg) 倾斜函数(deg) skewX() skewY() transform:scale(X,Y) 缩放函数(正数,负数和小数) scaleX() scaleY() transform:translate(X,Y) 位移函数(px) translateX() translateY() transform 简写执行顺序(后写先执行) 不同变换函数的顺序不同，效果也不一样 transform-origin: x,y 旋转的基准点(默认值center) x: left/center/right/length/% y: top/center/bottom/length/% z: length transform:matrix(a,b,c,d,e,f) 矩阵函数 默认值：matrix(1,0,0,1,0,0) 通过矩阵实现缩放 x轴缩放 a=xa c=xc e=x*e; y轴缩放 d=yd b=yb f=y*f; 通过矩阵实现位移 x轴位移: e=e+disX y轴位移: f=f+disY 通过矩阵实现倾斜 x轴倾斜: c=Math.tan(xDeg/180*Math.PI) y轴倾斜: b=Math.tan(yDeg/180*Math.PI 通过矩阵实现旋转 a=Math.cos(deg/180*Math.PI); b=Math.sin(deg/180*Math.PI); c=-Math.sin(deg/180*Math.PI); d=Math.cos(deg/180*Math.PI); CSS3 3D变换transform-style:preserve-3d 建立3D环境(要加给父级元素)perspective:800px 添加视镜 一般800px到1000px立体效果更好,就是元素里我们的距离近大远小transfrom: translateZ() 元素在Z轴方向上的移动距离transform: scaleZ() 元素在Z轴方向上的缩放transform: rotate() rotateX() 元素围绕其 X 轴以给定的度数进行旋转 rotateY() 元素围绕其 Y 轴以给定的度数进行旋转 rotateZ() 元素围绕其 Z 轴进行旋转(和2D中效果一样) CSS3 响应式布局分栏布局(只有-webkit有效) column-width 栏目宽度(给父元素加但不要加高度) column-count 栏目列数当同时设column-width和column-count时,只有column-count有效 column-gap 各栏目之间的距离 column-rule 栏目的分隔线 响应式布局 关键字and not 用来排除某种指定的媒体类型only 用来指定某种特定类型的媒体类型 媒体特性max-width:600px 最大宽度min-width:600px 最小宽度max-device-width:480px 设备输出宽度orientation:portrait 竖屏orientation:landscape 横屏-webkit-min-device-pixel-ratio:2 像素比devicePixelRatio 设备像素比window.devicePrixelRatio=物理像素/dips 样式引入(不同设备引入不同css)&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; media=&quot;all and (orientation:portrait )&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; media=&quot;screen and (min-width:800px)&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; media=&quot;screen and (min-width:600px) and (max-width:800px)&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; media=&quot;screen and (max-width:600px)&quot; /&gt; max-device-width和max-width的区别 123456/* 1、max-device-width是设备整个显示区域的宽度，例如，真实的设备屏幕宽度。2、max-width是目标显示区域的宽度，例如，浏览器宽度。3、如果使用max-device-width，那么在PC浏览器上浏览网页时，缩小或放大浏览器时是不执行CSS的，因为“PC设备”没有变化。但如果使用max-width，缩小或放大浏览器时是执行CSS的，因为“显示区域”即浏览器大小发生了变化。4、如果使用max-device-width，那么当手机由竖变横时，CSS是不执行的，因为“手机宽度”并没有变化。如果使用max-width，那么当手机由竖变横时，CSS是执行的，因为“显示区域”发生了变化。5、通常，面向“移动设备”用户使用max-device-width；面向“PC设备”用户使用max-width。*/ 媒体查询(不同屏幕大小使用不同的样式) 1234567891011121314151617181920212223.d1&#123; width:200px; height:600px; background:#000;&#125;/* 超小屏幕 手机&gt; */@media (max-width:768px)&#123; .d1&#123; background:skyblue; &#125;&#125;/* 小屏幕 平板 */@media (min-width:768px) and (max-width:992px)&#123; .d1&#123; background:#999; &#125;&#125;/* 中等屏幕 桌面显示器 */@media (min-width:992px) and (max-width:1200px)&#123; .d1&#123; background:blue; &#125;&#125;/* 大屏幕 大桌面显示器&gt; */@media (min-width:1200px)&#123; .d1&#123; background:pink; &#125;&#125; 移动设备viewpoart&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt; CSS3 响应式设计 为什么要进行响应式设计 为了在不同大小的设备上呈现同样的网页 早期的解决方案 是为不同的设备提供不同的网页,比如专门的wp版本. 现在的解决方案 让同一网页自动适应不同大小的屏幕,根据屏幕宽度,自动调整布局(layout).一次设计,普遍适用,自动识别屏幕宽度,并作出相应调整的网页设计 响应式设计详解 viewport标签 让网页自动适应屏幕的宽度在头部head添加 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; 网页宽度默认等于屏幕宽度width=device-width 原始缩放比例initial-scale=1 媒体查询 自动探测屏幕宽度,然后加载相应的css文件media query&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (max-width:767px)&quot; href=&quot;phone.css&quot; /&gt;如果屏幕宽度小于767像素(max-width:767px)就加载phone.css文件&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (min-width:768px)&quot; href=&quot;phone.css&quot; /&gt;如果屏幕宽度大于768像素(min-width:768px)就加载pc.css文件 不使用固定的宽度,尽可能使用百分比宽度 使用相对大小的字体使用rem，相对根元素html字体大小,默认为16像素,所以 1rem = 16px。或者使用em字体大小 图片的自适应(fluid image)实现图片的自动缩放img{max-width:100%},多媒体标签实现自适应object,embed{max-width:100%} 响应式设计的原则 移动优先 在设计的初期就要考虑页面如何在多终端的展示 渐进增强(progressive enhancement) 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验,意味着朝前看，同时保证其根基处于安全地带 优雅降级(graceful degradation) 一开始就应该针对那些最高级、最完善的浏览器来设计网站构建完整的功能，然后再针对低版本浏览器进行兼容 区别 优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5学习]]></title>
    <url>%2Fhtml5%2F</url>
    <content type="text"><![CDATA[Html5特点:代码更加简洁,标签具有语义化,新增了一些属性,代码更加宽松,是互联网的下一代标准,新增了更加丰富且实用的规范, 如: 语义化标签、废除标签、丰富表单控件、拖拽事件、Canvas、SVG矢量图、Video、Audio、触屏touch事件、本地存储、应用缓存等. HTML5新增标签 结构标签:块级元素(有语义的div) 12345678910&lt;header&gt; 标记定义一个页面或一个区域的头部&lt;nav&gt; 标记定义导航链接&lt;section&gt; 标记定义一个区域(类似div)&lt;aside&gt; 标记定义页面部分的侧边栏&lt;footer&gt; 标记定义一个页面或一个区域的底部&lt;article&gt; 标记定义一篇文章&lt;dialog&gt; 标记定义一个会话框&lt;hgroup&gt; 标记定义文件中一个区块的相关信息&lt;figure&gt; 标记定义一组媒体内容以及他们的解释说明&lt;figcaption&gt; 标记定义figure元素的解释说明 多媒体标签 123&lt;video&gt; 页面中插入视频内容&lt;audio&gt; 页面中插入音频内容&lt;source&gt; 可定义多个媒体资源 绘图标签 12&lt;canvas&gt; 绘制图片&lt;svg&gt; 矢量图 注释标签 123&lt;ruby&gt; 标记定义注释或音标&lt;rp&gt; 告诉那些不支持Ruby元素的浏览器如何去显示&lt;rt&gt; 标记定义对ruby的注释内容文本 其他标签 123456789&lt;menu&gt; 标记重新定义用户界面的菜单配合commond或者menuitem使用&lt;keygen&gt; 标记定义表单里公钥&lt;mark&gt; 标记定义有mark标记的文本(默认为黄色背景)&lt;output&gt; 标记定义一些输出类型,计算表单结果,配合表单事件&lt;time&gt; 标记定义一个日期/时间 没什么用便于seo&lt;address&gt; 标记定义文章或作者的详细信息 默认斜体显示&lt;meter&gt; 状态标签,温度等 &lt;meter min='0' max='45' low='36' high='38' value='35' &gt;&lt;/meter&gt;&lt;progress&gt; 进度条 &lt;progress max="100" value="30"&gt;&lt;datalist&gt; 为input定义下拉列表仅在chrome中有效 废除元素 123纯表现 basefont,big,center,font,s,strike,tt,u会产生负面影响 frame,frameset,noframes产生混淆 acronym,applet,isindex,dir Html5新增表单 input表单type属性值 12345678910111213type="email" 限制用户输入的必须为Email类型type="url" 限制用户输入的必须为url类型type="date" 限制用户输入的必须为日期类型type="datetime" 显示完整日期 含时区type="datetime-local" 显示完整日期 不含时区type="time" 限制用户输入必须为时间类型type="month" 限制用户输入的必须为月类型type="week" 限制用户输入的必须为周类型type="number" 限制用户输入的必须为数字类型type="range" 生成一个滑动条 其他属性type="search" 具有搜索意义的表单result=n的属性type="color" 生成一个颜色选择表单type="tel" 显示电话号码 新增表单属性 12345required: 内容不能为空placeholder: 表单提示文字（占位符），输入文字后消失autofocus: 自动聚焦 页面加载之后pattern 正则表达式autocomplete 是否保存或提示用户输入值 默认为on 关闭off 表单验证反馈 123456789invalid 事件 validity对象(valid查看验证是否通过)input.addEventListener(“invalid”,fn,false) 验证失败时执行函数阻止默认验证: ev.preventDefault()关闭验证: formnovalidate输入值为空时: valueMissing值与设定类型不匹配:typeMismatch输入值不满足正则: patternMismatch不符合自定义验证: customError自定义验证: setCustomValidity() Html5拖拽事件 图片自带拖拽功能, 其他元素可设置draggable属性draggable:true 拖拽元素(被拖拽的元素对象)事件:ondragstart 拖拽前触发ondrag 拖拽过程中,连续触发ondragend 拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件:ondragenter 进入目标元素触发ondragover 进入目标,离开目标之间,连续触发ondragleave 离开目标元素触发ondrop 在目标元素上释放鼠标触发,需要在ondragover里添加阻止默认行为,才可以实现 拖放事件的执行顺序 1234// Drop不触发 dragstart&gt;drag&gt;dragenter&gt;dragover&gt;dragleave&gt;dragend// Drop触发时 dragstart&gt;drag&gt;dragenter&gt;dragover&gt;drop&gt;dragend// (需要在dragover的时候阻止默认行为)// 拖拽的兼容问题 在火狐浏览器中需设置dataTransfer对象才可以拖拽除图片外的标签 dataTransfer对象下的属性有:setData() 设置数据key和value(必须是字符串)getData() 获取数据 根据key获取对应的valueeffectAllowed(none,copy,copyLink,copyMove,link,linkMove,move,all,uninitialized) 设置光标样式files 获取外部拖拽的文件,返回filesList列表,在filesList下有个type属性,返回文件的类型 12345678odiv1.ondragstart = function(ev) &#123; var ev = ev || window.event ev.dataTransfer.setData('data', 'odiv1')&#125;odiv2.ondrop = function(ev)&#123; var ev = ev || window.event ev.dataTransfer.getData('data')&#125; 图片上传与拖拽 1234567891011121314151617181920212223242526272829/*1.获取外部的拖拽的文件 file=ev.dataTransfer.files2.新建一个文件读取对象 re=new FileReader()3.读取拖拽进来的文件 re.readAsDataURL(file[0])4.读取文件完成触发函数 re.onload=function()&#123;&#125;5.取得读取到的数据 this.result6.创建img标签 将取得数据赋值给img的src属性7.将img对象添加到目标对象中*/odiv3.ondrop = function(ev)&#123; var ev = ev||window.event ev.preventDefault() this.indexHTML = '' var file = ev.dataTransfer.files // 获取外部拖拽的文件 for (var i=0;i&lt;file.length;i++) &#123; // 遍历上传的文件 if(file[i].type.indexOf('image') &gt; -1)&#123;// 判断是否是图片类型 var re = new FileReader() // 新建文件读取对象 re.readAsDataUrl(file[i]) // 读取文件 re.onload = function()&#123; console.log(this.result) var img = doucment.createElement('img') // 创建图片对象 img.src = this.result // 将读取到的文件数据赋值给img对象 odiv3.appendchild('img') // 将img对象添加到拖拽的目标对象odiv3上 &#125; &#125; else &#123; alert('请上传图片类型') &#125; &#125;&#125; Html5canvas绘图 canvas标签 &lt;canvas id=&quot;can&quot; width=&quot;300px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;canvas元素本身是没有绘图能力的,所有的绘制工作必须在javascript中进行完成,拥有多种绘制图形,字符,图像的方法 canvas绘图环境设置cxt=getContext(&quot;2d&quot;) 目前只支持2d绘图环境(获取图形上下文) 绘制路径 123456cxt.beginPath() 开始路径cxt.closePath() 结束路径// 注:画每个图形最好都加上beginPath()和closePath()否则,会出现所有图形都连在一起,就是因为没有结束路径cxt.rect(x,y,w,h) 矩形路径cxt.save() 保存路径 新开辟一个空间来绘制图形 保存之前的画布内容cxt.restore() 恢复路径 释放之前的画布内容 设置绘图样式和方法 1234567cxt.moveTo(x,y) 将触笔移动(x,y)点cxt.lineTo(x,y) 绘制到(x,y)点cxt.stroke() 用触笔方法画线cxt.fill() 用填充方法画线cxt.fillStyle=”green” 设置图形(填充)方法样式的颜色cxt.strokeStyle=”blue” 设置边框(触笔)方法的颜色cxt.lineWidth=10 触笔的宽度(线宽) 绘制线段 123cxt.moveTo(x,y) 绘制线段的起点cxt.lineTo(x,y) 绘制线段的终点cxt.stroke() 使用触笔方法划线段 绘制矩形 1234cxt.fillRect(x,y,w,h) 填充方法绘制实心矩形 x,y起点坐标 w宽 h高cxt.strokeRect(x,y,w,h) 触笔方法绘制空心矩形cxt.clearRect(x,y,w,h) 清除画布内容// 当同时使用这两方法时,前面绘制的内容会被后面的覆盖 图形边界样式 12// lineJoin 边界连接点的样式 miter(默认值) round(圆角) bevel(斜角)// lineCap 端点样式 butt(默认值) round(圆角) square(长度多出线宽一半) 绘制圆形 1234ctx.arc(x,y,r,0,360,false)// x,y 圆心坐标位置 r 圆半径 0,360 从0度到360度绘制一个圆形// true/false 顺时针/逆时针绘图// 注: 0,360 这是弧度制 角度*PI/180 绘制曲线 123456ctx.arcTo(x1,y1,x2,y2,r)// x1,y1 坐标一 x2,y2 坐标二 r圆弧半径ctx.quadraticCurveTo(dx,dy,x1,y1)// 贝塞尔曲线dx,dy控制点x1,y1 结束点ctx.BezierCurveTo(dx1,dy1,dx2,dy2,x1,y1)// 贝塞尔曲线: dx1,dy1 控制点一 dx2,dy2 控制点二 x1,y1 结束点 Canvas变换 123ctx.translate(x,y) // 从起始点为基准,移动到当前位置ctx.rotate(弧度) //旋转,弧度公式 角度*PI/180ctx.scale(wb,hb) //缩放比例(缩放canvas绘制的图片) 绘制图片 12345678910111213141516171819drawImage(img,x,y,w,h)// 绘制图片(图片,x坐标,y坐标,宽度,高度)// 绘制图片时,要图片预加载之后再绘制,否则会因缓存而加载不出var can = document.getElementById('can')var ctx = can.getContext("2d")var img = new Iamge()img.src = 'images/1.jpg'img.onload = function()&#123; ctx.drawImage(img, 0, 0, can.width, can.height)&#125;// 绘制背景图片var can = document.getElementById('can')var ctx = can.getContext("2d")var img = new Iamge()img.src = 'images/1.jpg'img.onload = function()&#123; ctx.fillStyle(ctx.createPattern(img, 'no-repeat')) ctx.fillReact(0, 0, can.width, can.height)&#125; 渐变 123456789101112131415161718192021222324// 线性渐变// createLinearGradient(x1,y1,x2,y2) // x1,y1 起始坐标点 x2,y2 结束坐标点// addColorStop(位置,颜色) //渐变点: 位置:渐变点 0~1之间 可多个var can = document.getElementById('can')var ctx = can.getContext("2d")var color = ctx.createLinearGradient(50, 50, 200, 200)color.addColorStop(0, '#f3c')color.addColorStop(1, '#03f')ctx.fileStyle = colorctx.fileReact(50, 50, 200, 200)// 径向渐变// createRadialGradient(x1,y1,r1,x2,y2,r2)// x1,y1,r1 内圆圆心坐标和半径 x2,y2,r2 外圆圆心坐标和半径var can = document.getElementById('can')var ctx = can.getContext("2d")var color = ctx.createLinearGradient(150, 150, 50, 150, 150, 100)color.addColorStop(0, 'blue')color.addColorStop(0.5, 'red')color.addColorStop(1, 'yellow')ctx.fileStyle = colorctx.beginPath()ctx.arc(150, 150, 100, 0, 360, false)ctx.closePath()ctx.fill() 导出canvas图片 火狐,谷歌浏览器右键菜单可直接导出为图片 img.src=can.toDataURL() //导出图片 绘制文本 123456789101112// strokeText(文本,x,y) 绘制空心文本// fillText(文本,x,y) 绘制实心文本// font="font-size font-family" 注 尺寸字体缺一不可// textAlign="" 文本左右对齐方式 // start center end left right// textBaseline="" 文本上下对齐方式 // alphabetic 默认 文本基线时普通字母的字母基线 // top 文本基线是em方框的顶端 // hanging 文本基线是悬挂基线 // middle 文本基线是em方框的正中 // ideographic 文本基线是表意基线 // bottom 文本基线是em方框的底端// measureText(文本).width 文本的实际宽度(只有宽度值) 绘制阴影 123// shadowOffsetX,shadowOffsetY x轴,y轴偏移// shadowBlur 阴影模糊度// shadowColor 阴影颜色 默认颜色 rgba(0,0,0,0) HTML5 SVG矢量图 SVG指可伸缩矢量图形,图像在放大和缩小时,图形质量不会损失,是使用XML来描述二维图形和绘图程序的语言 &lt;svg xmlns=”http://www.w3.org/2000/svg” version=”1.1”&gt;&lt;/svg&gt; svg圆形 123&lt;circle cx="50" cy="50" r="30" stroke="red" stroke-wodth="" fill="none/transparent" style=""&gt;&lt;/circle&gt;// 圆心坐标 cx,cy 半径 r fill stroke stroke-width style 样式 svg矩形 1234&lt;rect width="90" height="90" x="200" y="10" stroke="red"stroke-width="5" fill="transparent" rx="20"ry="20" stroke-opacity="0.7"&gt;&lt;/rect&gt;// 宽/高 width/height 起始点 x,y 圆角 rx,ry 透明stroke-opacity svg线段 123&lt;line x1="50" y1="50" x2="150" y2="150"stroke="red" stroke-opacity="0.7"&gt;&lt;/line&gt;// 起始坐标 x1,y1 终止坐标 x2,y2 svg折线 123&lt;polyline points="50 50 50 150 150 50 150 150"stroke="red" fill="none"&gt;&lt;/polyline&gt;// 空格或逗号隔开多个点 svg多边形 12&lt;polygon points="50 50 50 150 150 50 150 150"stroke="red" fill="none"&gt;&lt;/polygon&gt; Text标签 12&lt;text x="150" y="150" font-size="40px" text-anchor="middle"&gt;文字&lt;/text&gt;// 起始位置 x,y 对齐方式 text-anchor:start/end/middle Path路径 123456&lt;path d="M50 50L150 30L200 100" stroke="red"stroke-width="5" fill="none"&gt; &lt;/path&gt;// M(起始坐标) L(结束坐标) H(水平线) V(垂直线) Z(闭合路劲)// C,S,Q,T(贝塞尔曲线) A(圆弧)// 大写为绝对坐标(具体的位置坐标)// 小写为相对坐标(相对于起始点的具体长度) HTML5视频video &lt;video src=&quot;xxx.mp4&quot; controls autoplay width=&quot;500&quot; height=&quot;500&quot; Preload=”preload” poster=”1.jpg” loop=”loop”&gt;&lt;/video&gt; Video的属性 123456789Autopaly 视频加载完成后自动播放Controls 向用户显示播放控件(必须设定)Width 设置播放器宽度Height 设置播放器高度Loop 播放完是否继续播放该视频,循环播放Preload 页面加载时就加载视频,并预备播放Src 视频url地址Poster 加载等待的画面图片poster=”url”Autobuffer 设置为浏览器缓冲方式,不设置autoplay才有效 video对象方法vid.paly() 播放 vid.pause() 暂停 vid.load() 重新加载 video对象属性12345678currentTime: 开始到播放现在所用的时间duration: 媒体总时间(只读)volume: 0.0-1.0de 音量相对值muted: 是否静音false/truepaused: 媒体是否暂停(只读)ended: 媒体是否播放完毕(只读)error: 媒体发生错误的时候,返回错误代码(只读)currentSrc: 以字符串的形式返回媒体地址(只读) HTML5音频audio &lt;audio src=&quot;xxx.mp4&quot; controls autoplay&gt; audio 属性1234autoplay="autoplay" 加载完自动播放controls="controls" 显示用户控件preload="preload" 页面加载时加载音频,并预备播放src="url" 要播放的音频的URL HTML新增touch事件 触屏事件touch 123456touchstart 当手指触摸到屏幕时触发touchmove 手指在屏幕上移动时触发touchend 手指离开屏幕时触发touchenter 当触点进入某个元素时触发touchleaver 当触点离开某个元素时触发touchcancel 当触点由于某些原因被中断时触发 触屏事件对象touchEvent 1234567891011touches 当前位于手机屏幕上的所有手指列表 最多5个手指targetTouches 位于当前的元素上的手指的列表changeTouches 涉及当前事件的手指列表clientX 触摸目标在视窗中的X坐标clientY 触摸目标在视窗中的Y坐标identifier 标识触摸的唯一IDpageX 触摸目标在页面中的X坐标pageY 触摸目标在页面中的Y坐标screenX 触目目标在屏幕中的X坐标screenY 触摸目标在屏幕中的Y 坐标target 触摸的DOM节点目标 Html5 新增JS特性 获取class列表属性 123456789// &lt;div class=”div1 div2 div3”&gt;&lt;/div&gt;var odiv = document.getElementsByTagName('div')odiv.classlist //div1 div2 div3odiv.classlist.length //3odiv.classlist.add("div4") // 添加class类odiv.classlist.item(2) // 返回类名在元素中的索引值从0开始odiv.classlist.remove("div2","div4") //移除多个class类odiv.classlist.toggle("div5") // 有class类则移除没有则添加odiv.classList.contains("div2") // 是否包含某个类名 新增选择器 123document.querySelector("#div|.cnt|div|css选择器") //只能返回一组中的第一个元素document.querySelectorAll(“css选择器”) // 可以获取一组元素document.getElementsByClassName("box") // IE9以下不兼容 获取自定义属性 1234//&lt;div id="div1" data-tew='自定义属性' data-tew-all='多节自定义属性'&gt;自定义属性获取&lt;/div&gt;var oDiv = document.querySelector('#div1')console.log(oDiv.dataset.tew)console.log(oDiv.dataset.tewAll) Html5本地存储 sessionStorage 会话存储 12345// 生命周期为关闭浏览器窗口 关闭窗口数据销毁 在同一个窗口下数据可以共享sessionStorage.getItem(key) // 获取存储数据sessionStorage.setItem(key,value) // 设置存储数据sessionStorage.removeItem(key) // 删除存储数据sessionStorage.clear() // 清除存储数据 localStorage 本地存储 123456// 永久生效，除非手动删除，清理垃圾，存储在磁盘上,可以在多窗口共享// 只能存储字符串，可以将对象JSON.stringify()之后在存储,可能存储在浏览器内存和硬盘上localStorage.setItem(key, walue) // 设置储存内容localStorage.getItem(key) // 获取存储数据localStorage.removeItem(key) // 删除keylocalStorage.clear() // 清除所有数据 HTML5 历史管理history history.pushState() 123location.href // http://192.168.5.16:8000history.pushState(&#123;&#125;, '', '/foo') // http://192.168.5.16:8000/foohistory.pushState(&#123;&#125;, '', '/') // http://192.168.5.16:8000 history.replaceState() 123location.href // http://192.168.5.16:8000history.replaceState(&#123;&#125;, '', '/foo') // http://192.168.5.16:8000/foohistory.pushState(&#123;&#125;, '', '/') // http://192.168.5.16:8000 history.go(number) 回退到指定历史记录 history.back() 等价于 history.go(-1) history.forward() 则等价于 history.go(1)]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习]]></title>
    <url>%2Fbootstrap%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。Bootstrap 让前端开发更快速、简单。所有开发者都能快速上手且应用广泛。 下载 官网地址和官方实例 使用CDN 123456&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.5/dist/css/bootstrap.min.css"&gt;&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.5/dist/css/bootstrap-theme.min.css"&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.5/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; 下载 用于生产环境的bootstrap之后解压 本地引入以移动设备为优先 窗口和设备的屏幕一致,初始缩放100% 禁止用户双击注:bootstrap是基于jquery开发的所以在引入bootstrap.js文件之前需要加入jquery文件下载的Bootstrap的基本文件结构：编译好的 CSS 和 JS (bootstrap.*) 文件，经过压缩的 CSS 和 JS (bootstrap.min.*) 文件。CSS 源码映射表 (bootstrap.*.map) 。fonts下 Glyphicons 的图标字体文件. bootstrap对视口的划分 超小屏幕(xs): &lt; 576px 小屏幕(sm): &gt;= 576px 中等屏幕(mg): &gt;= 768px 大屏幕(lg): &gt;= 992px 超大屏幕(xl): &gt;= 1200px 布局容器12&lt;div class=”container”&gt; 固定容器: 在不同视口大小下就会有不同的固定宽度 &lt;/div&gt;&lt;div class=”container-fulid”&gt; 自适应容器: 宽度为100% &lt;/div&gt; 栅格系统Bootstrap的栅格系统使用统一的&quot;行&quot;和&quot;列&quot;来实现复杂的响应式布局,默认情况下将一行内容等分为12份,通过使用col-x类名在指定每一列占用多少份12345678910111213141516&lt;!-- 将栅格系统一定要放入容器中 --&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-5"&gt; &lt;!-- offset-x 当前列偏移x份 --&gt; &lt;div class="col-5 offset-2"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="container-fulid"&gt; &lt;div class="row"&gt; &lt;!-- order-x 列排序 小的在前面 大的在后面 --&gt; &lt;div class="col-4 order-3"&gt; &lt;div class="col-4 order-2"&gt; &lt;div class="col-4 order-1"&gt; &lt;/div&gt;&lt;/div&gt; 公共样式1234567891011121314151617181920212223242526272829303132&lt;!-- 文字颜色 --&gt;&lt;!-- .text-primary .text-success .text-danger .text-warning .text-dark --&gt;&lt;div class="text-primary"&gt;颜色: 主要蓝&lt;/div&gt;&lt;div class="text-success"&gt;颜色: 成功绿&lt;/div&gt;&lt;div class="text-danger"&gt;颜色: 危险红&lt;/div&gt;&lt;!-- 背景颜色 --&gt;&lt;!-- .bg-primary .bg-success .bg-danger .bg-warning .bg-dark --&gt;&lt;div class="bg-primary"&gt;颜色: 主要蓝&lt;/div&gt;&lt;div class="bg-success"&gt;颜色: 成功绿&lt;/div&gt;&lt;div class="bg-danger"&gt;颜色: 危险红&lt;/div&gt;&lt;!-- 边框 --&gt;&lt;!-- border/border-x 添加边框 border-color 边框颜色 round 圆角边框 --&gt;&lt;div class="border border-warning round"&gt;警告黄圆角边框&lt;/div&gt;&lt;!-- 浮动 --&gt;&lt;!-- clearfix 清除浮动 bootstarp4.x float-left/right/none 浮动 bootstarp3.x pull-left/right 浮动 --&gt;&lt;div class="clearfix"&gt; &lt;div class="float-left"&gt;左浮动&lt;/div&gt; &lt;div class="float-right"&gt;右浮动&lt;/div&gt;&lt;/div&gt;&lt;!-- 定位 position-* --&gt;&lt;div class="position-relative"&gt;相对定位&lt;/div&gt;&lt;div class="position-absolute"&gt;绝对定位&lt;/div&gt;&lt;!-- 关闭按钮 --&gt;&lt;button type="button" class="close" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;&lt;!-- 三角符号 --&gt;&lt;span class="caret"&gt;&lt;/span&gt;&lt;!-- 让内容块居中 --&gt;&lt;div class="center-block"&gt;...&lt;/div&gt;&lt;!-- 显示或隐藏 --&gt;&lt;div class="show"&gt;...&lt;/div&gt;&lt;div class="hidden"&gt;...&lt;/div&gt;&lt;div class="invisible"&gt;...&lt;/div&gt; 排版的标签12345678910111213&lt;h1 class=”page-header”&gt;内容&lt;/h1&gt; 36px&lt;h2&gt;&lt;/h2&gt; 30px&lt;h3&gt;&lt;/h3&gt; 24px&lt;h4&gt;&lt;/h4&gt; 18px&lt;h5&gt;&lt;/h5&gt; 14px&lt;h6&gt;&lt;/h6&gt; 12px.h1,.h2,.h3,.h4,.h5,.h6 模拟h标签的样式.page-header 设置页头 给标题加一个分隔线&lt;small&gt;&lt;/small&gt; 副标题 小一号&lt;big&gt;&lt;/big&gt;副标题 大一号&lt;strong&gt;&lt;/strong&gt;推荐使用的加粗&lt;em&gt;&lt;/em&gt;推荐使用的倾斜&lt;del&gt;&lt;/del&gt;删除线 文本对齐方式1234&lt;p class="text-left"&gt;文字左对齐&lt;/p&gt;&lt;p class="text-center"&gt;文字居中对齐&lt;/p&gt;&lt;p class="text-right"&gt;文字右对齐&lt;/p&gt;&lt;p class="text-justify"&gt;文字两端对齐&lt;/p&gt; 英文大小写1234&lt;!-- .text-uppercase 英文大写 .text-lowercase 英文小写 .text-capitalize 首字母大写 --&gt;&lt;p class="text-lowercase"&gt;lowercased text&lt;/p&gt;&lt;p class="text-uppercase"&gt;UPPERCASED TEXT&lt;/p&gt;&lt;p class="text-capitalize"&gt;Capitalized Text&lt;/p&gt; 列表1234567891011&lt;ul class="list-inline"&gt; &lt;li&gt;.list-unstyled 去掉列表前面的符号 和去掉原有的格式&lt;/li&gt;&lt;/ul&gt;&lt;ul class="list-inline"&gt; &lt;li&gt;.list-inline 把li进行横向排列&lt;/li&gt;&lt;/ul&gt;&lt;!-- .dl-horizontal 设置变成横向排列 --&gt;&lt;dl class="dl-horizontal"&gt; &lt;dt&gt;自定义列表&lt;/dt&gt; &lt;dd&gt;自定义列表项&lt;/dd&gt;&lt;/dl&gt; 表格12345678910111213141516171819202122&lt;!-- .table 表格的一个基类.table-bordered 给表格加外边框 为表格和其中的每个单元格增加边框。.table-hover 鼠标放上去的悬停效果 放在行或单元格 背景变色.table-striped 隔行换色 条纹状表格.table-condensed 改变单元格的padding值 使表格变得紧凑些.table-responsive 给table的父元素加以移动设备为优先,如果不能显示完全的显示 会出现滚动条注: 状态类设置的是行tr或td.active 鼠标悬停在行或单元格上时所设置的颜色.success 标识成功或积极的动作.info 标识普通的提示信息或动作.Warning 标识警告或需要用户注意.danger 标识危险或潜在的带来负面影响的动作 --&gt;&lt;table class="table table-hover table-condensed table-bordered table-responsive"&gt; &lt;tr&gt; &lt;td class="active"&gt;...&lt;/td&gt; &lt;td class="success"&gt;...&lt;/td&gt; &lt;td class="warning"&gt;...&lt;/td&gt; &lt;td class="danger"&gt;...&lt;/td&gt; &lt;td class="info"&gt;...&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;.form-inline 类可使其内容左对齐并且表现为 inline-block 级别的控件.form-horizontal 类可以将 label 标签和控件组水平并排布局.checkbox-inline 或 .radio-inline 多选框（checkbox）或单选框（radio）使这些控件排列在一行.form-group-lg 或 .form-group-sm 设置水平排列的表单组的尺寸.input-lg 或 .input-sm 设置控件的尺寸--&gt;&lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!-- 多选框 --&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox1" value="option1"&gt; 1 &lt;/label&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox2" value="option2"&gt; 2 &lt;/label&gt; &lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox3" value="option3"&gt; 3 &lt;/label&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!-- 单选框 --&gt; &lt;label class="radio-inline"&gt; &lt;input type="radio" name="inlineRadioOptions" id="inlineRadio1" value="option1"&gt; 1 &lt;/label&gt; &lt;label class="radio-inline"&gt; &lt;input type="radio" name="inlineRadioOptions" id="inlineRadio2" value="option2"&gt; 2 &lt;/label&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!-- 下拉列表 --&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!-- 文本域 rows 控制行数 --&gt; &lt;textarea class="form-control" rows="3"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 按钮为 &lt;a&gt;、&lt;button&gt; 或 &lt;input&gt; 元素添加按钮类（button class）即可使用 Bootstrap 提供的样式。12345678910&lt;!--按钮颜色: btn-default btn-primary btn-success btn-info btn-warning btn-danger btn-link尺寸: .btn-lg .btn-sm .btn-xs块级按钮: .btn-block 将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素禁用: 添加 disabled 属性--&gt;&lt;a class="btn btn-default" href="#" role="button"&gt;Link&lt;/a&gt;&lt;button class="btn btn-primary btn-xs" type="submit"&gt;Button&lt;/button&gt;&lt;input class="btn btn-warning btn-sm" type="button" value="Input"&gt;&lt;input class="btn btn-danger btn-lg" type="submit" value="Submit"&gt; 响应式图片1234567&lt;!-- .img-responseive 响应式图片.img-rounded 圆角矩形.img-circle 圆形.img-thumbnail 给图片加圆角的边框 --&gt;&lt;img src="..." alt="..." class="img-rounded img-responseive"&gt;&lt;img src="..." alt="..." class="img-circle img-responseive"&gt;&lt;img src="..." alt="..." class="img-thumbnail img-responseive"&gt; 图标123&lt;!-- glyphicon glyphicon-* --&gt;&lt;span class="glyphicon glyphicon-align-left" aria-hidden="true"&gt;&lt;/span&gt;&lt;span class="glyphicon glyphicon-star" aria-hidden="true"&gt;&lt;/span&gt; 导航1234567891011121314&lt;!--.nav .nav-tabs 设置标签页.nav-pills 胶囊式标签页 .nav-stacked 垂直方向堆叠排列 .nav-justified 标签页等分宽度--&gt;&lt;ul class="nav nav-pills"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation" class="dropdown"&gt; &lt;a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="dropdown-menu"&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 导航条12345678&lt;!--.navbar .navbar-default 导航条.navbar-fixed-top 固定在顶部 .navbar-fixed-bottom 固定在底部.navbar-inverse 反色的导航条--&gt;&lt;nav class="navbar navbar-fixed-top navbar-inverse"&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/nav&gt; 插件1234567891011121314&lt;!-- 模态框 --&gt;&lt;!-- .modal-lg/.modal-sm 模态框尺寸 --&gt;&lt;button type="button" class="btn btn-primary" data-toggle="modal" data-target="#myModal"&gt;Large modal&lt;/button&gt;&lt;div class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel"&gt; &lt;div class="modal-dialog modal-lg" role="document"&gt; &lt;div class="modal-content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 用法一 使用 data 属性控制 在控制元素上添加 data-target="#myModal" --&gt;&lt;!-- 用法二 通过javascript调佣 --&gt;&lt;script&gt;$('#myModal').modal('show') // 手动打开模态框$('#myModal').modal('hide') // 手动隐藏模态框&lt;/script&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php基础2]]></title>
    <url>%2Fphp%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言，使用广泛，主要适用于Web开发领域， 可植入性强、拓展性强。 PHP数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677把若干变量按有序的形式组织起来的一种集合数组中存的是多个内容，数组的内容叫做元素 每个元素都是由 键(key下标)和值(value)组成数组的分类1.索引数组 下标是数字的2.关联数组 下标是字符串 能体现该单元的内容下标默认是从0开始 自动增长的下标都是出现过的最大值加1 关联数组的字符串下标不会影响索引下标的增长规则 下标重复则后面覆盖前面的值如果键是浮点数 则转成整数,如果字符串的内容恰好也是整数则理解为整数ex:$arr3=array(2=&gt;'非',2.5=&gt;'凡','2.5'=&gt;'软','2'=&gt;'件'); print_r($arr3);//Array([2]=&gt;'件',[2.5]=&gt;'软')$arr3=array(2=&gt;'非',2.5=&gt;'凡','2.5'=&gt;'软','2'=&gt;'件','2x'=&gt;'逗'); print_r($arr3);//Array([2]=&gt;'件',[2.5]=&gt;'软',[2x]=&gt;'逗')0.使用数组标识符[]声明$arr=["aaa",11,2=&gt;22,"bbb"] //适用于php5.4以后2.使用array()函数声明$arr=array("aaa",2=&gt;"bbb","one"=&gt;"ccc")3.直接一个个赋值声明删除数组中的某个元素unset()但数组不会重建索引，使用array_values()函数重建索引二维数组：数组元素的本身仍是数组访问二维数组中的某个元素 $arr[2]["age"]数组的长度或个数count($arr) count($str)如果是字符串无论是否为空都返回int 1数组的遍历1.使用for循环遍历数组 只针对递增的索引数组 一定是下标连续的索引数组，不能遍历关联数组，操作的是数组的一个备份2.使用foreach遍历数组foreach(数组 as 值变量)&#123;&#125;foreach(数组 as 下标变量=&gt;值变量)&#123;&#125;3.使用list()函数遍历数组 用数组的值为多个变量赋值 list($name,$age,$sex)=arr("zhang","25","男"); a.list右边只能是一个数组，参数必须是变量，不能是值 b.只能将下标是从0开始且连续的索引数组转为变量 c.可以在list()参数中通过空项选择性的接收数组元素4.使用each()函数遍历 each($arr);参数是一个数组，返回的值也是一个数组固定有四个元素 array(1=&gt;"zhang","value"=&gt;"zhang",0=&gt;"name","key"=&gt;"name") each()只处理当前指针所在的位置， 处理完后指向下一个元素，如果 已经到结束为止了，则返回false5.使用each list和while遍历 while(list($key,$value)=each($arr))&#123; echo $key,"--",$value &#125;数组的指针next()将指针向后移动一个元素,prev()将指针向前移动一个元素key()获取当前指针位置,current()获取当前指针所对应的值end()将指针指向数组最后一个元素并将其取出来,reset()将指针移至第一个索引的位置超全局数组(变量) 页面的任何位置都可以访问$_SERVER 包含头信息 路径和脚本位置的数组$_ENV $GLOBALS $_FILES$_GET 接收用户通过URL向服务器传的参数 $_POST 接收用户通过http协议向服务器传的参数$_COOKIE $_SESSION $_REQUEST获取IP地址 $_SERVER["REMOTE_ADDR"] 获取端口号 $_SERVER["REMOTE_PORT"]操作数组的函数a.数组的键/值操作1.array_values() 返回数组中所有元素的值1. count($arr) 获取数组的长度2. array_key_exists($key,$arr) 判断数组中是否存在某个键3. in_array("字符"，$arr,true) 判断数组中有没有某个元素，true类型和值都必须相同， 区分大小写，若是数组顺序也要相同4. array_filp($arr) 交换数组中的键和值 键和值必须是整型或字符串，不能是其他类型 原数组不改变5. array_reverse($arr,true)将数组反向 true(保留原来的键名只对索引数组有效)原数组不变array_filter($arr,"函数")过滤数组中的单元，若无函数则删除所有等值为false的单元sort()对数组按升序排列 rsort()对数组按降序排列 (不保留下标)ksort()对数组按照键名升序排列 krsort()对数组按照键名降序排列asort()对数组进行排序并保持索引关系 asort()对数组进行降序排序并保持索引关系natsort()按自然排序算法对数组进行排序 natsort()按自然排序算法对数组不区分大小写排序array_multisort()对多个数组或多维数组进行排序array_pop将数组最后一个单元弹出(出栈) array_push将一个或多个单元压入数组末尾(入栈)array_shift将数组开头的单元移除(出列) array_unshift在数组开头插入一或多个单元(入列)array_sum() 求所有数组元素的和 max() 返回数组的最大值 min() 返回数组的最小值array_product() 返回所有数组的乘积注: array_push() array_unshift() 返回数组的长度 原数组改变数组的合并可以使用+或array_merge()使用+合并 会把最先出现的值作为最终结果返回当键名为数字时,array_merge()不会覆盖掉原来的值,而是附加到后面当键名为字符时它会覆盖前面的值注意:数字键形式 '数字' 等价于 数字 PHP字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596单引号和双引号的区别a.在双引号中可以解析变量(变量被自动替换成数值),而在单引号中不能解析变量 (按普通字符数出)b.在双引号中可以使用转义字符 \n \\ \$ \' \" 在单引号中不能使用转义字符除了(转义单引号本身 \' 转义转义符号本身 \\ )\n 在PHP中只有在查看源代码时会看到效果 在页面中无效果 在使用引号输出变量时最好用&#123;&#125;包含避免变量和后面的字符连在一起 或者用空格隔开 echo "在第&#123;$a&#125;行中有&#123;$b&#125;个错误";c.单引号不需要分析变量.需要转义的也少,速度比双引号快ASCII码 36(左),37(上),38(右),39(下) 32~126 为可见字符 32为空格 数字0-9为 47-56 小写字母a-z 97-122 大写字母 A-Z 65-90符串声明或定义方式 a.单引号(尽量使用单引号) b.双引号 双引号和定界符中的变量都会被解析 c.定界符&lt;&lt;&lt; $str=&lt;&lt;&lt;str 要输出的字符串 str; str为指定的标识符，结束标识符必须另起一行，前后不能有其他字符或空格， 在开始和结束标识之间不有注释 定义大段文本 d.字符串的拼接 用.号 $a.$b =&gt; $a$b字符串处理函数可以将其他类型的数据先自动转换成字符串后再处理1.统计字符串的长度 a. strlen($str): 汉字在GBK编码中占2个字节 在UTF-8中占3个字节 b. mb_strlen($str,"gbk") 统计汉字字符2.截取字符串 a.substr($str,int start,length) 从star开始截取length个字符 如果start为负数 则从后往前数位置 如果length为负数则代表结束位置3.echo $str; print $str; 输出字符串 区别 echo无返回值 可以打印多个4.printf(%b,%c,%0,$str,$str,$str)格式化输出字符串5.trim()去除字符串两边的空白字符和特殊字符 ltrim()去除字符串左边的空白字符和特殊字符 rtrim()去除字符串右边的空白字符和特殊字符6.strtolower($str)将字符串$str全部变成小写 strtoupper($str)将字符串$str全部变成大写 ucfirst($str)将字符串$str第一个字符改大写 ucwords($str)将字符串$str每个字的第一个字母大写7.htmlspecialchars($str)将字符串转换成html实体 strip_tags($str)删除html标签8.strrev()将字符串前后颠倒9.检索字符串(查询) strstr();检索字符串 stristr()不区分大小写匹配 strstr($str1,$str2)获取指定字符串$str2在$str1中首次出现的位置到末尾的子字符串， 成功则返回剩余字符串，没找到则返回false 如果加参数true则返回出现位置到前面的字符串 strpos($str,"k") 检索字符在字符串中第一次出现的位置10.explode($str1,$str,limit)将字符串分割成数组 如果$str1为空，则返回false.如果$str在$str中找不到则返回包含$str单个元素的数组 implode($str,$arr)将数组转换成字符串11.替换字符串 a. str_replace($a,$b,$str) $a和$b可以是字符串也可以是数组 ex: echo str_replace('死','***',$str); b. strtr() 替换一批字符串 ex: $str="男人,女人,男孩,女孩"; echo strtr($str,array("男"=&gt;"女","女"=&gt;"男")); //女人,男人,女孩,男孩strlen($str); //返回字符串的长度mb_strlen($str) //以指定的编码格式返回字符串的长度注: count($str) 无论是否为空都返回1trim($str) 过滤字符串前后的空格trim($str," @") 过滤字符串前后的空格和指定的字符trim($str," a..z") 过滤字符串前后的空格和指定的字符ltrim 过滤左边的空格rtrim 过滤右边的空格chunk_split() 将字符串分割成小块chunk_split($str,n,"--") //ab--cd--ef--一个参数时 表示整个 n分割成几块 以--连接chr(97) //a 返回指定字符编码所对应的字符ord('a') //97 返回指定字符的字符编码substr($str,start,[length])1.如果没有length 则返回从start开始到结束所有的字符ex: echo substr("abcdef",1); //bcdef2.如果start为负 则从结尾处开始截取ex: echo substr("abcdef",-2,3) //ef3.如果length为负 则表示结束位置ex: echo substr("abcdef",-4,-1) //cde4.如果start大于字符串的长度 则返回falseex: var_dump(substr("abcdef",7)) //bool(false)5.如果start和length都为负数时 无交集则返回空字符串ex: var_dump(substr("abcdef",-5,-6)); //string(0) ""ucfirst($str) 将第一个单词的首字母大写lcfirst($str) 将第一个单词的首字母小写ucwords($str) 将每个单词的首字母大写strtoupper($str) 将字符串转化为大写strtolower($str) 将字符串转化为小写strstr($str,"a") 返回a第一次出现的位置到结尾的所有字符(包括a)ex: echo strstr($str6,"s"); //sdiasstrstr($str,"a",true) 返回a第一次出现的位置之前的字符(不包括a)ex: echo strstr($str6,"s",true); //astrrchr($str1,$str2) 返回字符串$str1中$str2最后一次出现的位置以后的所有字符strpos($str,"a") 返回指定字符第一次出现的位置(索引) 找不到返回falseex: echo strpos($str6,"s"); //1strrpos($str,"a") 返回指定字符最后一次出现的位置(索引) 找不到返回falseex: echo strrpos($str6, "s"); //5explode(".",$str); 将字符串以指定字符分割成数组 参数顺序不能改变ex: print_r(explode(",","asb,jk")); //Array ( [0] =&gt; asb [1] =&gt; jk )implode($arr,["--"]); 将数组以指定字符拼接成字符串ex: echo implode(array("asb","jk"),"-"); //asb-jk PHP文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253文件类型 在windows中只能是'file(文件)'或'dir(目录)'获取文件类型 filetype('../jsq.php')常用文件属性处理函数file_exists() 判断文件或目录是否存在filesize() 取得文件的大小is_readable() 判断文件是否可读is_writable() 判断文件是否可写is_executable() 判断文件是否可执行filectime() 获取文件的创建时间(时间戳)filemtime() 获取文件的修改时间(时间戳)fileatime() 获取文件的访问时间(时间戳)stat() 获取文件的大部分属性disk_total_space(“c:”) 磁盘总大小disk_free_space(“D:”) 磁盘可用空间is_dir() 判断文件名是否是一个目录is_file() 判断文件名是否是正常文件目录的基本操作 解析目录路径 不同的跟路径 A:PHP操作的根路径是操作系统的根 B:文档的根目录（在浏览器中使用） 路径相关函数 basename 返回路径中的文件名部分 dirname 返回路径中的目录部分 pathinfo 返回文件路径的信息(数组)包括dirname basename extension 遍历目录 A:foreach(glob() as $filename)使用glob函数遍历目录 B:打开目录opendir() 读取文件readdir() closedir()关闭目录 rewiddir()倒回目录 在读取目录后在对文件操作时不要操作.和.. 统计目录大小 disk_total_space()磁盘总大小 disk_free_space()磁盘可用空间 filesize()文件大小 dir()目录大小 建立与删除目录 mkdir()新建目录 rmdir()删除目录(目录必须为空) unlink(删除文件) 复制目录文件的基本操作 touch()创建一个文件 copy()复制文件 rename()重新命名或移动 unlink()删除一个文件 对文件内容整体的操作 不打开文件进行读取 file_get_contents()读取文件的内容 readfile()读取整个文件 $arr=file()一行一行的读取文件返回一个数组 $arr[n]读取第n行 file_put_contents()整个写入文件内容 文件的打开与关闭 $fp=fopen("文件位置URL","模式")资源 打开文件 模式 r只读 指针指向文件开头 w写入 清空文件 不存在则创建 a追加写入 指针指向文件末尾 不存在则创建 fclose($fp)关闭文件 文件某一部分进行操作 fwrite($fp,'写入文字') 写入文字 打开文件以后读取 fgets从打开的文件中读取一行 fgetc从打开的文件中读取一个字符文件的上传设置 方法必须为POST 编码方式必须为enctype='multipart/from-data' move_upload_file()文件上传函数 PHP面向对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374类是对象的抽象，对象是类的实例类的基本元素:成员属性和成员方法 在成员属性和方法前面一定要有修饰词public,private对类进行实例化 $bf1=new BoyFriend()创建对象访问对象中的成员属性或成员方法$引用名 = new 类名() $引用名-&gt;成员属性=赋值 为对象属性赋值echo $引用名-&gt;成员属性 输出对象的属性 echo $引用名-&gt;成员方法() 调用对象的方法构造方法 __construct(); 1.是对象创建完成以后，第一个自动调用的方法(特殊) 2.方法名称比较特殊，可以和类名相同的方法名 3.给对象的成员赋初值析构方法 __destruct(); 对象被注销(释放)之前自动调用的方法，不能带任何参数面向对象编程的三大特点: 1.封装性 就是把对象中的成员属性和成员方法加上访问修饰符使其尽可能隐藏对象的内部细节以达到 对成员的访问控制 3种访问修饰符 public(公有的 默认的) 在类的内部和子类中，在类体外都可以使用， private(私有的) 只能在所属类的内部使用和修改，不能在类体外和类的子类中访问 对于私有成员属性，不能在类外直接获取，需要在类的里面添加一方法通过方法来获取只 能在大括号内调用 protected(受保护的) 可以在本类和子类中被调用，其他地方则不能使用 2.继承性 子类使用extends继承父类 子类可以将父类中所有的内容都继承过来(私有的可继承过来但无法操作)可以修改或添加 继承中的重载(覆盖) 在子类可以用和父类相同的方法名 使用 类::成员 parent::成员 访问父类中被覆盖的方法 parent::__construct()只要是子类去覆盖父类的构造方法，一定要在子类的最上面调用一下 父类被覆盖的构造方法 权限的问题:子类只能大于或等于父类的权限，不能小于 3.多态性 魔术方法 __set() 在直接设置私有属性值时，自动调用，两个参数属性名和属性值 __get() 自动调用,是在直接访问私有成员时自动调用不是私有不调用一个参数 __isset() __unset() __tostring()是在直接使用 echo print输出一个对象时，自动调用这个方法，将对象的基本 信息放在__tostring()内部形成字符串返回，不能有参数 __clone() 克隆对象时，自动调用的方法，是对新克隆对象的初始化，在这个方法中$this代 表的是克隆后的副本，所以可以对其成员进行初始化 __call() 在调用一个对象中不存在的方法时自动调用 有两个参数__call(不存在的方法名，参数列表(数组)) 可以写提示，还可以将功能相似方法名不同的用它来完成 关键字 instanceof $p instanceof Student用于检测当前对象实例是否属于某一个类 final 用final修饰的类不能被继承，用final修饰的方法不能被覆盖(不让别人去扩展) static 可以修饰属性和方法，不能修饰类，可以被同一个对象共用，不需要实例化，静态成员 一旦被加载，脚本结束后才释放，静态方法中只能调用静态变量，不能调用非静态成员 调用静态成员的方式 A:在内部调用时使用 self::静态成员 B:在类外调用内部的静态成员时使用 类名::静态成员 const 修饰的成员属性为常量，只能修饰成员属性 访问方式和static相同 clone 使用clone复制一份对象 $obj1 = clone $obj对象串行化(序列化) 1.将对象转成字符串--串行化 应用 ①将对象在网络中传输 ②将对象持久保存 $str = serialize（对象） file_put_contents("objstr.txt",$str) __sleep() 在串行化时自动调用的方法 作用: 可以设置需要串行化的对象的属性 在这个方法中返回一个数组，在数组中声明的属性 被串行化，默认是全部串行化 2.将字符串转回对象--返串行化 $str=file_get_contnets("objstr.txt") $p=unserialize($str) __wakeup() 在反串行化时自动调用的方法 作用: 对串行化回来的对象进行初始化自动加载类 function __autoload($classname)&#123; inculude strtolower($classname)."class.php"&#125;抽象方法和抽象类 抽象方法 用abstract来修饰,没有方法体,不使用&#123;&#125;,直接使用分号结束功能只能在子类中实现 抽象类 不能被实例化的类,只能作为其他类的父类来使用,用abstract来声明抽象类,普通类 中不能有抽象方法,子类必须把全部的抽象方法覆盖(重写),才能创建对象 接口 使用interface声明接口,特殊的抽象类，接口中的方法必须全部是抽象方法，不能 使用public以外的关键字修饰接口中的成员 成员属性必须是常量不能是变量 子类使用implements来实现接口的，要实现多个接口每个接口之间用逗号连接命名空间(名字空间) 使用namespace来声明 必须放在第一行 PHP中操作MySQL1234567891011121314151617181920212223242526272829303132331.连接数据库 mysql_connect("数据库服务器地址","用户名","密码") or die('连接失败'.mysql_error())2.设定连接编码 a. mysql_query("set names 网页文件编码名") b. mysql_set_charset("网页文件编码名")3.选择数据库 a. mysql_query("use 数据库名"); b. mysql_select_db("数据库名")4.执行sql语句 mysql_query(sql语句)对于mysql_query()函数 可以执行几乎所有的sql语句 分为两种情况情况1 执行没有数据返回的语句 比如:insert update delete create drop 返回布尔值 true执行成功 false 执行失败情况2 执行有数据返回的语句 比如: select show desc 返回false 执行失败 执行成功 返回 结果集(数据集)$res=mysql_query("select.....") //执行又返回的数据的语句while($arr = mysql_fetch_array($res))&#123; //mysql_fetch_array() 会出现该结果集中的一行数据并赋值给$arr 返回的是关联数组和索引数组的结合 其下标是字段名 //mysql_fetch_assoc() 返回的是关联数组 下标时列名 值对应列值 //mysql_fetch_row() 返回的是只含值得索引数组 //mysql_fetch_object() 返回的是对象,一条记录就是一个对象 // 一个字段就是一个属性 $rwo-&gt;name 访问 //while循环中 会依次取出结果集中的所有数据 直到返回false foreach($arr as $val)&#123; echo $val; //使用foreach循环遍历出每一列的值 &#125; &#125;5.释放资源 mysql_free_result($res)6.关闭数据库连接 mysql_close($link)扩展php中操作mysql数据的几个函数a. mysql_num_rows("结果集") //获取该结果集的行数b. mysql_num_fields("结果集") //获取该结果集的列数c. mysql_field_name("结果集",$i) //获取该结果集的第i个字段名字(i从0开始)其他: mysql_error 获取mysql执行失败时的错误信息 Mysqlimysqli优势 基于面向过程和面向对象的使用 支持预处理语句 支持事务 支持mysql的新功能,新特性,速度更快查看是否开启mysqli phpinfo() extension_loaded(“mysqli”) function_exists(“mysqli_connect”) get_loaded_extensions() 数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//1.连接并选择数据库$mi = @new mysqli("localhost","root","root","stu");//2.如果有错误显示错误信息if($mi-&gt;connect_errno)&#123; //错误编号die("Connect Error".$mi-&gt;connect_error); //错误信息&#125;//3.设置字符编码$mi-&gt;set_charset('utf8');//4.执行单条sql语句$mi-&gt;query($sql)//5.获得新插入操作产生的Auto_increment的值 如果没有 返回0$mi-&gt;insert_id;//6.获得上一次操作产生的受影响的记录条数a.受影响的行数 b. -1(sql出错,执行失败) c. 受影响为0行$mi-&gt;affected_rows;//7.结果集对象的操作a.$res-&gt;num_rows 结果集行数b.$res-&gt;fetch_all(); 默认返回的 索引+索引数组形式 MYSQL_NUM$res-&gt;fetch_all(MYSQLI_ASSOC) 返回的是 索引+关联数组形式$res-&gt;fetch_all(MYSQLI_BOTH) 返回的是 索引+索引和关联都有的形式$res-&gt;fetch_array() 默认返回结果集中的一条数据(数组和关联方式) MYSQLI_BOTH$res-&gt;fetch_array(MYSQLI_ASSOC)$res-&gt;fetch_assoc() 结果集中取出一条 以关联数组显示$res-&gt;fetch_array(MYSQLI_NUM)$res-&gt;fetch_row() 结果集中取出一条 以索引数组显示c.$res-&gt;data_seek(0) 移动结果中指针到具体位置//8.释放结果集资源$mi-&gt;free_result//9.关闭连接$mi-&gt;close()//10.过滤字符串中的特殊字符 防止sql注入$mi-&gt;escape_string()//11.执行多条sql语句 每条语句以分号结束 前一条语句如果失败后面的不会执行$mi-&gt;multi_query($sql)//12.针对多条SQL语句的查询$sql = “select id,username,age from user;”;$sql.=”select current_user();”;$sql.=”select now();”;//use_result()/store_result() 获取第一条查询语句产生的结果集//more_results() 检测是否有更多的结果集//next_result() 将结果集指针向下移动一位If($mi-&gt;multi_query($sql))&#123; do&#123; if($res=$mi-&gt;store_result())&#123; $row[]=$mi-&gt;fetch_all(MYSQLI_ASSOC);&#125;&#125;while($mi-&gt;more_results()&amp;&amp;$mi-&gt;next_result());&#125;else&#123; echo $mi-&gt;error;&#125;//13.预处理语句a 准备预处理语句 防止sql注入 ‘ or 1=1 #$sql = “insert user(uname,upwd,uage) values(?,?,?)”;$mysqli_stmt = $mi-&gt;prepare($sql);$uname = “张三” $upwd = “123” $uage = 18b 绑定参数$mysqli_stmt = $mi-&gt;bind_param(“ssi”,$uname,$upwd,$uage);c 执行预处理语句$mysqli_stmt -&gt;execute()d 预处理查询语句$mysqli_stmt-&gt;bind_result($id,$uname,$age) //绑定结果集的值到变量$mysqli_stmt-&gt;fetch() 遍历结果集//14.事务处理 a 先关闭自动提交功能 $mi-&gt;autocommit(FALSE); $sql = “update account set money=money-200 where uname = ‘king’”; $res = $mi-&gt;query($sql); $affect =$mi-&gt;affected_rows; $sql1 = “update account set money=money+200 where uname = ‘queen’”; $res = $mi-&gt;query($sql1); $affect 1=$mi-&gt;affected_rows; If($res &amp;&amp; $affect&gt;0 &amp;&amp; $res1 &amp;&amp; $affect1&gt;0)&#123; $mi-&gt;commit(); //提交事务 echo “转账成功”; $mi-&gt;autocommit(TRUE); //开启自动提交&#125;else&#123; $mi-&gt;rollback() //事务回滚 echo “转账失败”;&#125; 其他123456789101112131415161718192021222324251.echo 主要用来打印输出字符串和数字(数组和布尔值不适合) 无返回值 true输出1 false无任何输出 null也无任何输出 可以打印多个 速度比print快 print() 和echo差不多 只能打印一个 有返回值1和0 print_r() print_r常用来输出数组 输出的内容包括键和值 不包括数据类型 var_dump() 输出变量的类型和值类型(查看数据结构)值类型和长度 适用于数组和布尔值 printf() 格式化输出字符串 都可以做打印输出用parse_str($str) 将ulr传递的值(字符串)解析成变量ex: $str = "first=value&amp;arr[]=foo+bar&amp;arr[]=baz" ; parse_str($str); echo $first; //valueparse_str($str,$arr) 将ulr传递的值(字符串)解析成变量用数组存起来ex: $str = "first=value&amp;arr[]=foo+bar&amp;arr[]=baz" ; parse_str($str,$arr); echo $arr["first"]; //value echo $arr['arr'][1]; //bazhtmlspecialchars($str) 将字符串转为实体stripslashes($str) 删除斜线strip_tags($str) 从字符串中去除指定的HTML和PHP标记PHP 实现页面跳转 1.header("location:XXX.php") 2.echo "&lt;meta http-equiv='refresh' content='0;url=XXX.php'&gt;";]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php基础1]]></title>
    <url>%2Fphp%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[PHP语言基础 php程序结构 12345a &lt;?php echo "标准结构"; ?&gt; //推荐写法b &lt;? echo "简短风格"; ?&gt; //需修改php.ini文件 short_open_tag=onc &lt;% echo "asp风格" %&gt; //需修改php.ini文件 asp_tags=ond &lt;script language="php"&gt;&lt;/script&gt;php的结束符 ?&gt; 如果后面没有其他代码 可以省略 程序的注释a /*多行注释*/ 不允许嵌套b //或# 单行注释 (php代码每一行都必须以分号;结束) 变量 1234567891011121314151617181920212223242526272829303132333435363738391.变量名以$开始2.变量的名称声明时一定要有意义3.以字母或下划线开头，不能以数字开头，不能有运算符号4.变量的名称区分大小写（驼峰式命名方式） a. var_dump()查看变量的类型和内容(数据结构) b. isset()判断变量是否存在 测试被设置为null的值或unset函数处理过的变量时 返回false empty()判断变量是否为空 "" "0" 0 NULL false array()尽量使用!empty() 判断是否存在 d. unset()删除一个变量(销毁变量名) 断开变量名跟数据之间的引用关系 e. gettype()获取变量类型 boolean integer double string array object resouce NULL f. 判断是否是某类型 is_int() is_bool() is_float() is_object() is_array() is_resource() is_null() is_numeric() is_callable() 是否是有效的函数名常见命名法 1.驼峰命名法 首单词小写 其后每个单词首字母大写 $myName 2.帕斯卡命名法 每个单词首字母大写 $MyName 3.下划线分割法 每个单词小写,之间用下划线分割开 $my_name变量作用域1.全局变量 定义在函数之外，作用于整个PHP文件(内部使用必须用global声明) 声明在调用之前，脚本结束(浏览器关闭)即释放2.局部变量 定义在函数之内或形参，只限于内部使用，在函数外不能被使用 调用几次声明几次，释放(销毁)几次3.静态变量 用static声明，在函数第一次调用结束后仍保留变量值(存在),且不会消失 静态变量的初始化只是在第一次遇到时被执行，以后不再执行初始化操作变量的生存周期即从变量被声明的那一刻起，直到程序脚本运行结束，变量随之释放可变变量使用一个变量的值作为另一个变量的名称 $liubei='河北人';$laoda='liubei';$paihang="laoda";echo $laoda,$$laoda,$$$paihang; // liubei 河北人 河北人引用变量&amp;1.只有变量才有地址，只有变量才能有引用 (引用相当于快捷方式)2.一个变量发生变化，另一个也跟着发生变化3.在使用unset()函数时，如果有引用关系，只是解除了这种引用关系， 只删除一个名字，另一个还在4.如果两个变量是引用关系，一个变，另一个也变，但是如果给其中 一个引用，不是普通的值，而是一个新的引用，则改变引用关系。 八种原始数据类型 1234567891011121314151617181920212223242526272829303132333435363738A:四种标量类型1.布尔型(boolean) 特殊情况下的false:布尔值 false|整数值 0|浮点型 0.0|字符串 "" "0"| 数组 array[]| null值 所有其他值都被认为是true(包括任何资源)2.整型(integer) 整型数可以用八进制，十进制，十六进制来表示 八进制以0开头，十六进制以0x开头 十进制 123 1*100+2*10+3*1 八进制 0123 1*64+2*8+3*1 //23 十六进制 0x123 1*256+2*16+3*1 //291 二进制 是由2位16个字节表示 从右往左依次2的倍数 5 0000 0101 最高位为1时不指定符号则为负数 ~5 //-6 &lt;=(255-5-256) 如果超出int所能表示的最大范围(-2147483648~+2147483647),将会被当做float型处理3.浮点型(float) 浮点型两种格式 标准格式 3.1415 科学计数法 31415e-4 浮点型的数值是一个近似值(不精确)，应尽量避免浮点型之间的比较大小4.字符串(string) 单个字符和多个字符都是字符串，字符串没有长度限制，在单引号中不能使用单引号， 在双引号之间不能使用双引号(除非经过转义字符)B:两种复合类型1.数组(Array)2.对象(Object)C:两种特殊类型1.资源(Resource)2.Null 三种情况 a.没有赋任何值 b.被赋值为null c.被unset()函数处理过的变量伪类型 mixed $a 说明一个参数可以接受多种不同的类型 number $a 说明一个参数可以是int或float callback $a 说明一个参数可以是函数或一个对象的方法数据类型之间的转换1.强制转换 getType(变量);获取变量的类型 强制转换时割舍小数位 a.setType(变量,类型)----将原变量类型给转换了 b.在变量使用时，前面加上类型符号(int)$str---在赋值时给了新变量一个新类型， 原变量类型不变 c.intval() floatval() strval()2.自动转换 小类型自动转化为大类型 字符串会转换为整型或浮点型 布尔型和null会转换为 整型或浮点型字符串转整型时，没有以数字开头时转为0，有数字或科学计数法开头时转为整型数字 布尔型false会输出为空,true会输出为1 常量的声明和使用 12345678910111.常量一旦被声明，这个常量值就不会被改变,不能重新赋值,不能销毁 范围是全局的 只支持4种标量数据类型(bool int float string) 不能使用$符2.使用函数define('常量名'，常量值)声明 使用defined('常量名')判断是否被定义 ex: define("HOST","www.baidu.com",true); defined('host')?1:03.常量名称默认是区分大小写的，习惯上要全大写define(常量名，常量值，true or false) true(不区分大小写) false(默认区分大小写)4.获取常量值 直接使用常量名(不要加$) ROOT 使用constant('ROOT')函数获取 ex: echo host; echo constant("host");5.预定义常量 __FILE__ 获取当前文件的路径(两个下划线) __LINE__获取当前行数 PHP_VERSION 当前PHP服务器的版本引用赋值 $a=&amp;$b 把$b的地址引用赋给$a $a改变$b也改变 PHP 运算符 算术运算符 1234+ - * / %求模的时候正负值取决于被除数的正负++ -- 自增或自减 对于布尔值没有效果 对于字符串自增或自减属于升序或降序$a++或$a-- 先用(赋值)再加 结果不变 ++$a或--$a 先加再用(赋值) 结果加1或减1++$a比$a++ 效率高 $a++ 会分配临时变量来保存 $a 然后再++ 赋值运算符 把右边的值赋给左边的变量或常量 字符串运算符 12连接运算符 ".", 将左右两个字符串连接在一起连接赋值运算符 ".=" 将右边的字符串加到左边的字符串后面 比较运算符 12比较运算符的结果是一个布尔型 &lt; &gt; &lt;= &gt;= ==不等于 != 恒等于 === 值和类型都相同 非恒等于!== 数值不相等或类型不相同 逻辑运算符 12345and或&amp;&amp; 逻辑与 当两边都为true时，才返回true，否则返回falseor或|| 逻辑或 只要有一个为true时，返回true，都为假时才返回falsexor 逻辑异或 当两个操作数一个为真一个为假时，才返回true！ 逻辑非 单一操作数为true，则返回false逻辑运算的短路特性:defined("PI")||define("PI",3.14) 位运算符 1234对二进制位从低位到高位对齐后进行计算&amp; 按位与 | 按位或 ^ 按位异或 ~ 按位取反&lt;&lt; 向左移n位 数字增大2的n次方(乘以2的n次方) &gt;&gt;向右移位 数字减小2倍(除以2)按位运算不会出现短路 三元运算符(条件运算符) 12表达式1？表达式2：表达式3如果表达式1为真则执行表达式2，表达式1为假则执行表达式3 PHP语句程序的3种控制结构 顺序结构 分支(选择)结构 循环结构 条件控制语句 12345678910111213141516171819if语句 if..else语句if(expr)&#123; if(expr)&#123; statement; statement;&#125;只有一条语句时，大括号可以省略 &#125;else&#123; statement; &#125;elseif语句 switch...case语句if(expr1)&#123; switch(变量)&#123; statement1; case 值1:statement1; &#125;elseif(expr2)&#123; break; statement2; case 值2:statement2; &#125;elseif&#123; break; statement3; case 值3:statement3; &#125;else&#123; break; statement4; default:statement; &#125; &#125;a.switch(变量) 变量的类型只能是整型或字符串b.switch case 适合单个值匹配 elseif 适合判断范围时使用c.break是退出switch使用的,如果需要同时匹配多个值可以使用多个case而不加break 循环控制语句 123456 while循环语句 do...while循环语句 for语句 while(expr)&#123; do&#123; for(expr1;expr2;expr3)&#123; statement; statement; statement; &#125;//条件为真假时用while &#125;while(expr); &#125;expr1变量的初始赋值,expr2为循先执行表达式，表达式为 先执行循环体，在判断表 环条件，expr3为变量递增或递减true时，才执行循环体 达式，成立再执行循环体 用于已知循环次数多条件循环操作 跳转控制语句break语句 break n; 指定要跳出几层循环 结束循环结构continue语句 continue n; 指定要跳出几层循环 只能终止本次循环 exit() die()函数是exit()函数的别名 输出一条信息 并退出当前脚本 PHP函数的使用函数是一段完成指定任务的已命名代码块 自定义函数 1234567891011121314151617181920function function_name($arg1,$arg2)&#123; fun_body; return arg_n;&#125;function_name();//函数的调用可以在函数前也可以在函数后面1.函数名要有意义,函数名不区分大小写,不能重复定义，和保留字相同的名称不能使用2.被传入的参数称为实参,而函数定义的参数成为形参,参数可有可无,可以有多个","用逗号分隔3.函数返回值return后面紧跟要返回的一个值 不会直接输出 如果不写return则返回NULL a.可以终止函数后面不执行 b.返回一个结果4.判断函数是否存在 function_exists()函数的参数的传递方式 1.按值传递方式 实参的值不会发生改变 2.按引用传递方式 将实参的内存地址传递给形参,当形参在函数中有任何改变时,实参的值也 会发生变化.如果形参是引用参数,调用函数时,必须传一个变量不能是数值 3.默认参数 默认参数必须放在非默认参数的后面 (实参和形参是按顺序对应传递数据的) 4.不定参数 func_get_args() 将传递给脚本函数的所有参数当作数组返回PHP函数对自身的调用成为递归调用回调函数: 指调用函数时,将另一个函数作为参数传递给调用的函数变量函数：如果将一个函数名称赋给一个变量 在变量后加上()就会调用对应的函数function add()&#123; &#125; $var="add" $var() 系统函数 12345678910引用文件(包含文件)include与require语句的区别1.include调用外部文件只有程序执行到该语句才调用require只要程序一执行,就会立刻调用文件2.调用文件时,若没找到require语句会输出严重错误,立即终止脚本的处理.而include则会输出一个警告,不会终止脚本的运行,后面的可以继续执行include_once与require_once的区别都是确保被包含文件只能被包含一次.避免因多次包含而导致函数的重复定义而产生的错误不同的是在调用外部文件发生错误时,include_once产生一个警告而require_once则导致一个致命错误 常用数学函数 12abs() 绝对值 pow(n,m) n的m次方 max() 求两个以上数的最大值min() 求两个以上数的最小值 rand(n,m) 返回n和m之间的随机数 PHP日期和时间 更改PHP语言中的时区设置 1231.修改php.ini文件中的设置，将date.timezone="Asia/Shanghai",重启Apache服务器2.在程序中添加如下函数 date_default_timezone_get()获取当前时区date_default_timezone_set(PRC或Asia/Chongqing或Asia/Shanghai) 获取当前时间的时间戳 123echo time()."&lt;br /&gt;"; //返回时间戳 1470457489echo microtime()."&lt;br /&gt;"; //0.11247900 1470457489echo microtime(true)."&lt;br /&gt;"; //1470457661.9925微秒的时间戳 计算程序运行的时间 将时间戳格式化 1234date('Y-m-d H:i:s',time()); date("Y年m月d日 H:i:s",time());Y 四位完整的年份 m 表示月份 d 月份中的第几天有前导0l 英文格式星期 N 星期中的第几天H 24小时格式有前导0 i 有前导0的分钟数 s 有前导0的秒数 获取指定日期的时间戳 1234567mktime(int hour,int minute,int second,int mounth,int day,int year);//取得指定日期的时间戳ex: echo mktime(14,35,20,11,27,2016)."&lt;br /&gt;"; //1470381856strtotime();获取英文格式日期时间字符串的时间戳(相对于当前时间)//将英文文本的日期时间转化为unix时间戳ex: strtotime('now'); strtotime('now -1 day') 前一天的时间戳checkdate(int month,int day,int year)检验日期的有效性 PHP图像与图形123456789101112131415161718192021输出图像必须加header('Content-type:image/gif')，屏蔽notice错误(变量未声明导致乱码)1.创建资源(画布) $im=imagecreatetruecolor(300,300)2.设置颜色及填充背景色 $co=imagecolorallocate($im,255,255,255)一般为白色 imagefill($im,0,0,$co)(按是否需要背景色)3.设置绘制图形的颜色 $red=imagecolorallocate($im,255,0,0)4.绘制图像或在图像上写字 imageline($im,100,100,200,200,$red)5.输出或保存图像(iamgegif($im,'image/meizi.gif')) imagegif($im)6.释放资源 imagedestroy($im)imagefill($im,0,0,$co) 区域填充 imagesetpixel($im,100,100,$co) 画一个点imageline($im,100,100,200,200,$co) 画一条线段imagerectangle($im,100,100,200,200,$co) 画一个矩形(填充的矩形imagerfilledectangle)imageellipse($im,100,100,100,150,$co) 画一个椭圆(填充的椭圆imagefilledellipse)imagearc($im,100,100,180,180,0,100,$co) 画一个弧形imagestring($im,5,50,150,'hello world',$co) 水平画一个字符串(垂直画imagestringup)imagettftext($im,字体大小,角度,80,90,$co,字体路径,'文字') 用自定义字体输出文字 PHP异常处理123456789101112131.语法错误 2.运行时错误 3.逻辑错误错误报告及设置级别1.Notice注意级别 2.Warning警告级别 3.Fatal error严重错误级别屏蔽notice错误 error_reporting(E_ALL^E_NOTICE)用户自定义错误格式处理函数set_error_handler("myerrorfun");$mess="";function myerrorfun($error_type,$error_message,$error_file,$error_line)&#123; global $mess; $mess.="发生错误级别为&#123;$error_type&#125;类型,错误消息&#123;$error_message&#125;，在文件 &#123;$error_file&#125;中,第&#123;$error_line&#125;行。"&#125;echo $mess; PHP中的会话控制1234567891011121314151617181920212223242526272829303132333435363738394041Cookie是一种由服务器端发送给客户端的片段信息,存储在客户端浏览器的内存或硬盘 (就好比商场的会员卡,保存在用户手中,在期限内都可以打折)设置cookiesetcookie($name,[$value],[$expire],[$path],[$domain],[$source])setcookie(cookie名称,要存储的值,生存期限,存储路径,指定域名下有效,协议) 协议默认为0(http),1(https)setcookie(‘username’,’Tom’,time()+3600*24*7) 通常只需要设置前三个参数设置数组形式的cookie应用setcookie(‘user[username]’,’Tom’,time()+3600*24*7)setcookie(‘user[userpwd]’,’Tom’,time()+3600*24*7) 注意数组的键不要加引号读取cookie浏览器会将所有的cookie信息存储在$_COOKIE的全局数组中,都去的时候则通过$_COOKIE[‘username’]或$_COOKIE[‘user’][‘username’]获取删除cookiea.将指定的cookie名称的值赋空setCookie(‘username’) 值为空,但名称依然存在$_COOKIE数组中b.将指定cookie设为过期状态setcookie(‘username’,’’,time()-1) 删除指定的cookie值,不会存在$_COOKIE中 注意:不能用unset函数 删除cookie值sessionsession是将数据存放在服务器中,在为web系统中,指用户与web系统的对话过程,即从打开浏览器登录到关闭浏览器的这段时间 (就好比会员卡的卡号由商场保存)在session中,在客户端保存由服务器为用户创建的sessionId,而在服务器端保存变量的值sessionId保存在客户端的cookie中,如果阻止cookie,则可以讲sessionID保存在地址栏url中,通过web请求,把sessionId发送给服务器,然后通过sessionId获取session值,由32位十六进制数组成的字符串session的声明与使用开启会话 session_start() 作用 开启一个会话,返回已经存在的会话 在使用session_start()之前不能有任何的输出,空格或空行都不行session的注册与读取a Session_start() //开启sessionb $_SESSION[‘username’] = ‘Tom’ //注册session变量并赋值读取同样需要先开启session_start() 然后在读取$name=$_SESSION[‘username’]通过session_name()获取session名称 session_id() 获取sessionId注销变量与销毁session删除session中的单个变量Unset($_SESSION[‘username’]) 不要使用unset($_SESSION) 删除整个$_SESSION数组销毁session session_destroy()删除$_SESSION中所有的变量 $_SESSION=array()在cookie中删除sessionId setcookie(session_name,’’,time()-1,’/’)传递sessionId通过URL传递sessionId &lt;a href=”index.php?&#123;session_name()&#125;=&#123;session_id()&#125;”&gt;传递&lt;/a&gt; PHP正则表达式123456789101112131415161718192021222324252627282930313233正则表达式就是一个匹配模式的字符串,必须在函数中使用正则表达式的组成1.定界符 多种都可以常用为("/../")除了字母、数字、\以外的字符2.原子 最小的一个匹配单位(放在定界符内)必须有一个3.元字符 不能单独使用，修饰原子，用来扩展原子功能和限定功能4.模式修正符 对模式(正则)修正,作用整个表达式(写在定界符外)原子:打印字符(a-z A-Z 0-9%)和非打印字符转义字符:A 可以将有意义的字符转义成普通字符 \^ B 可以将没有意义的字符转成有意义的原子 \t预定义字符集 \D非数字字符 \d数字 \W非单词字符 \w单词字符 \S非空白字符 \s空白字符自定义原子表 [13579] [a-zA-Z]元字符: * 匹配前面的字符(原子)出现零次、一次或多次 + 匹配前面的字符出现1次或多次,至少出现一次 ？ 匹配前面的字符出现零次或1次,不可出现多次 &#123;n&#125; 匹配前面的字符只能出现n次 &#123;n,&#125; 匹配前面的字符最少出现n次 &#123;n,m&#125;匹配前面的字符最少出现n次,最多出现m次 | 表示或的关系,它两边的原子只要有一个出现就可以 ^或\A 表示必须以什么开始，必须写在最前面 $或\z 表示必须以什么结尾，必须写在定界符最后面 () 改变限定符的作用范围 子模式 反向引用 [] 只能匹配单个字符 - 表示字符的范围 . 可以匹配出换行符以外的任意一个字符 [^] 表示排除的意思模式修正符 i 修正正则表达式不区分大小写 m 修正正则表达式可视为多行 s 可以使 . 匹配换行符 x 可以使正则表达式忽略空白 g 查找所有可能的匹配结果可以是多个preg_match()正则查找 preg_split()正则分割 preg_replace()正则替换]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生ajax封装]]></title>
    <url>%2F%E5%8E%9F%E7%94%9Fajax%2F</url>
    <content type="text"><![CDATA[Ajax 即“Asynchronous Javascript And XML”(异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 原生ajax封装及使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var $ = &#123; //将对象转换成字符串 用于拼接参数 params: function(obj) &#123; var str = "" for (var key in obj) &#123; str += key + "=" + obj[key] + "&amp;" &#125; //组装的字符串多了一个&amp;,截取之后返回一个新的字符串 str = str.substr(0, str.length - 1) //username=zhangsan&amp;age=11&amp;sex=nan return str &#125;, ajax: function(obj) &#123; //1:创建对象 var xhr = new XMLHttpRequest(); //将 对象=&#123;username:"zhangsan",age:11,sex:"nan"&#125; 转换成 字符串的格式 username=zhangsan&amp;age=11&amp;sex=nan if (obj.beforeSend) &#123; //因为用户在调用的时候，可能没有传递,所以需要进行判断. var flag = obj.beforeSend() if (flag == false) &#123; return &#125; &#125; //对obj.data 的类型进行判断，如果是对象类型，我才去进行处理. if (typeof obj.data == "object") &#123; obj.data = this.params(obj.data) &#125; //2:打开对象 //注意：如果是get 方式提交，参数在地址的后面 if (obj.type.toLowerCase() == "get") &#123; obj.url = obj.url + "?" + obj.data obj.data = null &#125; xhr.open(obj.type, obj.url) //注意：处理post 我们需要给一个请求头 if (obj.type.toLowerCase() == "post") &#123; xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); &#125; //3:发送数据 xhr.send(obj.data) //4:接收数据 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; //响应完成 if (xhr.status == 200) &#123; //响应成功 var data = xhr.responseText obj.success(data) &#125; else &#123; obj.error &amp;&amp; obj.error() &#125; obj.complete &amp;&amp; obj.complete() &#125; &#125; &#125;&#125;;$.ajax(&#123; url:"../ajax.php", type:"POST", data:&#123; username:"zhangsan", age:11, sex:"nan" &#125;, //设置一个过滤器,这个也是一个回调函数. 请求发送之前调用. beforeSend:function()&#123; console.log("请求发送之前调用") //我们可以在这里去对发送到服务器的数据进行一些校验，正则校验 //如果验证不通过，就不发送请求了 return true &#125;, //这个是一个回调函数，数据响应成功的时候调用 success:function(info)&#123; console.log(info) console.log("数据响应成功调用") &#125;, //请求完成的时候调用. 我是想给用户一些提示.不管成功还是失败 complete:function()&#123; console.log("请求完成的时候去调用") &#125;, //请求出错的时候调用 error:function(err)&#123; console.log(err) console.log("请求出错的时候调用") &#125;&#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet插件用法(二)]]></title>
    <url>%2FEmmet%E6%8F%92%E4%BB%B6%E7%94%A8%E6%B3%95(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Emmet(前身是Zen Coding)是前端开发快速输入代码一种方式，它可以极大的提高代码编写的效率，它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。用和 CSS 选择器相似的语法来描述元素的嵌套层级关系和属性，实现 HTML/XML/CSS 等代码的智能自动补全。 CSS常用语法 常用基本css语法 12345678910111213141516171819202122/* por */ &#123; position: relative &#125;/* psa */ &#123; position: absolute &#125;/* psf */ &#123; position: fixed &#125;/* pss */ &#123; position: static &#125;/* fll */ &#123; float: left &#125;/* flr */ &#123; float: right &#125;/* cl */ &#123; clear: both &#125;/* di */ &#123; display: inline &#125;/* db */ &#123; display: block &#125;/* dib */ &#123; display: inline-block &#125;/* df */ &#123; display: flex &#125;/* ov */ &#123; overflow: hidden &#125;/* ov:s */ &#123; overflow: scroll &#125;/* ova */ &#123; overflow: auto &#125;/* mt */ &#123; margin-top: 10px &#125;/* mb */ &#123; margin-right: 10px &#125;/* mr */ &#123; margin-bottom: 10px &#125;/* ml */ &#123; margin-left: 10px &#125;/* pt */ &#123; padding-top: 10px &#125;/* pb */ &#123; padding-right: 10px &#125;/* pr */ &#123; padding-bottom: 10px &#125;/* pl */ &#123; padding-left: 10px &#125; border和background常用语法 123456789101112/* bd */ &#123; border: 1px solid #000 &#125;/* bdcl */ &#123; border-collapse: collapse &#125;/* bdt */ &#123; border-top: 1px solid #000 &#125;/* bdb */ &#123; border-bottom: 1px solid #000 &#125;/* bdl */ &#123; border-left: 1px solid #000 &#125;/* bdr */ &#123; border-right: 1px solid #000 &#125;/* bdrs */ &#123; border-radius: 10px &#125;/* bgs */ &#123; background-size: contain &#125;/* bgc */ &#123; background-color: #fff &#125;/* bgp */ &#123; background-position: 0 0 &#125;/* bgi */ &#123; background-image: url() &#125;/* bgr */ &#123; background-repeat: no-repeat &#125; text文字类语法 1234567891011121314151617/* fw */ &#123; font-weight: normal &#125;/* fsn */ &#123; font-style: normal &#125;/* fz */ &#123; font-size: 10px &#125;/* ff */ &#123; font-family: serif &#125;/* va */ &#123; vertical-align: top &#125;/* ta */ &#123; text-align: left &#125;/* tac */ &#123; text-align: center &#125;/* tar */ &#123; text-align: right &#125;/* taj */ &#123; text-align: justify &#125;/* td */ &#123; text-decoration: none &#125;/* ti */ &#123; text-indent: 2em &#125;/* ts */ &#123; text-shadow: hoff voff blur #000 &#125;/* lh */ &#123; line-height: 10px &#125;/* ls */ &#123; letter-spacing: normal &#125;/* whs */ &#123; white-space: nowrap &#125;/* wb */ &#123; word-break: normal &#125;/* ws */ &#123; word-spacing: 10px &#125; 其他常用语法 12345678910111213141516171819202122232425262728293031323334/* bxz */ &#123; box-sizing: border-box &#125;/* bxsh */ &#123; box-shadow: inset hoff voff blur #000 &#125;/* w10 */ &#123; width: 10px &#125;/* h10 */ &#123; height: 10px &#125;/* w100p */ &#123; width: 100% &#125;/* cr */ &#123; cursor: pointer &#125;/* c */ &#123; color: #fff &#125;/* ol */ &#123; outline: none &#125;/* lis */ &#123; list-style: none; &#125;/* op */ &#123; opacity: 1 &#125;/* op */ &#123; opacity: 1 &#125;/* ! */ &#123; display: none !important;&#125;/* anm */ &#123; animation: name duration timing-function delay iteration-count direction fill-mode &#125;/* trfr */ &#123; transform: rotate(angle) &#125;/* trf */ &#123; transform: '' &#125;/* trft */ &#123; transform: translate(x, y) &#125;/* trfo */ &#123; transform-origin: 0 &#125;/* trs */ &#123; transition: prop time &#125;/* @kf */ @keyframes/* lg */ &#123; background-image: linear-gradient() &#125;/* 单位: p-&gt;% e-&gt;em r-&gt;rem x-&gt;ex */&#123; /* w100 */ width: 100px; /* 数值默认单位px */ /* w100p */ width: 100%; /* w100e */ width: 100em; /* w100x */ width: 100ex;&#125;/* 色值: #6-&gt;#666666 #fc-&gt;#fcfcfc #fc0-&gt;#ffcc00 */&#123; /* c#6 */ color: #666666; /* c#fc */ color: #fcfcfc; /* c#fc0 */ color: #ffcc00;&#125;/* 多个值 m10p-20r-30e-40x */ &#123; margin: 10% -20rem -30em -40ex; &#125; 参考链接emmet查询地址快速生成html标签和css快捷键]]></content>
      <categories>
        <category>Emmet</category>
      </categories>
      <tags>
        <tag>Emmet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet插件用法(一)]]></title>
    <url>%2FEmmet%E6%8F%92%E4%BB%B6%E7%94%A8%E6%B3%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Emmet(前身是Zen Coding)是前端开发快速输入代码一种方式，它可以极大的提高代码编写的效率，它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。用和 CSS 选择器相似的语法来描述元素的嵌套层级关系和属性，实现 HTML/XML/CSS 等代码的智能自动补全。 快速生成html结构语法 &gt; 快速生成子元素 123456&lt;!-- nav&gt;ul&gt;li --&gt;&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; + 生成并列同级元素 1234&lt;!-- header+section+footer--&gt;&lt;header&gt;&lt;/header&gt;&lt;section&gt;&lt;/section&gt;&lt;footer&gt;&lt;/footer&gt; ^ 返回父层元素,可以多层 123456&lt;!-- header+setion&gt;p&gt;i+em^^footer --&gt;&lt;header&gt;&lt;/header&gt; &lt;setion&gt; &lt;p&gt;&lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;/setion&gt;&lt;footer&gt;&lt;/footer&gt; * 生成重复的元素 123456&lt;!-- ul&gt;li*3 --&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; () 生成复杂的组合 12345678910&lt;!-- header+(setion&gt;dl&gt;(dt+dd*2))+footer --&gt;&lt;header&gt;&lt;/header&gt; &lt;setion&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/setion&gt;&lt;footer&gt;&lt;/footer&gt; .或# 使用.和#来生成ID和CLASS属性 1234&lt;!-- div#header+div.page+div#footer.class1.name --&gt;&lt;div id="header"&gt;&lt;/div&gt;&lt;div class="page"&gt;&lt;/div&gt;&lt;div id="footer" class="class1 name"&gt;&lt;/div&gt; [] 使用中括号来自定义需要的属性 1234&lt;!-- td[title colspan data] --&gt;&lt;td title="" colspan="" data=""&gt;&lt;/td&gt;&lt;!-- td[title='hello' colspan='3' data='12'] --&gt;&lt;td title="hello" colspan="3" data="12"&gt;&lt;/td&gt; {} 生成标签内的内容 12&lt;!-- a&#123;百度一下&#125;+b&#123;你就知道&#125; --&gt;&lt;a href=""&gt;百度一下&lt;/a&gt;&lt;b&gt;你就知道&lt;/b&gt; $ 自动生成连续的编号,可以多个 123456789101112131415161718&lt;!-- ul&gt;li.item$&#123;item$$&#125;*3 --&gt;&lt;ul&gt; &lt;li class="item1"&gt;item01&lt;/li&gt; &lt;li class="item2"&gt;item02&lt;/li&gt; &lt;li class="item3"&gt;item03&lt;/li&gt;&lt;/ul&gt;&lt;!-- 从指定的数字开始编号 ul&gt;li.item$@3&#123;item$@2$@5&#125;*3 --&gt;&lt;ul&gt; &lt;li class="item3"&gt;item25&lt;/li&gt; &lt;li class="item4"&gt;item27&lt;/li&gt; &lt;li class="item5"&gt;item29&lt;/li&gt;&lt;/ul&gt;&lt;!-- 指定反向编号 ul&gt;li.item$@-3&#123;item$@2$@-5&#125;*3 --&gt;&lt;ul&gt; &lt;li class="item5"&gt;item29&lt;/li&gt; &lt;li class="item4"&gt;item27&lt;/li&gt; &lt;li class="item3"&gt;item25&lt;/li&gt;&lt;/ul&gt; 对于特定的结构可以省略html标签,采用默认的标签 123456789101112131415161718192021222324&lt;!-- .warp&gt;p&gt;.text --&gt;&lt;div class="warp"&gt; &lt;p&gt;&lt;span class="text"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- ul&gt;.item --&gt;&lt;ul&gt; &lt;li class="item"&gt;&lt;/li&gt; &lt;li class="item"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- table&gt;(.col&gt;.item*2)*3 --&gt;&lt;table&gt; &lt;tr class="col"&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class="col"&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class="col"&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;td class="item"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; lorem 快速生成大段文本(占位文字) 123456789&lt;!-- lorem + Tab --&gt;&lt;td&gt;Lorem ipsum dolor, sit amet consectetur adipisicing elit. Dicta, repellat rem. Inventore itaque illo saepe aut optio architecto esse porro nisi placeat, ratione eos voluptas, totam est quia recusandae vero!&lt;/td&gt;&lt;!-- ul&gt;lorem10.item*2 每一组多少个单词 --&gt;&lt;ul&gt; &lt;li class="item"&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt, dolorem.&lt;/li&gt; &lt;li class="item"&gt;Vero excepturi fugiat repudiandae. Qui at consequatur ut soluta! Cumque.&lt;/li&gt;&lt;/ul&gt; HTML常用快捷语法 ! 快速生成html5结构 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; link 快速生成 link类的标签 1234&lt;!-- link --&gt;&lt;link rel="stylesheet" href=""&gt;&lt;!-- link:favicon --&gt;&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"&gt; meta 快速生成 meta标签 123456&lt;!-- meta:utf --&gt;&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt;&lt;!-- meta:utf --&gt;&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;&lt;!-- meta:vp --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; script 快速生成script标签 12&lt;!-- script:src --&gt;&lt;script src=""&gt;&lt;/script&gt; input 快速生成表单元素 12345678910111213141516&lt;!-- inp --&gt;&lt;input type="text" name="" id=""&gt;&lt;!-- input:b --&gt;&lt;input type="button" value=""&gt;&lt;!-- input:p --&gt;&lt;input type="password" name="" id="" /&gt;&lt;!-- input:number --&gt;&lt;input type="number" name="" id=""&gt;&lt;!-- input:c --&gt;&lt;input type="checkbox" name="" id=""&gt;&lt;!-- input:r --&gt;&lt;input type="radio" name="" id=""&gt;&lt;!-- input:f --&gt;&lt;input type="file" name="" id=""&gt;&lt;!-- input:s --&gt;&lt;input type="submit" value="" /&gt; btn 快速生成button 123456&lt;!-- btn --&gt;&lt;button&gt;&lt;/button&gt;&lt;!-- btn:s --&gt;&lt;button type="submit"&gt;&lt;/button&gt;&lt;!-- btn:r --&gt;&lt;button type="reset"&gt;&lt;/button&gt; 参考链接emmet查询地址快速生成html标签和css快捷键]]></content>
      <categories>
        <category>Emmet</category>
      </categories>
      <tags>
        <tag>Emmet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的ajax]]></title>
    <url>%2FjQuery%E4%B8%AD%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[jQuery库拥有完整的Ajax兼容套件。其中的函数和方法允许我们在不刷新浏览器的情况下从服务器加载数据,jQuery中有多种ajax的请求方式,例如load(),$.ajax(),$.get(),$.post(),$.getJson()等 $(selector).load()$(selector). load( url,data,function(response,status,xhr) )load()方法通过AJAX请求从服务器加载数据,并把返回的数据放置到指定的元素中,默认get请求. url 规定要将请求发送到哪个 URL。 data 可选。规定连同请求发送到服务器的数据。 function(response,status,xhr) 可选。规定当请求完成时运行的函数。参数：response ­ 包含来自请求的结果数据 status 包含请求的状态 xhr 包含 XMLHttpRequest 对象 123456//把hello.txt的文本内容加载至$('#box');$('#box').load('hello.txt', function(response,status,xhr)&#123; console.log(response) console.log(status) console.log(xhr)&#125;); $.get()$(selector).get(url,data,success(response,status,xhr),dataType)get()方法通过远程HTTP GET请求载入信息 url 必需 规定请求的url data 可选 规定发送请求的数据 success(response, status, xhr) 可选 请求成功时的回调函数 dataType 可选 规定服务器响应返回的数据类型 123$.get('hello.txt', function (data) &#123; console.log(data)&#125;) $.post()$(selector).post(url,data,success(response,status,xhr),dataType)post()方法通过远程HTTP POST请求从服务器载入数据 url 必需 规定请求的url data 可选 规定发送请求的数据 success(response, status, xhr) 可选 请求成功时的回调函数 dataType 可选 规定服务器响应返回的数据类型 123$.post('order.php', &#123; id: '1000'&#125;, function (data) &#123; console.log(data)&#125;) $.getJSON()$(selector).getJSON(url,data,success(response,status,xhr))getJSON()方法通过远程HTTP GET请求载入JSON数据 url 必需 规定请求的url data 可选 规定发送请求的数据 success(response, status, xhr) 可选 请求成功时的回调函数 123$.getJSON('order.php', &#123; id: '1000'&#125;, function (data) &#123; console.log(data)&#125;) $.ajax()$.ajax()方法是JQuery将Ajax数据请求进行了封装，并指明请求的方式、地址、数据类型，以及回调方法等。 url 必需 发送请求的url地址 type 请求类型 (“POST” 或 “GET”等)， 默认为 “ GET “。 async 是否异步 默认为true(即请求均为异步),false 设置请求为同步,操作必须等请求完成才可继续执行 data 发送到服务器的数据 get请求会附加在地址栏上 beforeSend 发送请求前修改XHR对象,如自定义HTTP头 complete 当请求完成时调用函数—不管成功还是失败都会调用 dataType 预期服务器返回的数据类型 (xml,json,xml,text,html等) cache 默认为true,设置为false将不缓存请求信息 timeout 设置请求超时时间(毫秒) success 请求成功回调函数 error 请求失败回调函数 xhrFields: {withCredentials: true} 通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。 crossDomain: true 12345678910111213141516171819202122232425262728293031323334$('#send').click(function()&#123; $.ajax(&#123; type: "POST", url: "XXX.php", data: &#123;username:$("#username").val(), content:$("#content").val()&#125;, dataType: "json", timeout: 30000, beforeSend: function()&#123; // 设置请求头 request.setRequestHeader("BBG-Key", "ab9ef204-3253-49d4-b229-3cc2383480a6"); // 防止重复提交 $("#submit").attr(&#123; disabled: "disabled" &#125;); // 设置loading $("loading").show(); &#125;, success: function(data)&#123; $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function(commentIndex, comment)&#123; html += '&lt;div class="comment"&gt;&lt;h6&gt;' + comment['username'] + ':&lt;/h6&gt;&lt;p class="para"' + comment['content'] + '&lt;/p&gt;&lt;/div&gt;'; &#125;); $('#resText').html(html); &#125;, error: function(err)&#123; console.log(err) &#125;, complete: function()&#123; // 不管成功还是失败都会调用 // 关闭loading $("loading").show(); &#125; &#125;);&#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记]]></title>
    <url>%2FjQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery 概述123456789101112131415161718192021优势: 1.强大的选择器 2.出色的浏览器兼容性 3.方便的链式操作 4.出色的DOM操作的封装 5.完善的Ajax引入jquery &lt;script src="js/jquery.js"&gt;&lt;/script&gt; &lt;script src="http://apps.bdimg.com/libs/jquery/1.11.1/jquery.js"&gt; 百度静态资源库 采用cdn加速 本地载入速度快`测试是否引入成功 alert($); $=jquery`window.onload 等网页中所有资源(图片,flash,gif等)加载完后才执行 只执行最后一个$(document).ready() 等dom树加载完毕后就可以执行 可写多个 简化$(function()&#123;&#125;)DOM对象不能使用任何jquery中的方法,只能使用DOM中的方法jquery对象转成DOM对象方法 1.使用index $(input)[0].value 2.使用get(index) $(input).get(0).valueDOM对象转换成jquery对象 只要把DOM对象用$()包起来就可以了 $(input).val()取值和赋值合体 html() 取值 html("hello") 赋值`注: 当选择对象是一组元素时 取值取的是一组中的第一个元素 当选择对象是一组元素时 赋值时是一组中的所有元素`jQuery与其他js类库共存 名称冲突1.jQuery使用$符号作为jQuery的简介方式 其他库中函数同样使用$ jQuery使用名为noConflict()方法来解决该问题(释放$权) var jq=jQuery.noConflict(),帮助您使用自己的名称(比如jq)来代替$符号。2.改变引入的先后顺序 $()的四大调用方式 $(function(){}) 文档加载完毕执行函数等同于DOMContentLoaded $(selector) 获取选中的selector(css选择器)元素 $(element) 传递一个Element,document,window等原生js对象会转化为jQuery对象 $(&lt;tag&gt;&lt;/tag&gt;, object) 创建元素 tag是要创建的元素带&lt;&gt;的标签字符串 object是一个对象,对象里面可以设置创建元素的属性或data或事件 12345678910// 方式一$('&lt;div&gt;', &#123;text: '创建元素',class: 'box',css: &#123; background: 'red', color: '#fff', height: 100, width: 100 &#125;,click: function () &#123; alert(11) &#125;&#125;).appendTo($('body'))// 方式二$('&lt;div class="test" onclick="fn1()" style="color:pink"&gt;创建元素&lt;/div&gt;').appendTo($('body'))function fn1()&#123; alert(2222) &#125; 选择器引擎返回代理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889jquery选择器兼容任何版本的浏览器1.选择器 A 基本选择器 a.Id选择器 返回单个元素 b.类名选择器 c.标签选择器 B 层次选择器 a.E F 选择E元素所有的后代元素 b.E&gt;F 选择E元素的子元素 c.E+F 选择E元素后紧邻的兄弟元素 可以用next()代替 d.E~F 选择E元素后所有后代元素 可以用nextAll()代替 C 过滤选择器 ①基本过滤选择器(过滤选择器以:开头) a :first 选取第一个元素 b :last 选取最后一个元素 c :not(selector) 选取除指定选择器外的元素(选择器不要加引号) d :even 偶数选择器 e :odd 奇数选择器 f :eq() 选取指定索引的元素 g :gt() 选取大于指定索引的元素 h :lt() 选取小于指定索引的元素 i :header 选取h1~h6标题标签 j :animated 选取正在执行动画的元素 ②内容筛选 a :contains(text) 选取含有指定文本的元素 b :has(selector) 选取含有指定后代选择器的元素 c :empty 选取不包含子元素或文本元素的元素(注意换行被解析为空文本元素) d :parent 选取含有子元素或文本元素的元素 ③可见性筛选 a :hidden 选取所有不可见元素(不占位置的) `注 在网页中看不到的元素 元素不占有空间 opacity:0和visibility:hidden获取不到` b :visible 选取所有可见的元素 ④属性选择器 元素[sttr] a [attr] 选取拥有此属性的元素 b [attr="value"] 选取指定属性值的元素 c [attr*="value"] 选取属性包含指定字符的元素 d [attr^="value"] 选取属性以指定字符开头的元素 e [attr$="value"] 选取属性以指定字符结尾的元素 f [attr!="value"] 选取属性中不包含指定字符的元素 g [attr1="value"][attr2="value"] 选取多个属性的元素 h [attr|="value"] 选取属性值中以指定前缀的元素 ⑤子元素筛选 a :first-child 选择父元素的第一个子元素 b :last-child 选择父元素的最后一个子元素 c :only-child 选择元素中只包含一个子元素的元素 d :nth-child(n|even|odd) 选择父元素的第N个元素遵从css规范(n从1开始) ⑥表单属性选择器 a :disabled 选择所有不可用的元素 b :checked 选择所有选中的元素(单选框,复选框) c :selected 选择所有被选中的选项的元素(下拉框) d :focus 选择当前获得焦点的元素 e :enabled 选择所有可用的元素 D 表单元素选择器 :input :button :text :password :radio :checkbox :submit :image :file :reset (不支持 :textarea获取文本域 :select获取下拉框) `注 :input选择的是所有表单元素包括 input textarea select`2.筛选方法 a eq(index) 选择指定索引的元素 b filter(选择器) 从匹配的元素集合中选择指定选择器或表达式的元素(针对元素本身) c not(选择器) 从匹配的元素集合中移除指定的元素(针对元素本身) c first() 选择第一个元素 d last() 选择最后一个元素 e is(selector) 检测元素是否返回布尔值 f has() 包含指定后代的元素 h slice(n,m) 根据指定的下标范围(不包括m),选择匹配的元素的集合 i index() 索引就是当前元素在所有兄弟节点中的位置 `注:选择器 主要用在选择DOM对象上 筛选DOM方法 主要用在链式操作上 `3.遍历查找 a children("选择器") 选择子元素 b parent() 选择父元素 parents("选择器") 选择祖先元素 closest("选择器") 取得最近的匹配元素逐级向上查找父元素 offsetParent() 获取有定位的父级 c prev() 选择紧邻的前一个兄弟元素 d next() 选择紧邻的后一个兄弟元素 e siblings() 选择前后所有的兄弟元素 f end() 返回到最初匹配的元素 g find() 选择匹配元素集合中所有后代元素 h each() 遍历每个jquery对象 为每个元素执行一个函数 // ex:$("li").each(function(index,elem)&#123;&#125;) index下标 elem元素 i size() 获取一组元素的长度(相当于length)4.选择器的优化 a 优先使用id选择器 b 在class选择器前添加标签名 c 采用find(),而不使用上下文查找 d 使用强大的链式操作比缓存更快 注: 选择器中含有特殊字符的处理需要\\转义 $("#id\\#b") 批量操作dom以及dom树结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778791.属性的操作 a. 获取元素的属性 attr(name) name属性的名称 b. 设置元素的属性 attr(key,value) 设置多个属性值 attr(&#123;key0:value0,key1:value2&#125;) c. 删除元素的属性 removeAttr(name) 删除指定的属性(name必选) `注:prop() 用来处理布尔值的属性或不存在的属性,添加属性名称就会生效时使用 ` `选中判断 1. obj.attr('checked') 2. obj.prop('checked') 3. obj.is(':checked')`2.元素的内容操作 a.html() 只获取第一个匹配元素的HTML内容 html(val) 会设置所有匹配元素的HTML内容 b.text() 获取元素的文本内容(会获取一组元素所有的文本) text(val) 设置元素的文本内容 `注: html()方法仅支持Xhtml的文档 不能用于XML文档 而text()都支持` c.val() 获取或设置元素的value值 val("") 清空值 val("aaa") 设置值 val([]) 设置select radio checkbox 选项被选中 val(["chk1","chk2"]) 是从最后一个选项往前读取 如果选项的value值或者text中任意一项符合就会被选中3.元素样式的操作 a. css("name") 获取元素的指定的样式 css("name","vaue") 设置元素的指定的样式 css(&#123;"name1":value1,"name2":value2&#125;) 设置多个样式 `注: 如果值是数字 将会被自动转化为像素值 如果属性中带有"-"符号 不用引号则要采用驼峰命名法 fontSize 如果用引号则"font-size"和"fontSize"都可以` b. addClass(class) 为元素追加class类 addCalss(class class1 ...) 添加多个class类 c. toggleClass() 切换不同的元素类别 d. removeClass([class]) 删除指定的类别 `可选多个 用空格分开 如果不选名称则删除元素中所有类别` e. hasClass("class") 判断元素中是否含有某个样式 f. is(".classname") 判断元素中是否是某个样式 g 其他样式的获取 height() 获取或设置元素的高度 width() 获取或设置元素的宽度 offset() 获取元素到屏幕的左距离或右距离(只对可见元素有效) offset().left offset().top position().left position().top 到有定位的父级 scrollTop() 获取或者设置元素的滚动条距顶端的距离 scrollLeft() 获取或者设置元素的滚动条距左端的距离 当有多个class的使用可以用 addClass或removeClass 操作指定的class 当只有一个的时候,可以操作attr('class','acitve') 覆盖掉原来的class4.元素的节点操作 ①创建节点 a.用$()来创建节点 var newElement = $("&lt;div&gt;div标签&lt;/div&gt;") b.用字符串来创建节点 var newElement = "&lt;div&gt;div标签&lt;/div&gt;" ②插入节点 a. append(content) append(function(index,html)&#123;&#125;) 将函数的返回的内容追加到元素内部的末尾 appendTo(Tag) 向元素的内部末尾出插入内容 b. prepend(content) prependTo(Tag) 向元素的内部前面插入指定内容 c. after(content) 在匹配元素外部后面插入内容 d. before(content) 在匹配元素外部前面插入内容 e. insertAfter(Tag) 将所选择的元素插入另一个指定的元素的外部后面 f. insertBefore(Tag) 将所选择的元素插入另一个指定的元素的外部前面 ③复制节点 $("").clone().appendTo() 复制匹配的DOM元素本身 $("").clone(true).appendTo() 复制本身并将该元素的全部行为事件也复制 ④替换节点 a. replaceWith(content) 替换节点 将所选择的元素替换成指定的HTML或DOM元素 用括号中的字符替换所选择的元素 b. replaceAll(Tag) 替换节点 将Tag替换成指定的内容(Tag被替换的元素) 用字符串替换括号中所选择的元素 `注:一旦被替换,被替换的元素的全部事件都消失` ⑤包裹节点 a. wrap(html\elem\fn) 把所选择的元素用指定的HTML或DOM 包裹起来(外包装) b. unwrap()无参数 移除所选元素的父元素或包裹标记 c. wrapAll() 将所选元素用单个元素或DOM元素包裹起来(会改变dom节点结构) d. wrapInner() 将所选元素的子内容(包括文本节点)用指定内容包裹起来(内包装) ⑥遍历节点 $("p").each(function(index)&#123; this.title="第"+index+"个P"; &#125;) ⑦删除节点 a. remove() 删除指定的元素所包含的所有后代元素也一起被删除 返回指向被删除节点的引用可以继续使用但是其事件都不存在 b. detach() 删除指定的元素,返回结果是被删除元素但保留其操作方法(事件) c. empty() 清空元素里的全部节点或节点所包括的后代元素 `注: add() 将节点组合在一起` 处理事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.事件绑定 on或bind a. $("").click(fn); b. $("").bind("事件类型",[event.data],fn) $("").bind("click dblclick",function()&#123;&#125;) $("").bind(&#123;focus:function()&#123;alert(111);&#125;, c. $(document).on(events,[selector],[data],fn); events 一个或多个事件 多个事件用空格分割 selector 选择器元素 data 事件触发传递event.data参数给事件处理函数 fn 事件触发时执行的函数 `注: 可以为动态创建或生成的元素添加事件` $("p").on(&#123; mouseover:function()&#123;$("body").css("background-color","lightgray");&#125;, mouseout:function()&#123;$("body").css("background-color","lightblue");&#125;, click:function()&#123;$("body").css("background-color","yellow");&#125; &#125;);2.事件切换 a. hover(over,out) 当鼠标移动到所选的元素上时(mouseover)执行第一个函数 当鼠标移出这个元素(mouseout)执行第二个函数 ex: $("p:eq(1)").hover(function()&#123; $("#hi").show(); &#125;,function()&#123; $("#hi").hide() &#125;); b. toggle() 每次单击后依次调用函数通过函数设置的前后顺序进行调用 toggle(fn,fn2,[fn3]....) 依次调用fn函数3.移除事件 unbind(type,[fn])或off(type,[fn]) 移除元素绑定的事件 参数type为移除的事件类型,fn为需要移除的事件处理函数,如果没有参数 则移除所有绑定的事件.如果有参数fn则只移除绑定时指定的函数fn4.其他事件 a. one(type,[fn]) 为所选元素绑定一个仅触发一次的函数 ex: $("").one("click",function()&#123;&#125;); b. trigger(type) 在所选择的元素上触发指定类型的事件(自动触发) ex: $().trigger("select"); ex: otxt.bind("a",function()&#123; $("#divtop").html($(this).val()); &#125;).trigger("a"); 自动触发自定义事件5.事件对象的属性 a. e.type() 获取事件的类型 b. e.stopPropagation() 阻止冒泡事件(事件从里向外传递) c. e.preventDefault() 阻止默认行为 return false 同时阻止默认事件和冒泡事件 d. e.target() 获取到触发事件的元素(事件目标或事件源) e. e.pageX()/e.pageY 获取到光标相对于文档的x坐标和y坐标 e. clientX/e.clientY 获取到光标相对于可视区的x坐标和y坐标 f. e.which() 获取键盘键值或鼠标按下的左 中 右健的那个键 1=鼠标左键 left 2=鼠标中键 3=鼠标右键 g. e.data() 事件中传输的数据 ex: $().on("click",&#123;name:'hello'&#125;,function(ev)&#123; alert(ev.data.name); //hello &#125;)6.事件委托 a. delegate() 利用冒泡实现 好处 1.省略循环操作 2.对后添加元素直接拥有事件操作 ex: $("ul").delegate("li","click",function()&#123;&#125;) b. undelegate() 取消事件委托 c. on() 常用于动态添加的元素使用 ex: $('#div1').on('click','li',function()&#123; alert('ok'); &#125;) $('#div1').append($('&lt;li&gt;new&lt;/li&gt;')); 执行动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521.hide()和show() 显示或隐藏html元素 hide(speed,callback) show(speed,callback) 可选参数speed 速度 ("slow","normal","fast",1000) 其对应的速度分别是0.6秒 0.4秒 0.2秒 可选参数callback 显示或隐藏完成后执行的函数 ex $("#test").hide(3000,function()&#123;alert(1111);&#125;);2.toggle() 切换hide()和show()方法 toggle(speed,[callback]); ex $("#test").toggle(3000,function()&#123;alert("已隐藏");&#125;);3.淡入淡出 a. fadeIn() 实现淡入已隐藏元素 fadeIn(speed,callback) b. fadeOut() 实现淡出可见元素 fadeOut(speed,callback) c. fadeToggle() 实现fadeIn与fadeOut之间的切换 ex $("#test").toggle(2000); d. fadeTo() 方法允许渐变为给定的透明度 ex $("#test").fadeTo(2000,0.6);4.滑动 a. slideDown() 用于向下滑动元素 b. slideUp() 用于向上滑动元素 c. slideToggle()在slideDown()与slideUp()之间进行切换5.animate 自定义动画 animate(params,[duration],[easing],[callback]) 参数params 表示用于制作动画效果的属性样式和值的集合 可选[duration]表示速度 [easing]控制动画的表现效果 [callback]动画完成执行的回调函数 a 简单的动画 ex :$("#test").animate(&#123;height:"100px"&#125;,1000); b 移动位置的动画 ex: $(this).animate(&#123;left:"500px",top:"300px"&#125;,3000) 1.要使页面中的元素移动必须对该元素进行定位 相对或绝对 2.在animate中第一个参数params在表示动画属性时需采用驼峰命名 如果是font-size 必须写成fontSize才有效 否则报错 c 队列中的动画 元素执行多个动画效果时,这些animate()方法执行的先后顺序形成了动画的队列 产生队列后,动画的效果便按队列的顺序进行展示 ex: $(this).animate(&#123;left:"500px"&#125;,3000).animate(&#123;top:"300px"&#125;,3000) 注: left等属性有无引号都可以 d 动画的停止和延时 stop([clearQueue],[gotoend]) 停止所选元素中正在执行的动画 可选参数[clearQueue]布尔值是否停止正在执行的动画(阻止后续运动) 可选参数[gotoend] 布尔值表示是否立即完成正在执行的动画 stop() 停止当前动画 stop(true) 停止所有动画 stop(true,true) 停止所有动画 到达动画结果 finish() 立即停止到所有指定的目标点 delay(duration,[queueName]) 推迟对列中动画的执行 duration时间值毫秒数 [queueName]动画队列6.动画回调函数 如果想在最后一步切换元素的CSS样式,而css()方法在刚开始执行动画时就执行 原因是css()方法并不会加入到动画对列中而是立即执行,可以使用callback对 非动画方法实现排队,只要把css()方法放在最后一个动画的回调函数里(非动画 元素的插队)注: toggle() 两个意思 不写参数或写一个可选参数fn时表示切换显示和隐藏 toggle(speed,[fn]) 用于元素的显示和隐藏的切换 toggle(fn1,fn2) 单击时依次调用函数 其他1234567891011121314151617181920212223242526272829303132331. serialize() 序列化表单内容为字符串,用于 Ajax 请求。2. serializeArray() 序列化表单内容为数组(json格式),返回的是JSON对象3. this.defaultValue 当前文本框的默认值4. innerWidth() width+padding outerWidth() width+padding+border outerWidth(true) width+padding+border+margin5. 工具方法 // $().xxx() 是 jQuery 对象方法 // $.xxx() 工具方法 即可给jQuery对象用,也可给原生js对象使用 a. $.type() 判断数据类型比typeof更多 ex: var a="hello" alert(typeof a)或alert($.type(a)) //string b. $.trim() 去除前后的空格 c. $.inArray() 判断数组中是否存在某字符类似indexOf ex: var arr=['a',2,"c"]; alert($.inArray('c',arr)) //2 d. $.proxy() 改变this指向 ex: $.proxy(show,document,参数) e. $.noConflict() 防止冲突的 f. $.parseJSON() 将严格模式下的json格式字符串转换成json数据 g. $.makeArray(obj).push() 将类似数组的集合转换成数组 i. $.each() 循环遍历操作元素6. 插件的扩展 a. $.extend() 扩展工具方法下的插件形式 $.xxx() ex: $.extend(&#123; leftTrim:function(str)&#123; return str.replace(/^\s+/g,''); &#125; &#125;); 调用 $.leftTrim(str) b. $.fn.extend() 扩展到JQ对象下的插件形式 $().xxx() ex: $.fn.extend(&#123; aaa:function()&#123; alert(1111); &#125; &#125;); 调用 $().aaa(); ///1111]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性问题]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多浏览器兼容性问题都是因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是前端开发人员经常会碰到和必须要解决的问题。 兼容性问题 在IE6,7下123456789101112131415161718192021222324252627282930313233343536373839404142431、html5标签的兼容 动态创建元素 然后变成块级元素html5shiv：解决ie9以下浏览器对html5新增标签的不识别，并导致CSS不起作用的问题。respond.min:让不支持css3 Media Query的浏览器包括IE6-IE8等其他浏览器支持查询。&lt;!--[if lt IE 9]&gt; &lt;script src="//cdn.bootcss.com/respond.js/1.4.2/respond.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]—&gt;2、元素浮动之后,能设置宽高的元素就给宽高,如果需要宽度是内容撑开,就给它里边的块元素加上浮动3、第一块元素浮动,第二块元素使用margin,在IE6下会出现间隙问题 采用浮动解决4、在IE6下子元素超出父级宽高,会把父级的宽高撑开 最好不要让子级宽高超过父级5、p包含块元素嵌套规则 块元素不能在包含块元素 p h1~h6 dt 产生额外元素嵌套规则： a、块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。 b、块级元素不能放在p里面。 c、有几个特殊的块级元素只能包含内联元素，不能包含块级元素。如h1,h2,h3,h4,h5,h6,p,dt d、li内可以包含div6、margin 合并(尽量使用单方向的margin值) 和 传递(加边框 出发bfc,haslayout)7、display:inline-block; 在IE6下无效 &#123;*display:inline;*zoom:1;&#125;8、IE6下最小高度18px &#123;*overflow:hidden;&#125;9、IE6,IE7下margin双边距问题 当元素浮动后就会产生margin双边距问题 &#123;*display:inline;&#125;10、li里面元素都浮动,在IE6,IE7下会产生4px间隙问题 给li加&#123;*vertical:top;&#125;11、两个浮动元素中间有注释或者有内联元素 并且和父级宽高不超过3px时,在IE6下文字自溢出 解决: 避免两个浮动元素之间出现注释 与父级宽度相差3px以上12、IE6,IE7 当子级的position:relative时,父级overflow:hidden包不住子级 解决: 给父级也添加position:relative13、IE6下绝对定位元素父级宽高是奇数,绝对定位元素的right和bottom会有1px偏差 解决: 避免给父级宽高设置奇数14、IE6下绝对定位元素和浮动元素并列时,绝对定位元素消失 解决: 给浮动元素加一个父级 不要处于同级即可15、IE6,IE7下input缝隙问题 解决: 给input元素添加浮动 input&#123;*float:left;&#125;16、IE6下输入类型表单控件背景被文字挤走的问题 解决: 给背景图片加背景图片固定属性 background-attachment:fixed17、IE6不支持PNG24问题 解决: js插件 DD_belatedPNG_0.0.8a-min.js (不能处理body上png24) css background:url(../images/button1.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src="images/button1.png");18、IE6下margin负值,无效的时候,添加相对定位即可,position:relative解决.19、文字与图片垂直居中对齐方法 解决: 为图片与文字的共同父元素所有的后代元素定义*&#123;vertical-align:middle&#125;;例如: &lt;p&gt;我要的坚强&lt;img src="i/image.gif" /&gt;&lt;/p&gt; 只需定义p*&#123;vertical-align:middle&#125;即可使文字与图片同行垂直居中. 其他 img的边缘空白间隙3px问题 给img加vertical-align或者display:block 用a标签包裹起来的img图片,在ie中有蓝色边框存在 使用 border:none或0 清楚超链接图片的蓝色边框]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css学习笔记]]></title>
    <url>%2Fcss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[层叠样式表(Cascading Style Sheets，缩写为 CSS）:用于控制网页样式,实现网页表现与内容分离,布局和美化网页一个标签可以被多个css选择器选择，共同作用，这就是“层叠式”. css引入方式123456789101112131415161718&lt;!-- 行内样式 --&gt;&lt;p style="color:#FF0000"&gt;行内样式&lt;/p&gt;&lt;!-- 内部样式(常写在head中) --&gt;&lt;style type="text/css"&gt;/*css注释*/h1&#123;color:red;&#125;&lt;/style&gt;&lt;!-- 外部样式 --&gt;&lt;link href="1.css" type="text/css" rel="stylesheet" /&gt;&lt;!-- 注:rel 当前文档与被链接文档之间的关系 --&gt;&lt;!-- 导入样式 --&gt;&lt;style type="text/css"&gt;@import "1.css"; /*最好写法 @import url(1.css)*/&lt;/style&gt;注:link和import区别a.link 不仅可以加载css可以加载其他文件 而import只能加载cssb.import页面加载完后才会加载样式c.link无兼容性问题 import不兼容低版本 css语法1234 属性 值 属性 值h1&#123;color:red;font-size:14px;&#125;选择器 声明1 声明21em约等于16px 网页中默认的字体大小为16px css选择器1234567891011121314151617181920212223241. ID选择器 #one&#123;width:100px;height:100px;&#125;2. class选择器 .one&#123;width:100px;height:100px;&#125;3. 标签选择器 p&#123;width:100px;height:100px;&#125;4. 混合选择器 把选择的元素描述的越详细越好5. 属性选择器 div[id]&#123;color:red&#125;6. 子元素选择器 h1&gt;p&#123;color:red;&#125;注:只针对h1下的直接子元素,第三代不影响 IE6不兼容7. 相邻兄弟选择器 h1+p&#123;color:red;&#125; 只会影响相邻兄弟元素后面的不会影响前面的 h1~p&#123;color:red;&#125; 选择紧随其后的所有兄弟元素8. 伪类 a:link&#123;color:black;&#125; 未访问的链接 a:visited&#123;color:pink;&#125; 已访问的链接 a:hover&#123;color:red;&#125; 鼠标移动到链接上 a:active&#123;color:yellow;&#125; 鼠标点击之后 注:IE6不支持a以外其他任何标签的伪类 伪类顺序 lvha a:link,a:visited&#123;text-decoration:none;&#125; a:hover,a:focus;a:active&#123;text-decoration:underline;&#125;9. 伪元素 :before/:after 在元素的前面或后面添加内容 配合content table:after &#123; content: "end --table"; &#125; :first-letter 对象内的第一个字符样式 :first-line 对象内第一行的样式 :not(.tew)&#123;&#125; 除了class为tew之外 css优先级1234!important&gt;js&gt;行内样式&gt;ID&gt;Class&gt;标签&gt;继承&gt;通配符行内样式&gt;内嵌样式&gt;外联样式(就近原则)注:宽度 高度使用数值百分比时,确保父元素有宽高度!important 提升指定样式的优先级 p&#123;color:red!important;&#125; css背景属性1234567891011121314151617background 背景属性background 背景复合样式:颜色 路径 重复 位置(用几个写几个)/大小 固定backgournd:#00ff00 url('images/1.jpg') no-repeat top right;background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px padding-box,background-color:red; 背景颜色background-image:url() 背景图片background-repeat:no-repeat 不重复 repeat 可以重复出现(默认) repeat-x 只能水平方向平铺 repeat-y 只能垂直方向平铺background-attachment:fixed 固定背景图片不随页面滚动 scroll 不固定(默认)background-position:X Y 设置背景图片位置(定位背景图片) X/Y 各有五个值top bottom left center right 只写一个第二个默认为center还可以是具体数值background-size:cover或100% 100% 背景图片大小(不能写在复合样式里) cover按一边的比例放大 缩放使背景全部占满盒子注:在使用background-image之前必须为元素添加宽高度(背景不占位置空间) css文本属性12345678910111213141516171819202122232425262728293031323334a.字体风格 font-family:黑体;b.字体大小 font-size:12px;c.文字颜色 font-color:red;d.文字粗细 font-weight:blod/normale.文字修饰 text-decoration:underline/line-through/overline/none/blinkf.文本对齐 text-align:left/right/justify(两端对齐)/center(文字水平方向居中)注:text-align:center 只针对行间元素有效(文字和图片)g.首行缩进 text-indent:2em 两个字体单位 字体大小改变位置不变h.行间据行高 line-height:n 文字一行显示的位置,和容器高相同文字垂直方向居中显示i.字符间距 letter-spacing:n 字符和汉字都一样 单个字符,字母间距j.词间距 word-spacing:n 单词,词语间距,注意以空格分割才识别k.转换大小写 text-transform:capitalize(每个单词首字母大写) uppercase(每个字母都转成大写) lowercase(每个字母都转成小写)l.文字样式 font-style:normal italic boldm.文本省略 overflow:hidden;white-space:nowrap;text-overflow:ellipsis;n.文本折行 word-wrap: break-word （是否保留单词换行） word-break: break-all 设定保留的单位是 字 句子 单词 （针对多字节文字是否换行） white-space:nowrap 禁止换行 （空白处是否断行）o.元素垂直对齐 vertical-align: baseline(默认值) top middle bottom注： vertical-align只能应用于内联元以及 display 值为 table-cell 的元素。注: font: italic bold 16px/400px 微软雅黑; font: font-style|font-weight|font-size/line-height|font-family 复合写法 样式 粗细 大小/行高 风格行高的测量方式: 先确定文字字体大小,多行文字之间的距离/2(即上下边距) 当行高为奇数时文字上方要比下方少一个像素,得出文字的行高.哪些属性可以继承？color、text-开头的、line-开头的、font-开头的。所有关于盒子的、定位的、布局的属性都不能继承。CSS中可以继承的属性如下：1）文本相关属性：font-family、font-size、font-style、font-variant, font-weight、font、letter-spacing、line-height、text-align、text-indent、text-transform、word-spacing、color；2）列表相关属性：list-style-image、list-style-position、list-style-type、list-style；3）表格相关属性：border-collapse、border-spacing、caption-side、table-layoute；4）其他属性：Cursor、visibility。 css盒子模型12345678910111213141516171819202122232425262728margin 隔开元素与外面(外边距)padding 隔开元素与边框(内边距)注:width 和 height只能设置盒子中内容的宽度和高度,盒子实际的宽度和高度应该加上border 和 paddingborder 边框属性border 边框复合样式 边框线粗细 边框线风格 边框线颜色border:5px solid blue;边框样式风格 solid 实线 dashed 虚线 dotted 点状线 double 双线 grove 3D(相框效果)单独定义某个边宽度或样式或颜色border-top:上边框 border-bottom:下边框 border-left:左边框 border-right:右边框border-top-color:transparent; 上边框透明border-top-width:10px; 上边框宽度border-top-style:dashed; 上边框为虚线注:border-color:不是一个值时不能写在复合样式里且必须放在border-style之前先获得边框在设置颜色后面可以有四个颜色值 没有设置border-color的时候会默认使用文字color的颜色作为边框颜色margin 外边距 外边距的负值 可以增加元素的宽度margin:0 auto; /*设置元素水平居中*/margin:3px; /*上下左右都是3px*/margin:3px 5px; /*上下3px 左右5px*/margin:3px 5px 10px /*上3px 左右5px 下10px*/margin:3px 5px 2px 8px /*上3px 右5px 下2px 左8px*/padding 内边距外边距的合并:当两个垂直外边距相遇时,外边距会进行合并(取最大者)外边距的传递(塌陷):当子元素与父元素之间没有任何间距隔开的时候子级元素的margin-top会传递给父级加上边框则不会传递或者给父级添加上内边距padding-topoutline 轮廓 就是是出现在文字/图片链接,input,button元素周围的虚线边框注:1.a,input,button&#123;outline:none;&#125; img&#123;border:none&#125;2.$&#123;a,input,buuton&#125;.focus(function()&#123;this.blur()&#125;) display属性12345678910111213141516171819202122232425a. 块级元素(display:block) 1.占据一行,后面元素换行显示 可以放任何内容 2.可控制宽高 上下边距(支持所有css命令) 常见的有 div h1-h6 p hr ul ol dl 3.没有宽度时,默认撑满一排 注: 有些块元素不可以包含另一些块元素 例如块级元素不能放在p里面 它会先结束自己将其他标签解析到外面去b. 行内元素(dispaly:inline) 1.不会独占一行,元素并排显示 不能放块级元素(a除外) 2.不支持width height line-height无效 margin padding上下无效 3.宽度，背景颜色由内容撑开 常见 b span font img input a label strong em 4.代码换行被解析 默认垂直位置为vertical-align:baseline 5.行内元素与文字的垂直居中 vertical-align:middle 6.高度会继承父级的字体大小会高出一部分 使用font-size:0 清除display用来设置元素的显示方式display:block; 块级元素显示display:inline; 行内元素显示display:inline-block;行间块级元素 以块级元素样式展示以行级元素样式排列 1.块在一行显示 2.行内属性标签支持宽高 3.没有宽度时,内容撑开宽度 4.标签之间换行间隙被解析(问题) 5.ie6,ie7不支持块标签的inline-block(问题)间隙问题：父级字体设为0，自己重新设字体 无缝衔接，不换行display:none;将隐藏指定元素及其子元素的显示 位置不保留c. 行内块元素 position定位12345678910111213141516171819202122231. fixed 固定定位 位置固定在窗口的某个位置,不管滚动条如何拖动位置不改变,脱离文档流漂浮起来原来所占空间删除相对于浏览器窗口定位ex position:fixed;left:200px;top:200px;2. relative 相对定位 元素相对于他的起点进行移动 仍处于文档流中,其所占位置空间依然存在 提升层级ex position:relative;left:200px;top:200px;3. absolute 绝对定位 精准定位元素在页面的位置,脱离文档流漂浮起来原来所占空间删除ex position:absolute;left:-20px;top:150px;注: clip:rect(上右下左) 裁剪absolute绝对定位元素框绝对定位元素它的参照物是离最近已定位的非static定位的祖先元素如果没有则相对于body定位绝对定位的元素的left,top等是不包括父级的border宽度4. z-index 层级定位 改变层叠的先后顺序 z-index:n 值越大,越在上面(仅能在定位元素上有效)5. static 静态定位(解除定位) 用JS JQ改变样式属性值或hover鼠标 把定位修改为不定位,改变为static之后 left top z-index都不生效了6. 盒子有两种方式存在于浏览器中a.绘制在画板上(static,relative)b.漂浮在画板上(absolute,fixed)注:在定位的时候 如果没有设置方向 默认就是top:0px;left:0px(左上优先于右下) absolute绝对定位元素和fixed固定定位元素 块元素宽度不会继承父级宽度而是由内容撑开 绝对定位元素具有自动伸缩的特性 除非自己指定宽度根据第一个高级特性，我们可以衍生出第二个高级特性，由于绝对行为元素具有自动伸缩的功能，如果width值为auto此时如果我们设置 left 和 right 都为0，则该元素会填充满其相对的元素，如果此时我们将宽度设置为固定值，这是绝对定位元素会优先取 left 值作为定位标志（这个标准适用于从左向右读的文档流中，而在少数从右往左读的文档中，则优先取 right）。如果这时我们将 margin 设置为auto,则绝对定位元素会呈现居中状态；其实垂直方向的作用效果是一样，垂直方向同样可以自动拉伸水平居中有一点不同的是，无论 top 和 bottom 的值设置为多少，只要相等，就可以垂直居中。 float浮动12345678910111213141516/* 浮动的框可以向左向右浮动直到它的外边缘碰到包含框或另一个浮动匡为止,设定浮动之后它就不会占据原来的空间,改变正常的文档流排列,影响到周围的元素,控制元素在同层里左浮或右浮特征: 1.改变元素为块级 2.脱离文档流 3.提升层级半级 */&#123;float:left/right 向左或向右浮动&#125;/* 如果包含框太窄,无法容纳水平排列的浮动元素,那么其他浮动元素会下移直到有足够空间(宽度不够) *//* 如果浮动元素的高度不同,那么当他们向下浮动时可能被其他浮动元素卡住(高度过高) */清除浮动 不希望原来的空间被其他元素占据相当于换行1. 在其后面设置一个清除浮动的div 设置css样式 clear:both2. 给父级定义高度(只适合高度固定的布局中)拓展不好3. 给父级元素设置overflow：hidden（拓展不好）4. after 伪类 清浮动方法 在需要清除浮动的父容器添加类名为clearfix.clear:after&#123;content:"";display:block;clear:both;&#125;.clear&#123;zoom:1;&#125;浮动的性质：脱标、贴边、字围、收缩。注: 盒子一旦用了flaot:left/right position:absolute/fixed 会隐式改变display为行内块元素position:absolute/fixed 绝对定位/固定定位元素子级的浮动可以不用写清除浮动方法 其他CSS属性123456789101112131415161718192021222324/* 溢出隐藏 */&#123;overflow:visible 内容都会显示 hidden 超出(溢出)隐藏 auto 只有超出才显示滚动条 scroll 无论溢出与否都显示滚动条&#125;/* 可见属性 */&#123;visiblity:hidden/visible;display: none/block注:使用display设置的不可见区域所占位置也一起隐藏,而使用visiblty属性设置的不可见区域所占位置保留只是元素不可见&#125;/* opacity透明 */对于IE6/7/8 使用filter:alpha(opacity=0-100)对于webkit,opera,firefox,IE9+,使用opacity:值0-1对于早期火狐 使用-moz-opacity:值0-1兼容写法&#123; opacity:.5;filter:alpha(opacity=50);-moz-opacity:.5; &#125;/* 文本溢出 */&#123; text-overflow: clip:文本被修剪 / ellipse:显示省略号代表被修剪的文本 &#125;/* 鼠标样式 */&#123; cursor:pointer/move/help;cursor:url(arrow.cur),pointer; &#125; CSS列表属性1234简写list-style:none; 去除列表前的小圆点a.list-style-image:url(); //列表项前面的图像b.list-style-position:outside/inside; //列表项目标记放置在文本以外(默认)c.list-style-type:none/square/circle/disc //列表修饰符类型 CSS hack123456789针对不同浏览器写不同css样式的过程,就叫做css hack\9 所有IE10及IE10之前 background-color:blue\9;* IE7及IE7以下 *background-color:green;_ IE6及IE6以下 _background-color:pink;+ IE6及IE7 +background-color:pink;书写顺序 background-color:red; background-color:blue\9; *background-color:green; _background-color:pink; 其他 响应式设计和布局的方法 1.隐藏不重要的部分 2.折行 3.自适应空间 将css放在页头在载人HTML元素之前,先载入他们的样式,可以避免HTML出现无样式状态 将javascript放在页尾,先将网页呈现给用户,再来加载页面的脚本,避免javascript阻塞网页的呈现减少页面空白的时间. 同时执行两个点击事件的方法 采用事件监听机制 自定义标签默认是行内元素 zoom 触发haslayout ico 标题栏图标 png图片 找ico转换工具即可&lt;link rel=&quot;shortcut icon&quot; href=&quot;./img/100du.ico&quot; /&gt; 圆角的测量方法 选择–&gt;修改–&gt;平滑–&gt;调节即可 前端常见问题1.图片做超链接时IE下蓝色边框问题 img{border:none;})2.超链接在IE下被点击时出现的轮廓问题 a,input,textarea{outline:none;}3.表单元素水平对齐 用定位或浮动4.去除按钮默认样式 border:none5.阿里图标库 http://www.iconfont.cn 找到所有要用的图标库然后把生成的文件把之前的全部覆盖6.背景透明 文字不透明 采用绝对定位 把文字图层和背景透明图层叠在一起7.禁用文本框的缩放 textarea{resize:none}8.两端对齐 最外层套一个盒子 宽度较宽 最外层父级采用溢出隐藏9.抽屉式效果最后一个元素掉下去解决办法是 给他定位10.最小宽度解决pc段项目屏幕缩小浮动元素掉下去的问题 垂直居中1234561.父元素高度不确定的文本,图片,块级元素的垂直居中 方法 通过给父容器设置相同上下边距实现的2.父元素高度确定的单行文本的垂直居中 方法 给父元素设置line-height和height高度值相同来实现3.父元素高度确定的多行文本,图片,块级元素的垂直居中 方法 使用vertical-align:middle display:tab-cell]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html学习笔记]]></title>
    <url>%2Fhtml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[超文本标记语言(Hyper Text Markup Language)，标准通用标记语言下的一个应用。HTML 不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。 Html 超文本标记语言 静态页面: 网页上的内容无法自动更新,需要通过手动在网页的代码里添加修改. 动态页面: 网页上的内容可以自动更新,不用手动在网页的代码里添加或修改.web标准是网站所有标准的集合包括 结构(html) 样式(css)和行为(js)三部分 常见web浏览器 1.Internet Explorer 2.Firefox 3.Opera 4.Safari 5.Google Chrome 常见颜色 1234Black #000000 黑色 White #FFFFFF 白色 Red #FF0000 红色 Brown #A52A2A 棕色Green #008000 绿色 Blue #0000FF 蓝色 Gray #808080 灰色 Orange #FFA500 橙色Purple #800080 紫色 Yellow #FFFF00 黄色 Silver #C0C0C0 银色 Gold #FFD700 金色Pink #FFC0CB 粉色 Cyan #00FFFF 青色 常见的ASCII码 a-97 z-122 A-65 Z-90 0-48 页面结构12345&lt;!doctype html&gt; 网页文档的第一句&lt;html&gt; 网页文档的跟标签&lt;head&gt; 网页文档的头部信息&lt;title&gt; 网页文档的标题&lt;body&gt; 网页文档的主体内容 标签分类 非可视化标签 标签不能在网页的内容区域可见 可视化标签 标签可以在网页的内容区域可见注:只有可视化标签,才能用css改变它 双标签 成对出现的标签 单标签 不能包含文本内容和子标签 写法 &lt;img /&gt;ex:img meta link base input br hr 注意事项: 单标记一定要封死 标记一定要按顺序嵌套 属性的值要写在引号之间 核心属性 id class style name &lt;!--html注释--&gt; 注释内容不能写在标记内 12345678&lt;!-- 元信息标签 meta标签 页面描述信息 --&gt;&lt;meta name="Generator" content="Editplus" /&gt; 编辑工具&lt;meta name="Keywords" content="关键字1,关键词2" /&gt; 关键词(间隔用英文逗号)&lt;meta name="Description" content="主要内容" /&gt; 描述&lt;meta name="Author" content="小伟" /&gt; 作者&lt;meta http-equiv="content-type" content="text/html;charset=utf-8" /&gt;&lt;meta charset="utf-8" /&gt; 网页所使用的语言&lt;meta http-equiv="Refresh" content="n;url=http://www.souhu.com" /&gt; 指定时间内跳转到指定的页面 网页实体12不间断空格 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; 圆角空格 &amp;emsp; &amp; 和号 &amp;amp;"" 双引号 &amp;quot; '' 单引号 &amp;apos; ® 商标 &amp;reg; © 版权 &amp;copy; 人民币 &amp;yen; 文本标记1234567891011121314151617文字标题&lt;h1&gt;标题&lt;/h1&gt; 每个页面只可以有一个(seo) h1--&gt;h6 逐渐减小段落标签&lt;p&gt;另起一行空一行&lt;/p&gt;&lt;br/&gt; 换行&lt;nobr/&gt; 强制不换行水平分隔线&lt;hr size="粗细" width="长度" align="位置" color="颜色" /&gt;文字样式&lt;font size="字体大小" face="字体风格" color="文字颜色"&gt;文本标记&lt;/font&gt;保留格式标签&lt;pre&gt;用来保留文本的空格和换行&lt;/pre&gt;文字标识标签&lt;b&gt;加粗文字&lt;/b&gt; &lt;strong&gt;强调&lt;/strong&gt;&lt;i&gt;斜体&lt;/i&gt; &lt;em&gt;斜体&lt;/em&gt;起强调作用&lt;u&gt;下划线&lt;/u&gt; &lt;s&gt;带删除线&lt;/s&gt;&lt;sup&gt;上标&lt;/sup&gt; &lt;sub&gt;下标&lt;/sub&gt; 超链接1234567891011&lt;a href="目标文档的URL"&gt;超链接名称&lt;/a&gt;&lt;a href="目标文档的URL" target="窗口打开方式" name="页面锚点名称" &gt;内容&lt;/a&gt;&lt;!-- target形式:_blank(在新窗口打开) _self(在当前窗口打开(默认)) _parent(在父窗口打开)_top(在最顶层窗口打开) framename框架名称 --&gt;&lt;a href="#"&gt;空链接(当前页面)&lt;/a&gt;&lt;a href=""&gt;会显示当前文件夹下的文件目录结构&lt;/a&gt;&lt;a name="锚点名称"&gt;锚点&lt;/a&gt; 定义锚点&lt;a href="#锚点名称"&gt;连接到锚点&lt;/a&gt;&lt;a href="目标文档的url#锚点名称"&gt;其它文档的锚点&lt;/a&gt;&lt;!-- URL 统一资源定位符 --&gt;&lt;a href="mailto:873077939@qq.com"&gt;发送邮件&lt;/a&gt; 图片的使用1234567891011121314151617181920&lt;!-- gif:压缩位图格式支持透明背景可做动画 jpg:清晰度高加载快 png:透明的,容量小bmp:清晰度不高 容量较大 --&gt;&lt;!-- 图片四要素 --&gt;&lt;img src="图片路径" alt="描述性文本" width="宽度" height="高度" /&gt;&lt;!-- alt 当不可见或加载不成功时显示的描述性文本 提供给搜索引擎用的 title 鼠标滑过时显示的文本 --&gt;&lt;!-- 图片的位置 --&gt;&lt;img src="路径" align="位置" /&gt;&lt;!-- align:bottom 底部 top 顶部 left 左边 right 右边 middle 中间 absmiddle 绝对中间 --&gt;&lt;!-- 图片与文本间距 --&gt;&lt;img src="路径" hsapce="水平间距" vspace="垂直间距"/&gt;&lt;!-- 图片超链接 --&gt;&lt;a href="url"&gt;&lt;img src="图片路径"&gt;&lt;/a&gt;注:相对路径 相对于自己的目标文档位置绝对路径 从盘符开始的路径 D:\tew\web\1.jpg 从域名出发 http://bbs.moonseo.cn/image/logo.png同一级目录 &lt;img src="1.jpg" /&gt;或&lt;img src="./1.jpg"&gt;下一级目录 &lt;img src="images/1.jpg" /&gt;上一级目录 &lt;img src="../1.jpg" /&gt;不同目录 &lt;img src="photo/1.jpg" /&gt;&lt;!-- 图片之间默认会有3px空隙 给img设置 display:block即可或更改vertical-align:middel --&gt; 列表123456789101112131415161718192021&lt;!-- 无序列表 --&gt;&lt;ul type="disc|circle|square"&gt; &lt;li&gt;disc实心圆(默认)&lt;/li&gt; &lt;li&gt;circle空心圆&lt;/li&gt; &lt;li&gt;square小方块&lt;/li&gt;&lt;/ul&gt;&lt;!-- 有序列表 --&gt;&lt;ol type="1 a A i I" start="从第几个开始"&gt; &lt;li&gt;数字序列号&lt;/li&gt; &lt;li&gt;大小写英文字母&lt;/li&gt; &lt;li&gt;大小写罗马字母&lt;/li&gt;&lt;/ol&gt;&lt;!-- 定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;计算器&lt;/dt&gt; &lt;dd&gt;用来计算的机器&lt;/dd&gt; &lt;dt&gt;显示器&lt;/dt&gt; &lt;dd&gt;以视觉方式显示信息的装置&lt;/dd&gt;&lt;/dl&gt;&lt;!-- 注:dl 列表整体结构 dt 定义列表项的名称 dd 对dt的解释说明 dt不能重复使用 dd可以重复多个 列表的嵌套应该将列表放在li里面 --&gt; 表格12345678910111213141516171819202122232425262728&lt;!-- 表格 thead tbody th tr td表格的属性 cellspacing 单元格与单元格之间的距离 border 边框cellpadding 单元格与内容之间的距离align 水平对齐方式valign 垂直对齐方式rowspan 合并行 删除后面所有合并行的最后一列colspan 合并列 删除本行中的其他列之和等于总列数bgcolor 背景颜色 background 背景图片优先于背景颜色caption 表格标题(只能定义一个) th 表头rules="all" 合并边框线(不推荐)rules="none" 不显示单元格之间的分割线 --&gt;&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;td colspan="2"&gt;注释&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;解释&lt;/td&gt; &lt;td&gt;解释&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;解释&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;!-- 行的属性 height bgcolor background align valign 垂直对齐方式 --&gt;&lt;!-- 注:表格基本样式控制table&#123; border-collapse:collapse;// 将表格设置为单线条边框 &#125;table,td,th&#123;border:1px solid black;//设置表格,行,列的边框 &#125; --&gt; 表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- 表单由三部分组成:表单标签,表单域和表单按钮 --&gt;&lt;form action="" method="" name=""&gt;&lt;/form&gt;&lt;!-- name 表单名称 action:将表单提交的内容转到响应页面method 表单提交数据的方式 1.method="post" 将数据打包发送到所指的页面对于用户不可见相对安全大小不限 2.method="get" 将提交的数据附加在地址栏上(默认),不安全,大小有限制from的作用a：直接提交表单 b:使用submit/reset按钮 c：便于浏览器保存表单 d：可以整体提取值 进行表单验证 --&gt;&lt;!-- 单行文本框 --&gt;&lt;input type="text" value="默认值" size="长度" maxlength="允许输入字符" /&gt;&lt;!-- 密码框 --&gt;&lt;input type="password" /&gt;&lt;!-- 多行文本框 --&gt;&lt;textarea wrap="self off hard"(是否允许换行) cols="" rows=""&gt;&lt;/textarea&gt;&lt;!-- 注:多行文本框不可拖动只能在css这设置resize:none; --&gt;&lt;!-- 单选框 --&gt;&lt;input type="radio" name="sex" value="男" checked="checked" /&gt;男&lt;input type="radio" name="sex" value="女"&gt;女&lt;!-- 注:单选框的name必须相同,value不能相同 --&gt;&lt;!-- 复选框 --&gt;&lt;input type="checkbox" name="ck1" checked="checked" /&gt;体育&lt;input type="checkbox" name="ck2" /&gt;文学&lt;input type="checkbox" name="ck3" /&gt;地理&lt;!-- 注:同一组的复选框name属性必须不同 --&gt;&lt;!-- 下拉列表框 --&gt;&lt;select size="可见选项数目" multiple="multiple(允许多选)"&gt; &lt;optgroup label="中国"&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt; &lt;option&gt;陕西&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="美国"&gt; &lt;option&gt;纽约&lt;/option&gt; &lt;option&gt;华盛顿&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt;&lt;!-- 隐藏域 --&gt;&lt;input type="hidden" name="hidden" value="" /&gt;&lt;!-- 文件域 --&gt;&lt;input type="file" name="" enctype="multipart/form-data" /&gt;&lt;!-- 注:enctype 告诉表单在向服务器发送数据之前数据的编码方式提交按钮 --&gt;&lt;input type="submit" value="提交" /&gt;&lt;!-- 重置按钮 --&gt;&lt;input type="reset" value="重置" /&gt;(恢复页面打开时的初始值)&lt;!-- 图像按钮 --&gt;&lt;input type="image" src="url" /&gt;&lt;!-- 定义域 --&gt;&lt;filedset&gt; &lt;legend&gt;定义域标题&lt;/legend&gt;&lt;/filedset&gt;&lt;!-- label 为input标签定义标注 将文字与input表单元素关联(绑定)起来 当用户选择该标签时,会将焦点转到和标签相关的表单控件上,label标签的for属性 应当与相关元素的id属性相同 --&gt;&lt;input type="radio" id="man" /&gt;&lt;label for="man"&gt;男&lt;/label&gt;&lt;button&gt;请点击我&lt;/button&gt;&lt;!-- 在form表单中button默认值是submit提交 一般不再form中使用,而在不写form表单时可做提交按钮使用注:文本框的限制 disabled 禁用(禁用后无法提交) readonly 只读 --&gt; 框架1234567891011&lt;frameset clos=框架宽度(水平分割) rows=框架高度(垂直分割) border=框架边框粗细 frameborder="1/0" 是否显示边框&gt;&lt;/frameset&gt;&lt;frame noresize="noresize" 框架边框不可拉伸 scrolling="yes/no" 框架是否显示滚动条 frameborder="1/0" 是否显示边框 /&gt;&lt;frameset clos="137,*"&gt; &lt;frame src="1.html" /&gt; &lt;framset rows="82,*"&gt; &lt;frame src="2.html" /&gt; &lt;frame src="3.html" /&gt; &lt;/frameset&gt;&lt;/frameset&gt;&lt;!-- 框架链接 --&gt;&lt;iframe src="" name="one" /&gt; &lt;a href="" target="one" &gt;&lt;/a&gt; 多媒体1234567891011121314&lt;!-- A:&lt;marquee&gt;会移动的文字(跑马灯)&lt;/marquee&gt; --&gt;&lt;marquee direction="right" behavior="alternate"&gt;会移动的文字(跑马灯)&lt;/marquee&gt;&lt;!-- 方向:direction="left(默认),right,up,down"方式:behavior="scroll(默认)循环滚动,slide只滚一次,alternate来回滚动"次数:loop="n" 未指定的无限循环速度:scrollamount="n" 数值越大,滚动越快(单位像素)延时:scrolldelay="毫秒数" 滚动字幕停顿时间背景颜色:bgcolor="滚动字幕背景颜色"范围:height width鼠标滑过:onmouseout="this.start()" onmouseover="this.stop()" --&gt;&lt;!-- B.&lt;embed&gt;多媒体元素插入 --&gt;&lt;embed src="" autostart="true/false" loop="true/false" /&gt;&lt;!-- C.&lt;bgsound&gt;背景音乐(只限IE) --&gt;&lt;bgsound src="" loop="n/infinate" start="" /&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
